[
  {
    "query": "java-basics",
    "llm_version": "gpt_4",
    "language": "English",
    "course_content": {
      "course_name": "Java Basics",
      "lessons": [
        {
          "title": "Checking Character Properties",
          "topics": []
        },
        {
          "title": "Comparing Strings",
          "topics": []
        },
        {
          "title": "Unicode",
          "topics": []
        },
        {
          "title": "Detecting Text Boundaries",
          "topics": []
        },
        {
          "title": "Converting Latin Digits to Other Unicode Digits",
          "topics": []
        },
        {
          "title": "Converting Non-Unicode Text",
          "topics": []
        },
        {
          "title": "Internationalization of Network Resources",
          "topics": []
        },
        {
          "title": "Service Providers for Internationalization",
          "topics": []
        }
      ],
      "content": [
        {
          "Checking Character Properties": {
            "content": "<div id=\"PageTitle\">\r\n\t<h2>\r\n\t\tChecking Character Properties</h2>\r\n</div>\r\n<div id=\"PageContent\">\r\n\t<p>\r\n\t\tYou can categorize characters according to their properties. For instance, X is an uppercase letter and 4 is a decimal digit. Checking character properties is a common way to verify the data entered by end users. If you are selling books online, for example, your order entry screen should verify that the characters in the quantity field are all digits.</p>\r\n\t<p>\r\n\t\tDevelopers who aren&#39;t used to writing global software might determine a character&#39;s properties by comparing it with character constants. For instance, they might write code like this:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>char ch;\r\n//...\r\n\r\n// This code is WRONG!\r\n\r\n// check if ch is a letter\r\nif ((ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) || (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;))\r\n    // ...\r\n\r\n// check if ch is a digit\r\nif (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)\r\n    // ...\r\n\r\n// check if ch is a whitespace\r\nif ((ch == &#39; &#39;) || (ch ==&#39;\\n&#39;) || (ch == &#39;\\t&#39;))\r\n    // ...\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe preceding code is&nbsp;wrong&nbsp;because it works only with English and a few other languages. To internationalize the previous example, replace it with the following statements:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>char ch;\r\n// ...\r\n\r\n// This code is OK!\r\n\r\nif (Character.isLetter(ch))\r\n    // ...\r\n\r\nif (Character.isDigit(ch))\r\n    // ...\r\n\r\nif (Character.isSpaceChar(ch))\r\n    // ...\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html\" target=\"_blank\"><code>Character</code></a>&nbsp;methods rely on the Unicode Standard for determining the properties of a character. Unicode is a 16-bit character encoding that supports the world&#39;s major languages. In the Java programming language&nbsp;<code>char</code>&nbsp;values represent Unicode characters. If you check the properties of a&nbsp;<code>char</code>&nbsp;with the appropriate&nbsp;<code>Character</code>&nbsp;method, your code will work with all major languages. For example, the&nbsp;<code>Character.isLetter</code>&nbsp;method returns&nbsp;<code>true</code>&nbsp;if the character is a letter in Chinese, German, Arabic, or another language.</p>\r\n\t<p>\r\n\t\tThe following list gives some of the most useful&nbsp;<code>Character</code>&nbsp;comparison methods. The&nbsp;<code>Character</code>&nbsp;API documentation fully specifies the methods.</p>\r\n\t<ul>\r\n\t\t<li>\r\n\t\t\t<code>isDigit</code></li>\r\n\t\t<li>\r\n\t\t\t<code>isLetter</code></li>\r\n\t\t<li>\r\n\t\t\t<code>isLetterOrDigit</code></li>\r\n\t\t<li>\r\n\t\t\t<code>isLowerCase</code></li>\r\n\t\t<li>\r\n\t\t\t<code>isUpperCase</code></li>\r\n\t\t<li>\r\n\t\t\t<code>isSpaceChar</code></li>\r\n\t\t<li>\r\n\t\t\t<code>isDefined</code></li>\r\n\t</ul>\r\n\t<p>\r\n\t\tThe&nbsp;<code>Character.getType</code>&nbsp;method returns the Unicode category of a character. Each category corresponds to a constant defined in the&nbsp;<code>Character</code>&nbsp;class. For instance,&nbsp;<code>getType</code>returns the&nbsp;<code>Character.UPPERCASE_LETTER</code>&nbsp;constant for the character A. For a complete list of the category constants returned by&nbsp;<code>getType</code>, see the&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html\" target=\"_blank\"><code>Character</code></a>&nbsp;API documentation. The following example shows how to use&nbsp;<code>getType</code>&nbsp;and the&nbsp;<code>Character</code>&nbsp;category constants. All of the expressions in these&nbsp;<code>if</code>&nbsp;statements are&nbsp;<code>true</code>:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>if (Character.getType(&#39;a&#39;) == Character.LOWERCASE_LETTER)\r\n    // ...\r\n\r\nif (Character.getType(&#39;R&#39;) == Character.UPPERCASE_LETTER)\r\n    // ...\r\n\r\nif (Character.getType(&#39;&gt;&#39;) == Character.MATH_SYMBOL)\r\n    // ...\r\n\r\nif (Character.getType(&#39;_&#39;) == Character.CONNECTOR_PUNCTUATION)\r\n    // ...</code></pre>\r\n\t</div>\r\n</div>"
          }
        },
        {
          "Comparing Strings": {
            "content": "<div id=\"PageContent\">\r\n\t<p>\r\n\t\tApplications that sort through text perform frequent string comparisons. For example, a report generator performs string comparisons when sorting a list of strings in alphabetical order.</p>\r\n\t<p>\r\n\t\tIf your application audience is limited to people who speak English, you can probably perform string comparisons with the&nbsp;<code>String.compareTo</code>&nbsp;method. The&nbsp;<code>String.compareTo</code>method performs a binary comparison of the Unicode characters within the two strings. For most languages, however, this binary comparison cannot be relied on to sort strings, because the Unicode values do not correspond to the relative order of the characters.</p>\r\n\t<p>\r\n\t\tFortunately the&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/text/Collator.html\" target=\"_blank\"><code>Collator</code></a>&nbsp;class allows your application to perform string comparisons for different languages. In this section, you&#39;ll learn how to use the&nbsp;<code>Collator</code>&nbsp;class when sorting text.</p>\r\n\t<div id=\"PageTitle\">\r\n\t\t<h2>\r\n\t\t\tPerforming Locale-Independent Comparisons</h2>\r\n\t</div>\r\n\t<div id=\"PageContent\">\r\n\t\t<p>\r\n\t\t\tCollation rules define the sort sequence of strings. These rules vary with locale, because various natural languages sort words differently. You can use the predefined collation rules provided by the&nbsp;<code>Collator</code>&nbsp;class to sort strings in a locale-independent manner.</p>\r\n\t\t<p>\r\n\t\t\tTo instantiate the&nbsp;<code>Collator</code>&nbsp;class invoke the&nbsp;<code>getInstance</code>&nbsp;method. Usually, you create a&nbsp;<code>Collator</code>&nbsp;for the default&nbsp;<code>Locale</code>, as in the following example:</p>\r\n\t\t<div>\r\n\t\t\t<pre>\r\n\t\t\t<code>Collator myDefaultCollator = Collator.getInstance();\r\n</code></pre>\r\n\t\t</div>\r\n\t\t<p>\r\n\t\t\tYou can also specify a particular&nbsp;<code>Locale</code>&nbsp;when you create a&nbsp;<code>Collator</code>, as follows:</p>\r\n\t\t<div>\r\n\t\t\t<pre>\r\n\t\t\t<code>Collator myFrenchCollator = Collator.getInstance(Locale.FRENCH);\r\n</code></pre>\r\n\t\t</div>\r\n\t\t<p>\r\n\t\t\tThe&nbsp;<code>getInstance</code>&nbsp;method returns a&nbsp;<code>RuleBasedCollator</code>, which is a concrete subclass of&nbsp;<code>Collator</code>. The&nbsp;<code>RuleBasedCollator</code>&nbsp;contains a set of rules that determine the sort order of strings for the locale you specify. These rules are predefined for each locale. Because the rules are encapsulated within the&nbsp;<code>RuleBasedCollator</code>, your program won&#39;t need special routines to deal with the way collation rules vary with language.</p>\r\n\t\t<p>\r\n\t\t\tYou invoke the&nbsp;<code>Collator.compare</code>&nbsp;method to perform a locale-independent string comparison. The&nbsp;<code>compare</code>&nbsp;method returns an integer less than, equal to, or greater than zero when the first string argument is less than, equal to, or greater than the second string argument. The following table contains some sample calls to&nbsp;<code>Collator.compare</code>:</p>\r\n\t\t<table border=\"1\" summary=\"Collator.compare examples\">\r\n\t\t\t<tbody>\r\n\t\t\t\t<tr>\r\n\t\t\t\t\t<th>\r\n\t\t\t\t\t\tExample</th>\r\n\t\t\t\t\t<th>\r\n\t\t\t\t\t\tReturn Value</th>\r\n\t\t\t\t\t<th>\r\n\t\t\t\t\t\tExplanation</th>\r\n\t\t\t\t</tr>\r\n\t\t\t\t<tr>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\t<code>myCollator.compare(&quot;abc&quot;, &quot;def&quot;)</code></td>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\t<code>-1</code></td>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\t<code>&quot;abc&quot;</code>&nbsp;is less than &quot;def&quot;</td>\r\n\t\t\t\t</tr>\r\n\t\t\t\t<tr>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\t<code>myCollator.compare(&quot;rtf&quot;, &quot;rtf&quot;)</code></td>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\t<code>0</code></td>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\tthe two strings are equal</td>\r\n\t\t\t\t</tr>\r\n\t\t\t\t<tr>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\t<code>myCollator.compare(&quot;xyz&quot;, &quot;abc&quot;)</code></td>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\t<code>1</code></td>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\t&quot;xyz&quot; is greater than &quot;abc&quot;</td>\r\n\t\t\t\t</tr>\r\n\t\t\t</tbody>\r\n\t\t</table>\r\n\t\t<p>\r\n\t\t\tYou use the&nbsp;<code>compare</code>&nbsp;method when performing sort operations. The sample program called&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/text/examples/CollatorDemo.java\" target=\"_blank\"><code>CollatorDemo</code></a>&nbsp;uses the&nbsp;<code>compare</code>&nbsp;method to sort an array of English and French words. This program shows what can happen when you sort the same list of words with two different collators:</p>\r\n\t\t<div>\r\n\t\t\t<pre>\r\n\t\t\t<code>Collator fr_FRCollator = Collator.getInstance(new Locale(&quot;fr&quot;,&quot;FR&quot;));\r\nCollator en_USCollator = Collator.getInstance(new Locale(&quot;en&quot;,&quot;US&quot;));\r\n</code></pre>\r\n\t\t</div>\r\n\t\t<p>\r\n\t\t\tThe method for sorting, called&nbsp;<code>sortStrings</code>, can be used with any&nbsp;<code>Collator</code>. Notice that the&nbsp;<code>sortStrings</code>&nbsp;method invokes the&nbsp;<code>compare</code>&nbsp;method:</p>\r\n\t\t<div>\r\n\t\t\t<pre>\r\n\t\t\t<code>public static void sortStrings(Collator collator, String[] words) {\r\n    String tmp;\r\n    for (int i = 0; i &lt; words.length; i++) {\r\n        for (int j = i + 1; j &lt; words.length; j++) { \r\n            if (collator.compare(words[i], words[j]) &gt; 0) {\r\n                tmp = words[i];\r\n                words[i] = words[j];\r\n                words[j] = tmp;\r\n            }\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n\t\t</div>\r\n\t\t<p>\r\n\t\t\tThe English&nbsp;<code>Collator</code>&nbsp;sorts the words as follows:</p>\r\n\t\t<div>\r\n\t\t\t<pre>\r\n\t\t\t<code>peach\r\np&eacute;ch&eacute;\r\np&ecirc;che\r\nsin\r\n</code></pre>\r\n\t\t</div>\r\n\t\t<p>\r\n\t\t\tAccording to the collation rules of the French language, the preceding list is in the wrong order. In French p&eacute;ch&eacute; should follow p&ecirc;che in a sorted list. The French&nbsp;<code>Collator</code>&nbsp;sorts the array of words correctly, as follows:</p>\r\n\t\t<div>\r\n\t\t\t<pre>\r\n\t\t\t<code>peach\r\np&ecirc;che\r\np&eacute;ch&eacute;\r\nsin</code></pre>\r\n\t\t</div>\r\n\t</div>\r\n</div>\r\n<div id=\"PageTitle\">\r\n\t<h2>\r\n\t\tCustomizing Collation Rules</h2>\r\n</div>\r\n<div id=\"PageContent\">\r\n\t<p>\r\n\t\tThe previous section discussed how to use the predefined rules for a locale to compare strings. These collation rules determine the sort order of strings. If the predefined collation rules do not meet your needs, you can design your own rules and assign them to a&nbsp;<code>RuleBasedCollator</code>&nbsp;object.</p>\r\n\t<p>\r\n\t\tCustomized collation rules are contained in a&nbsp;<code>String</code>&nbsp;object that is passed to the&nbsp;<code>RuleBasedCollator</code>&nbsp;constructor. Here&#39;s a simple example:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>String simpleRule = &quot;&lt; a &lt; b &lt; c &lt; d&quot;;\r\nRuleBasedCollator simpleCollator =  new RuleBasedCollator(simpleRule);\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tFor the&nbsp;<code>simpleCollator</code>&nbsp;object in the previous example,&nbsp;<code>a</code>&nbsp;is less than&nbsp;<code>b</code>, which is less that&nbsp;<code>c</code>, and so forth. The&nbsp;<code>simpleCollator.compare</code>&nbsp;method references these rules when comparing strings. The full syntax used to construct a collation rule is more flexible and complex than this simple example. For a full description of the syntax, refer to the API documentation for the&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/text/RuleBasedCollator.html\" target=\"_blank\"><code>RuleBasedCollator</code></a>&nbsp;class.</p>\r\n\t<p>\r\n\t\tThe example that follows sorts a list of Spanish words with two collators. Full source code for this example is in&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/text/examples/RulesDemo.java\" target=\"_blank\"><code>RulesDemo.java</code></a>.</p>\r\n\t<p>\r\n\t\tThe&nbsp;<code>RulesDemo</code>&nbsp;program starts by defining collation rules for English and Spanish. The program will sort the Spanish words in the traditional manner. When sorting by the traditional rules, the letters ch and ll and their uppercase equivalents each have their own positions in the sort order. These character pairs compare as if they were one character. For example, ch sorts as a single letter, following cz in the sort order. Note how the rules for the two collators differ:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>String englishRules = (\r\n    &quot;&lt; a,A &lt; b,B &lt; c,C &lt; d,D &lt; e,E &lt; f,F &quot; +\r\n    &quot;&lt; g,G &lt; h,H &lt; i,I &lt; j,J &lt; k,K &lt; l,L &quot; +\r\n    &quot;&lt; m,M &lt; n,N &lt; o,O &lt; p,P &lt; q,Q &lt; r,R &quot; +\r\n    &quot;&lt; s,S &lt; t,T &lt; u,U &lt; v,V &lt; w,W &lt; x,X &quot; +\r\n    &quot;&lt; y,Y &lt; z,Z&quot;);\r\n\r\nString smallnTilde = new String(&quot;\\u00F1&quot;);    // &ntilde;\r\nString capitalNTilde = new String(&quot;\\u00D1&quot;);  // &Ntilde;\r\n\r\nString traditionalSpanishRules = (\r\n    &quot;&lt; a,A &lt; b,B &lt; c,C &quot; +\r\n    &quot;&lt; ch, cH, Ch, CH &quot; +\r\n    &quot;&lt; d,D &lt; e,E &lt; f,F &quot; +\r\n    &quot;&lt; g,G &lt; h,H &lt; i,I &lt; j,J &lt; k,K &lt; l,L &quot; +\r\n    &quot;&lt; ll, lL, Ll, LL &quot; +\r\n    &quot;&lt; m,M &lt; n,N &quot; +\r\n    &quot;&lt; &quot; + smallnTilde + &quot;,&quot; + capitalNTilde + &quot; &quot; +\r\n    &quot;&lt; o,O &lt; p,P &lt; q,Q &lt; r,R &quot; +\r\n    &quot;&lt; s,S &lt; t,T &lt; u,U &lt; v,V &lt; w,W &lt; x,X &quot; +\r\n    &quot;&lt; y,Y &lt; z,Z&quot;);\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe following lines of code create the collators and invoke the sort routine:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>try {\r\n    RuleBasedCollator enCollator = new RuleBasedCollator(englishRules);\r\n    RuleBasedCollator spCollator =\r\n        new RuleBasedCollator(traditionalSpanishRules);\r\n\r\n    sortStrings(enCollator, words);\r\n    printStrings(words);\r\n    System.out.println();\r\n\r\n    sortStrings(spCollator, words);\r\n    printStrings(words);\r\n} catch (ParseException pe) {\r\n    System.out.println(&quot;Parse exception for rules&quot;);\r\n}\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe sort routine, called&nbsp;<code>sortStrings</code>, is generic. It will sort any array of words according to the rules of any&nbsp;<code>Collator</code>&nbsp;object:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>public static void sortStrings(Collator collator, String[] words) {\r\n    String tmp;\r\n    for (int i = 0; i &lt; words.length; i++) {\r\n        for (int j = i + 1; j &lt; words.length; j++) {\r\n            if (collator.compare(words[i], words[j]) &gt; 0) {\r\n                tmp = words[i];\r\n                words[i] = words[j];\r\n                words[j] = tmp;\r\n            }\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tWhen sorted with the English collation rules, the array of words is as follows:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>chalina\r\ncurioso\r\nllama\r\nluz\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tCompare the preceding list with the following, which is sorted according to the traditional Spanish rules of collation:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>curioso\r\nchalina\r\nluz\r\nllama</code></pre>\r\n\t</div>\r\n</div>\r\n<div id=\"PageTitle\">\r\n\t<h2>\r\n\t\tImproving Collation Performance</h2>\r\n</div>\r\n<div id=\"PageContent\">\r\n\t<p>\r\n\t\tSorting long lists of strings is often time consuming. If your sort algorithm compares strings repeatedly, you can speed up the process by using the&nbsp;<code>CollationKey</code>&nbsp;class.</p>\r\n\t<p>\r\n\t\tA&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/text/CollationKey.html\" target=\"_blank\"><code>CollationKey</code></a>&nbsp;object represents a sort key for a given&nbsp;<code>String</code>&nbsp;and&nbsp;<code>Collator</code>. Comparing two&nbsp;<code>CollationKey</code>&nbsp;objects involves a bitwise comparison of sort keys and is faster than comparing&nbsp;<code>String</code>&nbsp;objects with the&nbsp;<code>Collator.compare</code>&nbsp;method. However, generating&nbsp;<code>CollationKey</code>&nbsp;objects requires time. Therefore if a&nbsp;<code>String</code>&nbsp;is to be compared just once,&nbsp;<code>Collator.compare</code>&nbsp;offers better performance.</p>\r\n\t<p>\r\n\t\tThe example that follows uses a&nbsp;<code>CollationKey</code>&nbsp;object to sort an array of words. Source code for this example is in&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/text/examples/KeysDemo.java\" target=\"_blank\"><code>KeysDemo.java</code></a>.</p>\r\n\t<p>\r\n\t\tThe&nbsp;<code>KeysDemo</code>&nbsp;program creates an array of&nbsp;<code>CollationKey</code>&nbsp;objects in the&nbsp;<code>main</code>&nbsp;method. To create a&nbsp;<code>CollationKey</code>, you invoke the&nbsp;<code>getCollationKey</code>&nbsp;method on a&nbsp;<code>Collator</code>object. You cannot compare two&nbsp;<code>CollationKey</code>&nbsp;objects unless they originate from the same&nbsp;<code>Collator</code>. The&nbsp;<code>main</code>&nbsp;method is as follows:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>static public void main(String[] args) {\r\n    Collator enUSCollator = Collator.getInstance(new Locale(&quot;en&quot;,&quot;US&quot;));\r\n    String [] words = {\r\n        &quot;peach&quot;,\r\n        &quot;apricot&quot;,\r\n        &quot;grape&quot;,\r\n        &quot;lemon&quot;\r\n    };\r\n\r\n    CollationKey[] keys = new CollationKey[words.length];\r\n\r\n    for (int k = 0; k &lt; keys.length; k ++) {\r\n        keys[k] = enUSCollator. getCollationKey(words[k]);\r\n    }\r\n\r\n    sortArray(keys);\r\n    printArray(keys);\r\n}\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe&nbsp;<code>sortArray</code>&nbsp;method invokes the&nbsp;<code>CollationKey.compareTo</code>&nbsp;method. The&nbsp;<code>compareTo</code>&nbsp;method returns an integer less than, equal to, or greater than zero if the&nbsp;<code>keys[i]</code>object is less than, equal to, or greater than the&nbsp;<code>keys[j]</code>&nbsp;object. Note that the program compares the&nbsp;<code>CollationKey</code>&nbsp;objects, not the&nbsp;<code>String</code>&nbsp;objects from the original array of words. Here is the code for the&nbsp;<code>sortArray</code>&nbsp;method:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>public static void sortArray(CollationKey[] keys) {\r\n    CollationKey tmp;\r\n\r\n    for (int i = 0; i &lt; keys.length; i++) {\r\n        for (int j = i + 1; j &lt; keys.length; j++) {\r\n            if (keys[i].compareTo(keys[j]) &gt; 0) {\r\n                tmp = keys[i];\r\n                keys[i] = keys[j];\r\n                keys[j] = tmp; \r\n            }\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe&nbsp;<code>KeysDemo</code>&nbsp;program sorts an array of&nbsp;<code>CollationKey</code>&nbsp;objects, but the original goal was to sort an array of&nbsp;<code>String</code>&nbsp;objects. To retrieve the&nbsp;<code>String</code>&nbsp;representation of each&nbsp;<code>CollationKey</code>, the program invokes&nbsp;<code>getSourceString</code>&nbsp;in the&nbsp;<code>displayWords</code>&nbsp;method, as follows:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>static void displayWords(CollationKey[] keys) {\r\n    for (int i = 0; i &lt; keys.length; i++) {\r\n        System.out.println(keys[i].getSourceString());\r\n    }\r\n}\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe&nbsp;<code>displayWords</code>&nbsp;method prints the following lines:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>apricot\r\ngrape\r\nlemon\r\npeach</code></pre>\r\n\t</div>\r\n</div>"
          }
        },
        {
          "Unicode": {
            "content": "<div id=\"PageContent\">\r\n\t<p>\r\n\t\tUnicode&nbsp;is a computing industry standard designed to consistently and uniquely encode characters used in written languages throughout the world. The Unicode standard uses hexadecimal to express a character. For example, the value 0x0041 represents the Latin character A. The Unicode standard was initially designed using 16 bits to encode characters because the primary machines were 16-bit PCs.</p>\r\n\t<p>\r\n\t\tWhen the specification for the Java language was created, the Unicode standard was accepted and the&nbsp;<code>char</code>&nbsp;primitive was defined as a 16-bit data type, with characters in the hexadecimal range from 0x0000 to 0xFFFF.</p>\r\n\t<p>\r\n\t\tBecause 16-bit encoding supports 216&nbsp;(65,536) characters, which is insufficient to define all characters in use throughout the world, the Unicode standard was extended to 0x10FFFF, which supports over one million characters. The definition of a character in the Java programming language could not be changed from 16 bits to 32 bits without causing millions of Java applications to no longer run properly. To correct the definition, a scheme was developed to handle characters that could not be encoded in 16 bits.</p>\r\n\t<p>\r\n\t\tThe characters with values that are outside of the 16-bit range, and within the range from 0x10000 to 0x10FFFF, are called&nbsp;supplementary characters&nbsp;and are defined as a pair of&nbsp;<code>char</code>&nbsp;values.</p>\r\n\t<div id=\"PageTitle\">\r\n\t\t<h2>\r\n\t\t\tTerminology</h2>\r\n\t</div>\r\n\t<div id=\"PageContent\">\r\n\t\t<p>\r\n\t\t\tA&nbsp;character&nbsp;is a minimal unit of text that has semantic value.</p>\r\n\t\t<p>\r\n\t\t\tA&nbsp;character set&nbsp;is a collection of characters that might be used by multiple languages. For example, the Latin character set is used by English and most European languages, though the Greek character set is used only by the Greek language.</p>\r\n\t\t<p>\r\n\t\t\tA&nbsp;coded character set&nbsp;is a character set where each character is assigned a unique number.</p>\r\n\t\t<p>\r\n\t\t\tA&nbsp;code point&nbsp;is a value that can be used in a coded character set. A code point is a 32-bit&nbsp;<code>int</code>&nbsp;data type, where the lower 21 bits represent a valid code point value and the upper 11 bits are 0.</p>\r\n\t\t<p>\r\n\t\t\tA Unicode&nbsp;code unit&nbsp;is a 16-bit&nbsp;<code>char</code>&nbsp;value. For example, imagine a&nbsp;<code>String</code>&nbsp;that contains the letters &quot;abc&quot; followed by the Deseret LONG I, which is represented with two&nbsp;<code>char</code>values. That string contains four characters, four code points, but five code units.</p>\r\n\t\t<p>\r\n\t\t\tTo express a character in Unicode, the hexadecimal value is prefixed with the string U+. The valid code point range for the Unicode standard is U+0000 to U+10FFFF, inclusive. The code point value for the Latin character A is U+0041. The character &euro; which represents the Euro currency, has the code point value U+20AC. The first letter in the Deseret alphabet, the LONG I, has the code point value U+10400.</p>\r\n\t\t<p>\r\n\t\t\tThe following table shows code point values for several characters:</p>\r\n\t\t<table border=\"1\" cellpadding=\"2\" cellspacing=\"0\" summary=\"table listing several code points\">\r\n\t\t\t<tbody>\r\n\t\t\t\t<tr>\r\n\t\t\t\t\t<th>\r\n\t\t\t\t\t\tCharacter</th>\r\n\t\t\t\t\t<th>\r\n\t\t\t\t\t\tUnicode Code Point</th>\r\n\t\t\t\t\t<th>\r\n\t\t\t\t\t\tGlyph</th>\r\n\t\t\t\t</tr>\r\n\t\t\t\t<tr>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\tLatin A</td>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\tU+0041</td>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\t<center>\r\n\t\t\t\t\t\t\t<img alt=\"The Latin character A\" src=\"https://docs.oracle.com/javase/tutorial/figures/i18n/000041.gif\" /></center>\r\n\t\t\t\t\t</td>\r\n\t\t\t\t</tr>\r\n\t\t\t\t<tr>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\tLatin sharp S</td>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\tU+00DF</td>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\t<center>\r\n\t\t\t\t\t\t\t<img alt=\"The Latin small letter sharp S\" src=\"https://docs.oracle.com/javase/tutorial/figures/i18n/0000df.gif\" /></center>\r\n\t\t\t\t\t</td>\r\n\t\t\t\t</tr>\r\n\t\t\t\t<tr>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\tHan for East</td>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\tU+6771</td>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\t<center>\r\n\t\t\t\t\t\t\t<img alt=\"The Han character for east, eastern or eastward\" src=\"https://docs.oracle.com/javase/tutorial/figures/i18n/006771.gif\" /></center>\r\n\t\t\t\t\t</td>\r\n\t\t\t\t</tr>\r\n\t\t\t\t<tr>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\tDeseret, LONG I</td>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\tU+10400</td>\r\n\t\t\t\t\t<td>\r\n\t\t\t\t\t\t<center>\r\n\t\t\t\t\t\t\t<img alt=\"The Deseret capital letter long I\" src=\"https://docs.oracle.com/javase/tutorial/figures/i18n/010400.gif\" /></center>\r\n\t\t\t\t\t</td>\r\n\t\t\t\t</tr>\r\n\t\t\t</tbody>\r\n\t\t</table>\r\n\t\t<p>\r\n\t\t\tAs previously described, characters that are in the range U+10000 to U+10FFFF are called supplementary characters. The set of characters from U+0000 to U+FFFF are sometimes referred to as the&nbsp;Basic Multilingual Plane (BMP).</p>\r\n\t\t<p>\r\n\t\t\tMore terminology can be found in the&nbsp;Glossary of Unicode Terms, listed on the&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/text/info.html\">More Information</a>&nbsp;page.</p>\r\n\t\t<h2>\r\n\t\t\tSupplementary Characters as Surrogates</h2>\r\n\t\t<div id=\"PageContent\">\r\n\t\t\t<p>\r\n\t\t\t\tTo support supplementary characters without changing the&nbsp;<code>char</code>&nbsp;primitive data type and causing incompatibility with previous Java programs, supplementary characters are defined by a pair of code point values that are called&nbsp;surrogates. The first code point is from the&nbsp;high surrogates&nbsp;range of&nbsp;<code>U+D800</code>&nbsp;to&nbsp;<code>U+DBFF</code>, and the second code point is from the&nbsp;low surrogates&nbsp;range of&nbsp;<code>U+DC00</code>&nbsp;to&nbsp;<code>U+DFFF</code>. For example, the Deseret character LONG I,&nbsp;<code>U+10400</code>, is defined with this pair of surrogate values:&nbsp;<code>U+D801</code>&nbsp;and&nbsp;<code>U+DC00</code>.</p>\r\n\t\t\t<div id=\"PageTitle\">\r\n\t\t\t\t<h2>\r\n\t\t\t\t\tCharacter and String APIs</h2>\r\n\t\t\t</div>\r\n\t\t\t<div id=\"PageContent\">\r\n\t\t\t\t<p>\r\n\t\t\t\t\tThe&nbsp;<code>Character</code>&nbsp;class encapsulates the&nbsp;<code>char</code>&nbsp;data type. For the J2SE release 5, many methods were added to the&nbsp;<code>Character</code>&nbsp;class to support supplementary characters. This API falls into two categories: methods that convert between&nbsp;<code>char</code>&nbsp;and code point values and methods that verifiy the validity of or map code points.</p>\r\n\t\t\t\t<p>\r\n\t\t\t\t\tThis section describes a subset of the available methods in the&nbsp;<code>Character</code>&nbsp;class. For the complete list of available APIs, see the&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html\" target=\"_blank\"><code>Character</code></a>&nbsp;class specification.</p>\r\n\t\t\t\t<h3>\r\n\t\t\t\t\tConversion Methods and the Character Class</h3>\r\n\t\t\t\t<p>\r\n\t\t\t\t\tThe following table includes the most useful conversion methods, or methods that facilitate conversion, in the&nbsp;<code>Character</code>&nbsp;class. The&nbsp;<code>codePointAt</code>&nbsp;and&nbsp;<code>codePointBefore</code>methods are included in this list because text is generally found in a sequence, such as a&nbsp;<code>String</code>, and these methods can be used to extract the desired substring.</p>\r\n\t\t\t\t<table border=\"1\" summary=\"table listing the most useful conversion methods from the Character class\">\r\n\t\t\t\t\t<tbody>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<th>\r\n\t\t\t\t\t\t\t\tMethod(s)</th>\r\n\t\t\t\t\t\t\t<th>\r\n\t\t\t\t\t\t\t\tDescription</th>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#toChars-int-char:A-int-\" target=\"_blank\"><code>toChars(int codePoint, char[] dst, int dstIndex)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#toChars-int-\" target=\"_blank\"><code>toChars(int codePoint)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tConverts the specified Unicode code point to its UTF-16 representation and places it in a&nbsp;<code>char</code>&nbsp;array. Sample usage:&nbsp;<code>Character.toChars(0x10400)</code></td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#toCodePoint-char-char-\" target=\"_blank\"><code>toCodePoint(char high, char low)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#toCodePoint-java.lang.CharSequence-int-\" target=\"_blank\"><code>toCodePoint(CharSequence, int)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#toCodePoint-char:A-int-int-\" target=\"_blank\"><code>toCodePoint(char[], int, int)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tConverts the specified parameters to its supplementary code point value. The different methods accept different input formats.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#codePointAt-char:A-int-\" target=\"_blank\"><code>codePointAt(char[] a, int index)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#codePointAt-char:A-int-int-\" target=\"_blank\"><code>codePointAt(char[] a, int index, int limit)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#codePointAt-java.lang.CharSequence-int-\" target=\"_blank\"><code>codePointAt(CharSequence seq, int index)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tReturns the Unicode code point at the specified index. The third method takes a&nbsp;<code>CharSequence</code>&nbsp;and the second method enforces an upper limit on the index.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#codePointBefore-char:A-int-\" target=\"_blank\"><code>codePointBefore(char[] a, int index)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#codePointBefore-char:A-int-int-\" target=\"_blank\"><code>codePointBefore(char[] a, int index, int start)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#codePointBefore-java.lang.CharSequence-int-\" target=\"_blank\"><code>codePointBefore(CharSequence seq, int index)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#codePointBefore-char:A-int-int-\" target=\"_blank\"><code>codePointBefore(char[], int, int)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tReturns the Unicode code point before the specified index. The third method accepts a&nbsp;<code>CharSequence</code>&nbsp;and the other methods accept a&nbsp;<code>char</code>&nbsp;array. The second method enforces a lower limit on the index.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#charCount-int-\" target=\"_blank\"><code>charCount(int codePoint)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tReturns the value 1 for characters that can be represented by a single&nbsp;<code>char</code>. Returns the value 2 for supplementary characters that require two&nbsp;<code>char</code>s.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t</tbody>\r\n\t\t\t\t</table>\r\n\t\t\t\t<h3>\r\n\t\t\t\t\tVerification and Mapping Methods in the Character Class</h3>\r\n\t\t\t\t<p>\r\n\t\t\t\t\tSome of the previous methods that used the&nbsp;<code>char</code>&nbsp;primitive data type, such as&nbsp;<code>isLowerCase(char)</code>&nbsp;and&nbsp;<code>isDigit(char)</code>, were supplanted by methods that support supplementary characters, such as&nbsp;<code>isLowerCase(int)</code>&nbsp;and&nbsp;<code>isDigit(int)</code>. The previous methods are supported but do not work with supplementary characters. To create a global application and ensure that your code works seamlessly with any language, it is recommended that you use the newer forms of these methods.</p>\r\n\t\t\t\t<p>\r\n\t\t\t\t\tNote that, for performance reasons, most methods that accept a code point do not verify the validity of the code point parameter. You can use the&nbsp;<code>isValidCodePoint</code>&nbsp;method for that purpose.</p>\r\n\t\t\t\t<p>\r\n\t\t\t\t\tThe following table lists some of the verification and mapping methods in the&nbsp;<code>Character</code>&nbsp;class.</p>\r\n\t\t\t\t<table border=\"1\" summary=\"table listing verification and mapping methods in the Character class\">\r\n\t\t\t\t\t<tbody>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<th>\r\n\t\t\t\t\t\t\t\tMethod(s)</th>\r\n\t\t\t\t\t\t\t<th>\r\n\t\t\t\t\t\t\t\tDescription</th>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isValidCodePoint-int-\" target=\"_blank\"><code>isValidCodePoint(int codePoint)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tReturns true if the code point is within the range of 0x0000 to 0x10FFFF, inclusive.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isSupplementaryCodePoint-int-\" target=\"_blank\"><code>isSupplementaryCodePoint(int codePoint)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tReturns true if the code point is within the range of 0x10000 to 0x10FFFF, inclusive.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isHighSurrogate-char-\" target=\"_blank\"><code>isHighSurrogate(char)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tReturns true if the specified&nbsp;<code>char</code>&nbsp;is within the high surrogate range of \\uD800 to \\uDBFF, inclusive.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isLowSurrogate-char-\" target=\"_blank\"><code>isLowSurrogate(char)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tReturns true if the specified&nbsp;<code>char</code>&nbsp;is within the low surrogate range of \\uDC00 to \\uDFFF, inclusive.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isSurrogatePair-char-char-\" target=\"_blank\"><code>isSurrogatePair(char high, char low)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tReturns true if the specified high and low surrogate code values represent a valid surrogate pair.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#codePointCount-java.lang.CharSequence-int-int-\" target=\"_blank\"><code>codePointCount(CharSequence, int, int)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#codePointCount-char:A-int-int-\" target=\"_blank\"><code>codePointCount(char[], int, int)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tReturns the number of Unicode code points in the&nbsp;<code>CharSequence</code>, or&nbsp;<code>char</code>&nbsp;array.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isLowerCase-int-\" target=\"_blank\"><code>isLowerCase(int)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isUpperCase-int-\" target=\"_blank\"><code>isUpperCase(int)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tReturns true if the specified Unicode code point is a lowercase or uppercase character.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isDefined-int-\" target=\"_blank\"><code>isDefined(int)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tReturns true if the specified Unicode code point is defined in the Unicode standard.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isJavaIdentifierStart-char-\" target=\"_blank\"><code>isJavaIdentifierStart(char)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isJavaIdentifierStart-int-\" target=\"_blank\"><code>isJavaIdentifierStart(int)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tReturns true if the specified character or Unicode code point is permissible as the first character in a Java identifier.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isLetter-int-\" target=\"_blank\"><code>isLetter(int)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isDigit-int-\" target=\"_blank\"><code>isDigit(int)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isLetterOrDigit-int-\" target=\"_blank\"><code>isLetterOrDigit(int)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tReturns true if the specified Unicode code point is a letter, a digit, or a letter or digit.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#getDirectionality-int-\" target=\"_blank\"><code>getDirectionality(int)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tReturns the Unicode directionality property for the given Unicode code point.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Character.UnicodeBlock.html#of-int-\" target=\"_blank\"><code>Character.UnicodeBlock.of(int codePoint)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tReturns the object representing the Unicode block that contains the given Unicode code point or returns&nbsp;<code>null</code>&nbsp;if the code point is not a member of a defined block.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t</tbody>\r\n\t\t\t\t</table>\r\n\t\t\t\t<h3>\r\n\t\t\t\t\tMethods in the String Classes</h3>\r\n\t\t\t\t<p>\r\n\t\t\t\t\tThe&nbsp;<code>String</code>,&nbsp;<code>StringBuffer</code>, and&nbsp;<code>StringBuilder</code>&nbsp;classes also have contructors and methods that work with supplementary characters. The following table lists some of the commonly used methods. For the complete list of available APIs, see the javadoc for the&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html\" target=\"_blank\"><code>String</code></a>,&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html\" target=\"_blank\"><code>StringBuffer</code></a>, and&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html\" target=\"_blank\"><code>StringBuilder</code></a>&nbsp;classes.</p>\r\n\t\t\t\t<table border=\"1\" summary=\"table listing relevant methods from the String, StringBuffer and StringBuilder classes\">\r\n\t\t\t\t\t<tbody>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<th>\r\n\t\t\t\t\t\t\t\tConstructor or Methods</th>\r\n\t\t\t\t\t\t\t<th>\r\n\t\t\t\t\t\t\t\tDescription</th>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#String-int:A-int-int-\" target=\"_blank\"><code>String(int[] codePoints, int offset, int count)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tAllocates a new&nbsp;<code>String</code>&nbsp;instance that contains characters from a subarray of a Unicode code point array.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#codePointAt-int-\" target=\"_blank\"><code>String.codePointAt(int index)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#codePointAt-int-\" target=\"_blank\"><code>StringBuffer.codePointAt(int index)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html#codePointAt-int-\" target=\"_blank\"><code>StringBuilder.codePointAt(int index)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tReturns the Unicode code point at the specified index.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#codePointBefore-int-\" target=\"_blank\"><code>String.codePointBefore(int index)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#codePointBefore-int-\" target=\"_blank\"><code>StringBuffer.codePointBefore(int index)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html#codePointBefore-int-\" target=\"_blank\"><code>StringBuilder.codePointBefore(int index)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tReturns the Unicode code point before the specified index.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#codePointCount-int-int-\" target=\"_blank\"><code>String.codePointCount(int beginIndex, int endIndex)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#codePointCount-int-int-\" target=\"_blank\"><code>StringBuffer.codePointCount(int beginIndex, int endIndex)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html#codePointCount-int-int-\" target=\"_blank\"><code>StringBuilder.codePointCount(int beginIndex, int endIndex)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tReturns the number of Unicode code points in the specified range.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#appendCodePoint-int-\" target=\"_blank\"><code>StringBuffer.appendCodePoint(int codePoint)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html#appendCodePoint-int-\" target=\"_blank\"><code>StringBuilder.appendCodePoint(int codePoint)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tAppends the string representation of the specified code point to the sequence.</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#offsetByCodePoints-int-int-\" target=\"_blank\"><code>String.offsetByCodePoints(int index, int codePointOffset)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#offsetByCodePoints-int-int-\" target=\"_blank\"><code>StringBuffer.offsetByCodePoints(int index, int codePointOffset)</code></a><br />\r\n\t\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html#offsetByCodePoints-int-int-\" target=\"_blank\"><code>StringBuilder.offsetByCodePoints(int index, int codePointOffset)</code></a></td>\r\n\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\tReturns the index that is offset from the given index by the given number of code points.<br />\r\n\t\t\t\t\t\t\t\t&nbsp;</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t</tbody>\r\n\t\t\t\t</table>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</div>\r\n</div>\r\n<div id=\"PageTitle\">\r\n\t<p>\r\n\t\t&nbsp;</p>\r\n\t<h2>\r\n\t\tDesign Considerations</h2>\r\n</div>\r\n<div id=\"PageContent\">\r\n\t<p>\r\n\t\tTo write code that works seamlessly for any language using any script, there are a few things to keep in mind.</p>\r\n</div>\r\n<div id=\"PageContent\">\r\n\t<p>\r\n\t\tTo write code that works seamlessly for any language using any script, there are a few things to keep in mind.</p>\r\n\t<table border=\"1\" summary=\"design considerations to write easily localizable code\">\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tConsideration</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tReason</th>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tAvoid methods that use the&nbsp;<code>char</code>&nbsp;data type.</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tAvoid using the&nbsp;<code>char</code>&nbsp;primitive data type or methods that use the&nbsp;<code>char</code>&nbsp;data type, because code that uses that data type does not work for supplementary characters. For methods that take a&nbsp;<code>char</code>&nbsp;type parameter, use the corresponding&nbsp;<code>int</code>&nbsp;method, where available. For example, use the&nbsp;<code>Character.isDigit(int)</code>&nbsp;method rather than&nbsp;<code>Character.isDigit(char)</code>&nbsp;method.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tUse the&nbsp;<code>isValidCodePoint</code>&nbsp;method to verify code point values.</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tA code point is defined as an&nbsp;<code>int</code>&nbsp;data type, which allows for values outside of the valid range of code point values from 0x0000 to 0x10FFFF. For performance reasons, the methods that take a code point value as a parameter do not check the validity of the parameter, but you can use the&nbsp;<code>isValidCodePoint</code>&nbsp;method to check the value.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tUse the&nbsp;<code>codePointCount</code>&nbsp;method to count characters.</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe&nbsp;<code>String.length()</code>&nbsp;method returns the number of code units, or 16-bit&nbsp;<code>char</code>&nbsp;values, in the string. If the string contains supplementary characters, the count can be misleading because it will not reflect the true number of code points. To get an accurate count of the number of characters (including supplementary characters), use the&nbsp;<code>codePointCount</code>&nbsp;method.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tUse the&nbsp;<code>String.toUpperCase(int codePoint)</code>&nbsp;and&nbsp;<code>String.toLowerCase(int codePoint)</code>methods rather than the&nbsp;<code>Character.toUpperCase(int codePoint)</code>&nbsp;or&nbsp;<code>Character.toLowerCase(int codePoint)</code>&nbsp;methods.</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tWhile the&nbsp;<code>Character.toUpperCase(int)</code>&nbsp;and&nbsp;<code>Character.toLowerCase(int)</code>&nbsp;methods do work with code point values, there are some characters that cannot be converted on a one-to-one basis. The lowercase German character &szlig;, for example, becomes two characters, SS, when converted to uppercase. Likewise, the small Greek Sigma character is different depending on the position in the string. The&nbsp;<code>Character.toUpperCase(int)</code>&nbsp;and&nbsp;<code>Character.toLowerCase(int)</code>&nbsp;methods cannot handle these types of cases; however, the&nbsp;<code>String.toUpperCase</code>&nbsp;and&nbsp;<code>String.toLowerCase</code>&nbsp;methods handle these cases correctly.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tBe careful when deleting characters.</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tWhen invoking the&nbsp;<code>StringBuilder.deleteCharAt(int index)</code>&nbsp;or&nbsp;<code>StringBuffer.deleteCharAt(int index)</code>methods where the index points to a supplementary character, only the first half of that character (the first&nbsp;<code>char</code>&nbsp;value) is removed. First, invoke the&nbsp;<code>Character.charCount</code>&nbsp;method on the character to determine if one or two&nbsp;<code>char</code>&nbsp;values must be removed.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tBe careful when reversing characters in a sequence.</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tWhen invoking the&nbsp;<code>StringBuffer.reverse()</code>&nbsp;or&nbsp;<code>StringBuilder.reverse()</code>&nbsp;methods on text that contains supplementary characters, the high and low surrogate pairs are reversed which results in incorrect and possibly invalid surrogate pairs.<br />\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n\t<div id=\"PageTitle\">\r\n\t\t&nbsp;</div>\r\n</div>"
          }
        },
        {
          "Detecting Text Boundaries": {
            "content": "<div id=\"PageContent\">\r\n\t<div id=\"PageContent\">\r\n\t\t<p>\r\n\t\t\tApplications that manipulate text need to locate boundaries within the text. For example, consider some of the common functions of a word processor: highlighting a character, cutting a word, moving the cursor to the next sentence, and wrapping a word at a line ending. To perform each of these functions, the word processor must be able to detect the logical boundaries in the text. Fortunately you don&#39;t have to write your own routines to perform boundary analysis. Instead, you can take advantage of the methods provided by the&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/text/BreakIterator.html\" target=\"_blank\"><code>BreakIterator</code>&nbsp;</a>class.</p>\r\n\t</div>\r\n</div>\r\n<div id=\"PageTitle\">\r\n\t<h2>\r\n\t\tAbout the BreakIterator Class</h2>\r\n</div>\r\n<div id=\"PageContent\">\r\n\t<p>\r\n\t\tThe&nbsp;<code>BreakIterator</code>&nbsp;class is locale-sensitive, because text boundaries vary with language. For example, the syntax rules for line breaks are not the same for all languages. To determine which locales the&nbsp;<code>BreakIterator</code>&nbsp;class supports, invoke the&nbsp;<code>getAvailableLocales</code>&nbsp;method, as follows:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>Locale[] locales = BreakIterator.getAvailableLocales();\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tYou can analyze four kinds of boundaries with the&nbsp;<code>BreakIterator</code>&nbsp;class: character, word, sentence, and potential line break. When instantiating a&nbsp;<code>BreakIterator</code>, you invoke the appropriate factory method:</p>\r\n\t<ul>\r\n\t\t<li>\r\n\t\t\t<code>getCharacterInstance</code></li>\r\n\t\t<li>\r\n\t\t\t<code>getWordInstance</code></li>\r\n\t\t<li>\r\n\t\t\t<code>getSentenceInstance</code></li>\r\n\t\t<li>\r\n\t\t\t<code>getLineInstance</code></li>\r\n\t</ul>\r\n\t<p>\r\n\t\tEach instance of&nbsp;<code>BreakIterator</code>&nbsp;can detect just one type of boundary. If you want to locate both character and word boundaries, for example, you create two separate instances.</p>\r\n\t<p>\r\n\t\tA&nbsp;<code>BreakIterator</code>&nbsp;has an imaginary cursor that points to the current boundary in a string of text. You can move this cursor within the text with the&nbsp;<code>previous</code>&nbsp;and the&nbsp;<code>next</code>&nbsp;methods. For example, if you&#39;ve created a&nbsp;<code>BreakIterator</code>&nbsp;with&nbsp;<code>getWordInstance</code>, the cursor moves to the next word boundary in the text every time you invoke the&nbsp;<code>next</code>&nbsp;method. The cursor-movement methods return an integer indicating the position of the boundary. This position is the index of the character in the text string that would follow the boundary. Like string indexes, the boundaries are zero-based. The first boundary is at 0, and the last boundary is the length of the string. The following figure shows the word boundaries detected by the&nbsp;<code>next</code>&nbsp;and&nbsp;<code>previous</code>&nbsp;methods in a line of text:</p>\r\n\t<p>\r\n\t\t[[ image(java/figure.gif, center) ]]</p>\r\n\t<center>\r\n\t\t<p>\r\n\t\t\tThis figure has been reduced to fit on the page.&nbsp;</p>\r\n\t</center>\r\n\t<p>\r\n\t\tYou should use the&nbsp;<code>BreakIterator</code>&nbsp;class only with natural-language text. To tokenize a programming language, use the&nbsp;<code>StreamTokenizer</code>&nbsp;class.The sections that follow give examples for each type of boundary analysis. The coding examples are from the source code file named&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/text/examples/BreakIteratorDemo.java\" target=\"_blank\"><code>BreakIteratorDemo.java</code></a>.</p>\r\n\t<div id=\"PageTitle\">\r\n\t\t<h2>\r\n\t\t\tCharacter Boundaries</h2>\r\n\t</div>\r\n\t<div id=\"PageContent\">\r\n\t\t<p>\r\n\t\t\tYou need to locate character boundaries if your application allows the end user to highlight individual characters or to move a cursor through text one character at a time. To create a&nbsp;<code>BreakIterator</code>&nbsp;that locates character boundaries, you invoke the&nbsp;<code>getCharacterInstance</code>&nbsp;method, as follows:</p>\r\n\t\t<div>\r\n\t\t\t<pre>\r\n\t\t\t<code>BreakIterator characterIterator =\r\n    BreakIterator.getCharacterInstance(currentLocale);\r\n</code></pre>\r\n\t\t</div>\r\n\t\t<p>\r\n\t\t\tThis type of&nbsp;<code>BreakIterator</code>&nbsp;detects boundaries between user characters, not just Unicode characters.</p>\r\n\t\t<p>\r\n\t\t\tA user character may be composed of more than one Unicode character. For example, the user character &uuml; can be composed by combining the Unicode characters \\u0075 (u) and \\u00a8 (&uml;). This isn&#39;t the best example, however, because the character &uuml; may also be represented by the single Unicode character \\u00fc. We&#39;ll draw on the Arabic language for a more realistic example.</p>\r\n\t\t<p>\r\n\t\t\tIn Arabic the word for house is:</p>\r\n\t\t<p>\r\n\t\t\t[[ image(java/glyph .gif, center) ]]</p>\r\n\t\t<p>\r\n\t\t\tThis word contains three user characters, but it is composed of the following six Unicode characters:</p>\r\n\t\t<div>\r\n\t\t\t<pre>\r\n\t\t\t<code>String house = &quot;\\u0628&quot; + &quot;\\u064e&quot; + &quot;\\u064a&quot; + &quot;\\u0652&quot; + &quot;\\u067a&quot; + &quot;\\u064f&quot;;\r\n</code></pre>\r\n\t\t</div>\r\n\t\t<p>\r\n\t\t\tThe Unicode characters at positions 1, 3, and 5 in the&nbsp;<code>house</code>&nbsp;string are diacritics. Arabic requires diacritics because they can alter the meanings of words. The diacritics in the example are nonspacing characters, since they appear above the base characters. In an Arabic word processor you cannot move the cursor on the screen once for every Unicode character in the string. Instead you must move it once for every user character, which may be composed by more than one Unicode character. Therefore you must use a&nbsp;<code>BreakIterator</code>&nbsp;to scan the user characters in the string.</p>\r\n\t\t<p>\r\n\t\t\tThe sample program&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/text/examples/BreakIteratorDemo.java\" target=\"_blank\"><code>BreakIteratorDemo</code></a>, creates a&nbsp;<code>BreakIterator</code>&nbsp;to scan Arabic characters. The program passes this&nbsp;<code>BreakIterator</code>, along with the&nbsp;<code>String</code>&nbsp;object created previously, to a method named&nbsp;<code>listPositions</code>:</p>\r\n\t\t<div>\r\n\t\t\t<pre>\r\n\t\t\t<code>BreakIterator arCharIterator = BreakIterator.getCharacterInstance(\r\n                                   new Locale (&quot;ar&quot;,&quot;SA&quot;));\r\nlistPositions (house, arCharIterator);\r\n</code></pre>\r\n\t\t</div>\r\n\t\t<p>\r\n\t\t\tThe&nbsp;<code>listPositions</code>&nbsp;method uses a&nbsp;<code>BreakIterator</code>&nbsp;to locate the character boundaries in the string. Note that the&nbsp;<code>BreakIteratorDemo</code>&nbsp;assigns a particular string to the&nbsp;<code>BreakIterator</code>&nbsp;with the&nbsp;<code>setText</code>&nbsp;method. The program retrieves the first character boundary with the&nbsp;<code>first</code>&nbsp;method and then invokes the&nbsp;<code>next</code>&nbsp;method until the constant&nbsp;<code>BreakIterator.DONE</code>&nbsp;is returned. The code for this routine is as follows:</p>\r\n\t\t<div>\r\n\t\t\t<pre>\r\n\t\t\t<code>static void listPositions(String target, BreakIterator iterator) {\r\n                \r\n    iterator.setText(target);\r\n    int boundary = iterator.first();\r\n\r\n    while (boundary != BreakIterator.DONE) {\r\n        System.out.println (boundary);\r\n        boundary = iterator.next();\r\n    }\r\n}\r\n</code></pre>\r\n\t\t</div>\r\n\t\t<p>\r\n\t\t\tThe&nbsp;<code>listPositions</code>&nbsp;method prints out the following boundary positions for the user characters in the string&nbsp;<code>house</code>. Note that the positions of the diacritics (1, 3, 5) are not listed:</p>\r\n\t\t<div>\r\n\t\t\t<pre>\r\n\t\t\t<code>0\r\n2\r\n4\r\n6</code></pre>\r\n\t\t</div>\r\n\t</div>\r\n</div>\r\n<div id=\"PageTitle\">\r\n\t<h2>\r\n\t\tWord Boundaries</h2>\r\n</div>\r\n<div id=\"PageContent\">\r\n\t<p>\r\n\t\tYou invoke the&nbsp;<code>getWordIterator</code>&nbsp;method to instantiate a&nbsp;<code>BreakIterator</code>&nbsp;that detects word boundaries:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>BreakIterator wordIterator =\r\n    BreakIterator.getWordInstance(currentLocale);\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tYou&#39;ll want to create such a&nbsp;<code>BreakIterator</code>&nbsp;when your application needs to perform operations on individual words. These operations might be common word- processing functions, such as selecting, cutting, pasting, and copying. Or, your application may search for words, and it must be able to distinguish entire words from simple strings.</p>\r\n\t<p>\r\n\t\tWhen a&nbsp;<code>BreakIterator</code>&nbsp;analyzes word boundaries, it differentiates between words and characters that are not part of words. These characters, which include spaces, tabs, punctuation marks, and most symbols, have word boundaries on both sides.</p>\r\n\t<p>\r\n\t\tThe example that follows, which is from the program&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/text/examples/BreakIteratorDemo.java\" target=\"_blank\"><code>BreakIteratorDemo</code></a>, marks the word boundaries in some text. The program creates the&nbsp;<code>BreakIterator</code>&nbsp;and then calls the&nbsp;<code>markBoundaries</code>&nbsp;method:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>Locale currentLocale = new Locale (&quot;en&quot;,&quot;US&quot;);\r\n\r\nBreakIterator wordIterator =\r\n    BreakIterator.getWordInstance(currentLocale);\r\n\r\nString someText = &quot;She stopped. &quot; +\r\n    &quot;She said, \\&quot;Hello there,\\&quot; and then went &quot; +\r\n    &quot;on.&quot;;\r\n\r\nmarkBoundaries(someText, wordIterator);\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe&nbsp;<code>markBoundaries</code>&nbsp;method is defined in&nbsp;<code>BreakIteratorDemo.java</code>. This method marks boundaries by printing carets (^) beneath the target string. In the code that follows, notice the&nbsp;<code>while</code>&nbsp;loop where&nbsp;<code>markBoundaries</code>&nbsp;scans the string by calling the&nbsp;<code>next</code>&nbsp;method:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>static void markBoundaries(String target, BreakIterator iterator) {\r\n\r\n    StringBuffer markers = new StringBuffer();\r\n    markers.setLength(target.length() + 1);\r\n    for (int k = 0; k &lt; markers.length(); k++) {\r\n        markers.setCharAt(k,&#39; &#39;);\r\n    }\r\n\r\n    iterator.setText(target);\r\n    int boundary = iterator.first();\r\n\r\n    while (boundary != BreakIterator.DONE) {\r\n        markers.setCharAt(boundary,&#39;^&#39;);\r\n        boundary = iterator.next();\r\n    }\r\n\r\n    System.out.println(target);\r\n    System.out.println(markers);\r\n}\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe output of the&nbsp;<code>markBoundaries</code>&nbsp;method follows. Note where the carets (^) occur in relation to the punctuation marks and spaces:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>She stopped.  She said, &quot;Hello there,&quot; and then\r\n^  ^^      ^^ ^  ^^   ^^^^    ^^    ^^^^  ^^   ^\r\n\r\nwent on.\r\n^   ^^ ^^\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe&nbsp;<code>BreakIterator</code>&nbsp;class makes it easy to select words from within text. You don&#39;t have to write your own routines to handle the punctuation rules of various languages; the&nbsp;<code>BreakIterator</code>&nbsp;class does this for you.</p>\r\n\t<p>\r\n\t\tThe&nbsp;<code>extractWords</code>&nbsp;method in the following example extracts and prints words for a given string. Note that this method uses&nbsp;<code>Character.isLetterOrDigit</code>&nbsp;to avoid printing &quot;words&quot; that contain space characters.</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>static void extractWords(String target, BreakIterator wordIterator) {\r\n\r\n    wordIterator.setText(target);\r\n    int start = wordIterator.first();\r\n    int end = wordIterator.next();\r\n\r\n    while (end != BreakIterator.DONE) {\r\n        String word = target.substring(start,end);\r\n        if (Character.isLetterOrDigit(word.charAt(0))) {\r\n            System.out.println(word);\r\n        }\r\n        start = end;\r\n        end = wordIterator.next();\r\n    }\r\n}\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe&nbsp;<code>BreakIteratorDemo</code>&nbsp;program invokes&nbsp;<code>extractWords</code>, passing it the same target string used in the previous example. The&nbsp;<code>extractWords</code>&nbsp;method prints out the following list of words:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>She\r\nstopped\r\nShe\r\nsaid\r\nHello\r\nthere\r\nand\r\nthen\r\nwent\r\non</code></pre>\r\n\t</div>\r\n</div>\r\n<div id=\"PageTitle\">\r\n\t<h2>\r\n\t\tSentence Boundaries</h2>\r\n</div>\r\n<div id=\"PageContent\">\r\n\t<p>\r\n\t\tYou can use a&nbsp;<code>BreakIterator</code>&nbsp;to determine sentence boundaries. You start by creating a&nbsp;<code>BreakIterator</code>&nbsp;with the&nbsp;<code>getSentenceInstance</code>&nbsp;method:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>BreakIterator sentenceIterator =\r\n    BreakIterator.getSentenceInstance(currentLocale);\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tTo show the sentence boundaries, the program uses the&nbsp;<code>markBoundaries</code>&nbsp;method, which is discussed in the section&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/text/word.html\">Word Boundaries</a>. The&nbsp;<code>markBoundaries</code>&nbsp;method prints carets (^) beneath a string to indicate boundary positions. Here are some examples:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>She stopped.  She said, &quot;Hello there,&quot; and then went on.\r\n^             ^                                         ^\r\n\r\nHe&#39;s vanished!  What will we do?  It&#39;s up to us.\r\n^               ^                 ^             ^\r\n\r\nPlease add 1.5 liters to the tank.</code></pre>\r\n\t</div>\r\n</div>\r\n<div id=\"PageTitle\">\r\n\t<h2>\r\n\t\tLine Boundaries</h2>\r\n</div>\r\n<div id=\"PageContent\">\r\n\t<p>\r\n\t\tApplications that format text or that perform line wrapping must locate potential line breaks. You can find these line breaks, or boundaries, with a&nbsp;<code>BreakIterator</code>&nbsp;that has been created with the&nbsp;<code>getLineInstance</code>&nbsp;method:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>BreakIterator lineIterator =\r\n    BreakIterator.getLineInstance(currentLocale);\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThis&nbsp;<code>BreakIterator</code>&nbsp;determines the positions in a string where text can break to continue on the next line. The positions detected by the&nbsp;<code>BreakIterator</code>&nbsp;are potential line breaks. The actual line breaks displayed on the screen may not be the same.</p>\r\n\t<p>\r\n\t\tThe two examples that follow use the&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/text/word.html#markBoundaries\"><code>markBoundaries</code></a>&nbsp;method of&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/text/examples/BreakIteratorDemo.java\" target=\"_blank\"><code>BreakIteratorDemo.java</code></a>&nbsp;to show the line boundaries detected by a&nbsp;<code>BreakIterator</code>. The&nbsp;<code>markBoundaries</code>&nbsp;method indicates line boundaries by printing carets (^) beneath the target string.</p>\r\n\t<p>\r\n\t\tAccording to a&nbsp;<code>BreakIterator</code>, a line boundary occurs after the termination of a sequence of whitespace characters (space, tab, new line). In the following example, note that you can break the line at any of the boundaries detected:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>She stopped.  She said, &quot;Hello there,&quot; and then went on.\r\n^   ^         ^   ^     ^      ^     ^ ^   ^    ^    ^  ^\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tPotential line breaks also occur immediately after a hyphen:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>There are twenty-four hours in a day.\r\n^     ^   ^      ^    ^     ^  ^ ^   ^\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe next example breaks a long string of text into fixed-length lines with a method called&nbsp;<code>formatLines</code>. This method uses a&nbsp;<code>BreakIterator</code>&nbsp;to locate the potential line breaks. The&nbsp;<code>formatLines</code>&nbsp;method is short, simple, and, thanks to the&nbsp;<code>BreakIterator</code>, locale-independent. Here is the source code:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>static void formatLines(\r\n    String target, int maxLength,\r\n    Locale currentLocale) {\r\n\r\n    BreakIterator boundary = BreakIterator.\r\n        getLineInstance(currentLocale);\r\n    boundary.setText(target);\r\n    int start = boundary.first();\r\n    int end = boundary.next();\r\n    int lineLength = 0;\r\n\r\n    while (end != BreakIterator.DONE) {\r\n        String word = target.substring(start,end);\r\n        lineLength = lineLength + word.length();\r\n        if (lineLength &gt;= maxLength) {\r\n            System.out.println();\r\n            lineLength = word.length();\r\n        }\r\n        System.out.print(word);\r\n        start = end;\r\n        end = boundary.next();\r\n    }\r\n}\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe&nbsp;<code>BreakIteratorDemo</code>&nbsp;program invokes the&nbsp;<code>formatLines</code>&nbsp;method as follows:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>String moreText =\r\n    &quot;She said, \\&quot;Hello there,\\&quot; and then &quot; +\r\n    &quot;went on down the street. When she stopped &quot; +\r\n    &quot;to look at the fur coats in a shop + &quot;\r\n    &quot;window, her dog growled. \\&quot;Sorry Jake,\\&quot; &quot; +\r\n    &quot;she said. \\&quot;I didn&#39;t know you would take &quot; +\r\n    &quot;it personally.\\&quot;&quot;;\r\n\r\nformatLines(moreText, 30, currentLocale);\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe output from this call to&nbsp;<code>formatLines</code>&nbsp;is:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>She said, &quot;Hello there,&quot; and\r\nthen went on down the\r\nstreet. When she stopped to\r\nlook at the fur coats in a\r\nshop window, her dog\r\ngrowled. &quot;Sorry Jake,&quot; she\r\nsaid. &quot;I didn&#39;t know you\r\nwould take it personally.&quot;</code></pre>\r\n\t</div>\r\n</div>"
          }
        },
        {
          "Converting Latin Digits to Other Unicode Digits": {
            "content": "<p>\r\n\tBy default, when text contains numeric values, those values are displayed using Latin (European) digits. When other Unicode digit shapes are preferred, use the<a href=\"https://docs.oracle.com/javase/8/docs/api/java/awt/font/NumericShaper.html\" target=\"_blank\"><code>java.awt.font.NumericShaper</code></a>&nbsp;class. The&nbsp;<code>NumericShaper</code>&nbsp;API enables you to display a numeric value represented internally as an ASCII value in any Unicode digit shape.</p>\r\n<p>\r\n\tThe following code snippet, from the&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/text/examples/ArabicDigits.java\" target=\"_blank\"><code>ArabicDigits</code></a>&nbsp;example, shows how to use a&nbsp;<code>NumericShaper</code>&nbsp;instance to convert Latin digits to Arabic digits. The line that determines the shaping action is bolded.</p>\r\n<div>\r\n\t<pre>\r\n\t<code>ArabicDigitsPanel(String fontname) {\r\n    HashMap map = new HashMap();\r\n    Font font = new Font(fontname, Font.PLAIN, 60);\r\n    map.put(TextAttribute.FONT, font);\r\n    <strong>map.put(TextAttribute.NUMERIC_SHAPING,\r\n        NumericShaper.getShaper(NumericShaper.ARABIC));</strong>\r\n\r\n    FontRenderContext frc = new FontRenderContext(null, false, false);\r\n    layout = new TextLayout(text, map, frc);\r\n}\r\n\r\n// ...\r\n\r\npublic void paint(Graphics g) {\r\n    Graphics2D g2d = (Graphics2D)g;\r\n    layout.draw(g2d, 10, 50);\r\n}\r\n</code></pre>\r\n</div>\r\n<p>\r\n\tThe&nbsp;<code>NumericShaper</code>&nbsp;instance for Arabic digits is fetched and placed into a&nbsp;<code>HashMap</code>&nbsp;for the&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/awt/font/TextAttribute.html#NUMERIC_SHAPING\" target=\"_blank\"><code>TextLayout.NUMERIC_SHAPING</code></a>&nbsp;attribute key. The hash map is passed to the&nbsp;<code>TextLayout</code>&nbsp;instance. After rendering the text in the&nbsp;<code>paint</code>&nbsp;method, the digits are displayed in the desired script. In this example, the Latin digits, 0 through 9, are drawn as Arabic digits.</p>\r\n<p>\r\n\t[[ image(java/arabic_digits.png, center) ]]</p>\r\n<p>\r\n\tThe previous example uses the&nbsp;<code>NumericShaper.ARABIC</code>&nbsp;constant to retrieve the desired shaper, but the&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/awt/font/NumericShaper.html#field_summary\" target=\"_blank\"><code>NumericShaper</code></a>&nbsp;class provides constants for many languages. These constants are defined as bit masks and are referred to as the&nbsp;<code>NumericShaper</code>&nbsp;bit mask-based constants.</p>\r\n<h2>\r\n\tEnum-Based Range Constants</h2>\r\n<p>\r\n\tAn alternative way to specify a particular set of digits is to use the&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/awt/font/NumericShaper.Range.html\" target=\"_blank\"><code>NumericShaper.Range</code></a>&nbsp;enumerated type (enum). This enum, introduced in the Java SE 7 release, also provides a set of&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/awt/font/NumericShaper.Range.html#field_summary\" target=\"_blank\">constants</a>. Although these constants are defined using different mechanisms, the&nbsp;<code>NumericShaper.ARABIC</code>&nbsp;bit mask is functionally equivalent to the&nbsp;<code>NumericShaper.Range.ARABIC</code>&nbsp;enum, and there is a corresponding&nbsp;<code>getShaper</code>&nbsp;method for each constant type:</p>\r\n<ul>\r\n\t<li>\r\n\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/awt/font/NumericShaper.html#getShaper-int-\" target=\"_blank\"><code>getShaper(int singleRange)</code></a></li>\r\n\t<li>\r\n\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/awt/font/NumericShaper.html#getShaper-java.awt.font.NumericShaper.Range-\" target=\"_blank\"><code>getShaper(NumericShaper.Range singleRange)</code></a></li>\r\n</ul>\r\n<p>\r\n\tThe&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/text/examples/ArabicDigitsEnum.java\" target=\"_blank\"><code>ArabicDigitsEnum</code></a>&nbsp;example is identical to the ArabicDigits example, except it uses the&nbsp;<code>NumericShaper.Range</code>&nbsp;enum to specify the language script:</p>\r\n<div>\r\n\t<pre>\r\n\t<code>ArabicDigitsEnumPanel(String fontname) {\r\n    HashMap map = new HashMap();\r\n    Font font = new Font(fontname, Font.PLAIN, 60);\r\n    map.put(TextAttribute.FONT, font);\r\n    <strong>map.put(TextAttribute.NUMERIC_SHAPING,\r\n        NumericShaper.getShaper(NumericShaper.Range.ARABIC));</strong>\r\n    FontRenderContext frc = new FontRenderContext(null, false, false);\r\n    layout = new TextLayout(text, map, frc);\r\n}\r\n</code></pre>\r\n</div>\r\n<p>\r\n\tBoth&nbsp;<code>getShaper</code>&nbsp;methods accept a&nbsp;<code>singleRange</code>&nbsp;parameter. With either constant type, you can specify a range of script-specific digits. The bit mask-based constants can be combined using the&nbsp;<code>OR</code>&nbsp;operand, or you can create a set of&nbsp;<code>NumericShaper.Range</code>&nbsp;enums. The following shows how to define a range using each constant type:</p>\r\n<div>\r\n\t<pre>\r\n\t<code>NumericShaper.MONGOLIAN | NumericShaper.THAI |\r\nNumericShaper.TIBETAN\r\nEnumSet.of(\r\n    NumericShaper.Range.MONGOLIAN,\r\n    NumericShaper.Range.THAI,\r\n    NumericShaper.Range.TIBETAN)\r\n</code></pre>\r\n</div>\r\n<p>\r\n\tYou can query the&nbsp;<code>NumericShaper</code>&nbsp;object to determine which ranges it supports using either the&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/awt/font/NumericShaper.html#getRanges--\" target=\"_blank\"><code>getRanges</code></a>&nbsp;method for bit mask-based shapers or the&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/awt/font/NumericShaper.html#getRangeSet--\" target=\"_blank\"><code>getRangeSet</code></a>&nbsp;method for enum-based shapers.</p>\r\n<div>\r\n\t<blockquote>\r\n\t\t<p>\r\n\t\t\t<strong>Note:</strong></p>\r\n\t\t<p>\r\n\t\t\tYou can use either the traditional bit masked-based constants or the&nbsp;<code>Range</code>&nbsp;enum-based constants. Here are some considerations when deciding which to use:</p>\r\n\t\t<ul>\r\n\t\t\t<li>\r\n\t\t\t\tThe&nbsp;<code>Range</code>&nbsp;API requires JDK 7 or later.</li>\r\n\t\t\t<li>\r\n\t\t\t\tThe&nbsp;<code>Range</code>&nbsp;API covers more Unicode ranges than the bit-masked API.</li>\r\n\t\t\t<li>\r\n\t\t\t\tThe bit-mask API is a bit faster than the&nbsp;<code>Range</code>&nbsp;API.</li>\r\n\t\t</ul>\r\n\t</blockquote>\r\n</div>\r\n<h2>\r\n\tRendering Digits According to Language Context</h2>\r\n<p>\r\n\tThe&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/text/examples/ArabicDigits.java\" target=\"_blank\"><code>ArabicDigits</code></a>&nbsp;example was designed to use the shaper for a specific language, but sometimes the digits must be rendered according to the language context. For example, if the text that precedes the digits uses the Thai script, Thai digits are preferred. If the text is displayed in Tibetan, Tibetan digits are preferred.</p>\r\n<p>\r\n\tYou can accomplish this using one of the&nbsp;<code>getContextualShaper</code>&nbsp;methods:</p>\r\n<ul>\r\n\t<li>\r\n\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/awt/font/NumericShaper.html#getContextualShaper-int-\" target=\"_blank\">getContextualShaper(int ranges)</a></li>\r\n\t<li>\r\n\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/awt/font/NumericShaper.html#getContextualShaper-int-int-\" target=\"_blank\">getContextualShaper(int ranges, int defaultContext)</a></li>\r\n\t<li>\r\n\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/awt/font/NumericShaper.html#getContextualShaper-java.util.Set-\" target=\"_blank\">getContextualShaper(Set&lt;NumericShaper.Range&gt; ranges)</a></li>\r\n\t<li>\r\n\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/awt/font/NumericShaper.html#getContextualShaper-java.util.Set-java.awt.font.NumericShaper.Range-\" target=\"_blank\">getContextualShaper(Set&lt;NumericShaper.Range&gt; ranges, NumericShaper.Range defaultContext)</a></li>\r\n</ul>\r\n<p>\r\n\tThe first two methods use the bit-mask constants, and the last two use the enum constants. The methods that accept a&nbsp;<code>defaultContext</code>&nbsp;parameter enable you to specify the initial shaper that is used when numeric values are displayed before text. When no default context is defined, any leading digits are displayed using Latin shapes.</p>\r\n<p>\r\n\tThe&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/text/examples/ShapedDigits.java\" target=\"_blank\"><code>ShapedDigits</code></a>&nbsp;example shows how shapers work. Five text layouts are displayed:</p>\r\n<ol>\r\n\t<li>\r\n\t\tThe first layout uses no shaper; all digits are displayed as Latin.</li>\r\n\t<li>\r\n\t\tThe second layout shapes all digits as Arabic digits, regardless of language context.</li>\r\n\t<li>\r\n\t\tThe third layout employs a contextual shaper that uses Arabic digits. The default context is defined to be Arabic.</li>\r\n\t<li>\r\n\t\tThe fourth layout employs a contextual shaper that uses Arabic digits, but the shaper does not specify a default context.</li>\r\n\t<li>\r\n\t\tThe fifth layout employs a contextual shaper that uses the&nbsp;<code>ALL_RANGES</code>&nbsp;bit mask, but the shaper does not specify a default context.</li>\r\n</ol>\r\n<p>\r\n\t[[ image(java/shaped_digits.png, center) ]]</p>\r\n<p>\r\n\tThe following lines of code show how the shapers, if used, are defined:</p>\r\n<ol>\r\n\t<li>\r\n\t\tNo shaper is used.</li>\r\n\t<li>\r\n\t\t<code>NumericShaper arabic = NumericShaper.getShaper(NumericShaper.ARABIC);</code></li>\r\n\t<li>\r\n\t\t<code>NumericShaper contextualArabic = NumericShaper.getContextualShaper(NumericShaper.ARABIC, NumericShaper.ARABIC);</code></li>\r\n\t<li>\r\n\t\t<code>NumericShaper contextualArabicASCII = NumericShaper.getContextualShaper(NumericShaper.ARABIC);</code></li>\r\n\t<li>\r\n\t\t<code>NumericShaper contextualAll = NumericShaper.getContextualShaper(NumericShaper.ALL_RANGES);</code></li>\r\n</ol>\r\n<p>\r\n\tSee the&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/text/examples/ShapedDigits.java\" target=\"_blank\"><code>ShapedDigits.java</code></a>&nbsp;example for further implementation details.</p>"
          }
        },
        {
          "Converting Non-Unicode Text": {
            "content": "<p>\r\n\tIn the Java programming language&nbsp;char&nbsp;values represent Unicode characters. Unicode is a 16-bit character encoding that supports the world&#39;s major languages. You can learn more about the Unicode standard at the&nbsp;<a href=\"http://www.unicode.org/\" target=\"_blank\">Unicode Consortium Web site</a>&nbsp;.</p>\r\n<p>\r\n\tFew text editors currently support Unicode text entry. The text editor we used to write this section&#39;s code examples supports only ASCII characters, which are limited to 7 bits. To indicate Unicode characters that cannot be represented in ASCII, such as &ouml;, we used the&nbsp;\\uXXXX&nbsp;escape sequence. Each&nbsp;X&nbsp;in the escape sequence is a hexadecimal digit. The following example shows how to indicate the &ouml; character with an escape sequence:</p>\r\n<div>\r\n\t<pre>\r\n\t<code class=\"java\">String str = &quot;\\u00F6&quot;;\r\nchar c = &#39;\\u00F6&#39;;\r\nCharacter letter = new Character(&#39;\\u00F6&#39;);\r\n</code></pre>\r\n</div>\r\n<p>\r\n\tA variety of character encodings are used by systems around the world. Currently few of these encodings conform to Unicode. Because your program expects characters in Unicode, the text data it gets from the system must be converted into Unicode, and vice versa. Data in text files is automatically converted to Unicode when its encoding matches the default file encoding of the Java Virtual Machine. You can identify the default file encoding by creating an&nbsp;OutputStreamWriter&nbsp;using it and asking for its canonical name:</p>\r\n<div>\r\n\t<pre>\r\n\t<code class=\"java\"><code>OutputStreamWriter out = new OutputStreamWriter(new ByteArrayOutputStream());\r\nSystem.out.println(out.getEncoding());</code>\r\n</code></pre>\r\n</div>\r\n<p>\r\n\tIf the default file encoding differs from the encoding of the text data you want to process, then you must perform the conversion yourself. You might need to do this when processing text from another country or computing platform.</p>\r\n<p>\r\n\tThis section discusses the APIs you use to translate non-Unicode text into Unicode. Before using these APIs, you should verify that the character encoding you wish to convert into Unicode is supported. The list of supported character encodings is not part of the Java programming language specification. Therefore the character encodings supported by the APIs may vary with platform. To see which encodings the Java Development Kit supports, see the&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html\" target=\"_blank\">Supported Encodings</a>&nbsp;document</p>\r\n<p>\r\n\tThe material that follows describes two techniques for converting non-Unicode text to Unicode. You can convert non-Unicode byte arrays into&nbsp;String&nbsp;objects, and vice versa. Or you can translate between streams of Unicode characters and byte streams of non-Unicode text.</p>\r\n<div id=\"PageTitle\">\r\n\t<h2>\r\n\t\tByte Encodings and Strings</h2>\r\n</div>\r\n<div id=\"PageContent\">\r\n\t<p>\r\n\t\tIf a byte array contains non-Unicode text, you can convert the text to Unicode with one of the&nbsp;String&nbsp;constructor methods. Conversely, you can convert a&nbsp;String&nbsp;object into a byte array of non-Unicode characters with the&nbsp;String.getBytes&nbsp;method. When invoking either of these methods, you specify the encoding identifier as one of the parameters.</p>\r\n\t<p>\r\n\t\tThe example that follows converts characters between UTF-8 and Unicode. UTF-8 is a transmission format for Unicode that is safe for UNIX file systems. The full source code for the example is in the file&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/text/examples/StringConverter.java\" target=\"_blank\">StringConverter.java</a>.</p>\r\n\t<p>\r\n\t\tThe&nbsp;StringConverter&nbsp;program starts by creating a&nbsp;String&nbsp;containing Unicode characters:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code class=\"java\">String original = new String(&quot;A&quot; + &quot;\\u00ea&quot; + &quot;\\u00f1&quot; + &quot;\\u00fc&quot; + &quot;C&quot;);\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tWhen printed, the&nbsp;String&nbsp;named&nbsp;original&nbsp;appears as:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code class=\"java\">A&ecirc;&ntilde;&uuml;C\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tTo convert the&nbsp;String&nbsp;object to UTF-8, invoke the&nbsp;getBytes&nbsp;method and specify the appropriate encoding identifier as a parameter. The&nbsp;getBytes&nbsp;method returns an array of bytes in UTF-8 format. To create a&nbsp;String&nbsp;object from an array of non-Unicode bytes, invoke the&nbsp;String&nbsp;constructor with the encoding parameter. The code that makes these calls is enclosed in a&nbsp;try&nbsp;block, in case the specified encoding is unsupported:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code class=\"java\">try {\r\n    byte[] utf8Bytes = original.getBytes(&quot;UTF8&quot;);\r\n    byte[] defaultBytes = original.getBytes();\r\n\r\n    String roundTrip = new String(utf8Bytes, &quot;UTF8&quot;);\r\n    System.out.println(&quot;roundTrip = &quot; + roundTrip);\r\n    System.out.println();\r\n    printBytes(utf8Bytes, &quot;utf8Bytes&quot;);\r\n    System.out.println();\r\n    printBytes(defaultBytes, &quot;defaultBytes&quot;);\r\n} \r\ncatch (UnsupportedEncodingException e) {\r\n    e.printStackTrace();\r\n}\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe&nbsp;StringConverter&nbsp;program prints out the values in the&nbsp;utf8Bytes&nbsp;and&nbsp;defaultBytes&nbsp;arrays to demonstrate an important point: The length of the converted text might not be the same as the length of the source text. Some Unicode characters translate into single bytes, others into pairs or triplets of bytes.</p>\r\n\t<p>\r\n\t\tThe&nbsp;printBytes&nbsp;method displays the byte arrays by invoking the&nbsp;byteToHex&nbsp;method, which is defined in the source file,&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/text/examples/UnicodeFormatter.java\" target=\"_blank\">UnicodeFormatter.java</a>. Here is the&nbsp;printBytesmethod:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code class=\"java\">public static void printBytes(byte[] array, String name) {\r\n    for (int k = 0; k &lt; array.length; k++) {\r\n        System.out.println(name + &quot;[&quot; + k + &quot;] = &quot; + &quot;0x&quot; +\r\n            UnicodeFormatter.byteToHex(array[k]));\r\n    }\r\n}\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe output of the&nbsp;printBytes&nbsp;method follows. Note that only the first and last bytes, the A and C characters, are the same in both arrays:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code class=\"java\">utf8Bytes[0] = 0x41\r\nutf8Bytes[1] = 0xc3\r\nutf8Bytes[2] = 0xaa\r\nutf8Bytes[3] = 0xc3\r\nutf8Bytes[4] = 0xb1\r\nutf8Bytes[5] = 0xc3\r\nutf8Bytes[6] = 0xbc\r\nutf8Bytes[7] = 0x43\r\ndefaultBytes[0] = 0x41\r\ndefaultBytes[1] = 0xea\r\ndefaultBytes[2] = 0xf1\r\ndefaultBytes[3] = 0xfc\r\ndefaultBytes[4] = 0x43</code></pre>\r\n\t</div>\r\n</div>\r\n<div id=\"PageTitle\">\r\n\t<h2>\r\n\t\tCharacter and Byte Streams</h2>\r\n</div>\r\n<div id=\"PageContent\">\r\n\t<p>\r\n\t\tThe&nbsp;java.io&nbsp;package provides classes that allow you to convert between Unicode character streams and byte streams of non-Unicode text. With the&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/io/InputStreamReader.html\" target=\"_blank\">InputStreamReader</a>&nbsp;class, you can convert byte streams to character streams. You use the&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/io/OutputStreamWriter.html\" target=\"_blank\">OutputStreamWriter</a>&nbsp;class to translate character streams into byte streams. The following figure illustrates the conversion process:</p>\r\n\t<p>\r\n\t\t[[ image(java/process.gif, center) ]]</p>\r\n\t<p>\r\n\t\tWhen you create&nbsp;InputStreamReader&nbsp;and&nbsp;OutputStreamWriter&nbsp;objects, you specify the byte encoding that you want to convert. For example, to translate a text file in the UTF-8 encoding into Unicode, you create an&nbsp;InputStreamReader&nbsp;as follows:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code class=\"java\">FileInputStream fis = new FileInputStream(&quot;test.txt&quot;);\r\nInputStreamReader isr = new InputStreamReader(fis, &quot;UTF8&quot;);\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tIf you omit the encoding identifier,&nbsp;InputStreamReader&nbsp;and&nbsp;OutputStreamWriter&nbsp;rely on the default encoding. You can determine which encoding an&nbsp;InputStreamReader&nbsp;or&nbsp;OutputStreamWriter&nbsp;uses by invoking the&nbsp;getEncoding&nbsp;method, as follows:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\tInputStreamReader defaultReader = new InputStreamReader(fis);\r\nString defaultEncoding = defaultReader.getEncoding();\r\n</pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe example that follows shows you how to perform character-set conversions with the&nbsp;InputStreamReader&nbsp;and&nbsp;OutputStreamWriter&nbsp;classes. The full source code for this example is in&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/text/examples/StreamConverter.java\" target=\"_blank\">StreamConverter.java</a>. This program displays Japanese characters. Before trying it out, verify that the appropriate fonts have been installed on your system. If you are using the JDK software that is compatible with version 1.1, make a copy of the&nbsp;font.properties&nbsp;file and then replace it with the&nbsp;font.properties.ja&nbsp;file.</p>\r\n\t<p>\r\n\t\tThe&nbsp;StreamConverter&nbsp;program converts a sequence of Unicode characters from a&nbsp;String&nbsp;object into a&nbsp;FileOutputStream&nbsp;of bytes encoded in UTF-8. The method that performs the conversion is called&nbsp;writeOutput:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code class=\"java\">static void writeOutput(String str) {\r\n    try {\r\n        FileOutputStream fos = new FileOutputStream(&quot;test.txt&quot;);\r\n        Writer out = new OutputStreamWriter(fos, &quot;UTF8&quot;);\r\n        out.write(str);\r\n        out.close();\r\n    } \r\n    catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n}\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe&nbsp;readInput&nbsp;method reads the bytes encoded in UTF-8 from the file created by the&nbsp;writeOutput&nbsp;method. An&nbsp;InputStreamReader&nbsp;object converts the bytes from UTF-8 into Unicode and returns the result in a&nbsp;String. The&nbsp;readInput&nbsp;method is as follows:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code class=\"java\">static String readInput() {\r\n    StringBuffer buffer = new StringBuffer();\r\n    try {\r\n        FileInputStream fis = new FileInputStream(&quot;test.txt&quot;);\r\n        InputStreamReader isr = new InputStreamReader(fis, &quot;UTF8&quot;);\r\n        Reader in = new BufferedReader(isr);\r\n        int ch;\r\n        while ((ch = in.read()) &gt; -1) {\r\n            buffer.append((char)ch);\r\n        }\r\n        in.close();\r\n        return buffer.toString();\r\n    } \r\n    catch (IOException e) {\r\n        e.printStackTrace();\r\n        return null;\r\n    }\r\n}\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe&nbsp;main&nbsp;method of the&nbsp;StreamConverter&nbsp;program invokes the&nbsp;writeOutput&nbsp;method to create a file of bytes encoded in UTF-8. The&nbsp;readInput&nbsp;method reads the same file, converting the bytes back into Unicode. Here is the source code for the&nbsp;main&nbsp;method:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code class=\"java\">public static void main(String[] args) {\r\n    String jaString = new String(&quot;\\u65e5\\u672c\\u8a9e\\u6587\\u5b57\\u5217&quot;);\r\n    writeOutput(jaString); \r\n    String inputString = readInput();\r\n    String displayString = jaString + &quot; &quot; + inputString;\r\n    new ShowString(displayString, &quot;Conversion Demo&quot;);\r\n}\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe original string (jaString) should be identical to the newly created string (inputString). To show that the two strings are the same, the program concatenates them and displays them with a&nbsp;ShowString&nbsp;object. The&nbsp;ShowString&nbsp;class displays a string with the&nbsp;Graphics.drawString&nbsp;method. The source code for this class is in&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/text/examples/ShowString.java\" target=\"_blank\">ShowString.java</a>. When the&nbsp;StreamConverter&nbsp;program instantiates&nbsp;ShowString, the following window appears. The repetition of the characters displayed verifies that the two strings are identical:</p>\r\n\t<p>\r\n\t\t[[ image(java/chn.gif, center) ]]</p>\r\n</div>"
          }
        },
        {
          "Internationalization of Network Resources": {
            "content": "<p>\r\n\tIn a modern Internet community, many users are no longer satisfied with using only ASCII symbols to identify a domain name or a web resource. For example, they would like to be able to register a new domain using their native characters in Arabic or Chinese. That is why the internationalization of network resources is a cornerstone in widening horizons for the World Wide Web.</p>\r\n<p>\r\n\tThis lesson describes the internationalization of the network Domain Name resources.</p>\r\n<div id=\"PageTitle\">\r\n\t<h2>\r\n\t\tInternationalized Domain Name</h2>\r\n</div>\r\n<div id=\"PageContent\">\r\n\t<p>\r\n\t\tHistorically, an Internet domain name contained ASCII symbols only. As the Internet gained popularity and was adopted across the world, it became necessary to support internationalization of domain names, specifically to support domain names that include Unicode characters.</p>\r\n\t<p>\r\n\t\tThe&nbsp;<strong>Internationalizing Domain Names</strong>&nbsp;in Applications (IDNA) mechanism was adopted as the standard to convert Unicode characters to standard ASCII domain names and thus preserve the stability of the domain name system. This system performs a lookup service to translate user-friendly names into network addresses.</p>\r\n\t<p>\r\n\t\tExamples of internationalized domain names:</p>\r\n\t<ul>\r\n\t\t<li>\r\n\t\t\thttp://\u6e05\u534e\u5927\u5b66.cn</li>\r\n\t\t<li>\r\n\t\t\thttp://www.\u0442\u0440\u0430\u043d\u0441\u043f\u043e\u0440\u0442.com</li>\r\n\t</ul>\r\n\t<p>\r\n\t\tIf you follow these links you will see that the Unicode domain name represented in the address bar is substituted with the ASCII string.</p>\r\n\t<p>\r\n\t\tTo implement similar functionality in your application, the&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/net/IDN.html\" target=\"_blank\">java.net.IDN</a>&nbsp;class provides methods to convert domain names between ASCII and non ASCII formats.</p>\r\n\t<table border=\"1\" summary=\"java.net.IDN class methods\">\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tMethod</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tPurpose</th>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/net/IDN.html#toASCII-java.lang.String-\" target=\"_blank\">toASCII(String)</a><br />\r\n\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/net/IDN.html#toASCII-java.lang.String-int-\" target=\"_blank\">toASCII(String, flag)</a></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tUsed before sending an IDN to the domain name resolving system or writing an IDN to a file where ASCII characters are expected, such as a DNS master file. If the input string doesn&#39;t conform to&nbsp;<a href=\"http://www.ietf.org/rfc/rfc3490.txt\" target=\"_blank\">RFC 3490</a>, these methods throw an&nbsp;IllegalArgumentException.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/net/IDN.html#toUnicode-java.lang.String-\" target=\"_blank\">toUnicode(String)</a><br />\r\n\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/net/IDN.html#toUnicode-java.lang.String-int-\" target=\"_blank\">toUnicode(String, flag)</a></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tUsed when displaying names to users, for example names obtained from a DNS zone. This method translates a string from ASCII Compatible Encoding (ACE) to Unicode code points. This method never fails; in case of an error the input string remains the same and is returned unmodified.</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n\t<p>\r\n\t\tThe optional&nbsp;flag&nbsp;parameter specifies the behavior of the conversion process. The&nbsp;ALLOW_UNASSIGNED&nbsp;flag allows including code points that are unassigned in Unicode 3.2. The&nbsp;USE_STD3_ASCII_RULES&nbsp;flag ensures that the STD-3 ASCII rules are observed. You can use these flags separately or logically OR&#39;ed together. If neither flag is desired, use the single-parameter version of the method.</p>\r\n</div>"
          }
        },
        {
          "Service Providers for Internationalization": {
            "content": "<p>\r\n\tService providers for internationalization enable the plug-in of locale-dependent data and services. Because locale-dependent data and services can be plugged-in, third parties are able to provide implementations of most locale-sensitive classes in the&nbsp;<code>java.text</code>&nbsp;and&nbsp;<code>java.util</code>&nbsp;packages.</p>\r\n<p>\r\n\tA service is a set of programming interfaces and classes that provide access to a specific application&#39;s functionality or feature. A service provider interface (SPI) is the set of public interfaces and abstract classes that a service defines. A service provider implements the SPI. Service providers enable you to create extensible applications, which you can extend without modifying its original code base. You can enhance their functionality with new plug-ins or modules. For more information about service providers and extensible applications, see&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/ext/basics/spi.html\" target=\"_top\">Creating Extensible Applications</a>.</p>\r\n<p>\r\n\tYou can use service providers for internationalization to provide custom implementations of the following locale-sensitive classes:</p>\r\n<ul>\r\n\t<li>\r\n\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/text/BreakIterator.html\" target=\"_blank\"><code>BreakIterator</code></a>&nbsp;objects</li>\r\n\t<li>\r\n\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/text/Collator.html\" target=\"_blank\"><code>Collator</code></a>&nbsp;objects</li>\r\n\t<li>\r\n\t\tLanguage code, country code, and variant name for the&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html\" target=\"_blank\"><code>Locale</code></a>&nbsp;class</li>\r\n\t<li>\r\n\t\tTime zone names</li>\r\n\t<li>\r\n\t\tCurrency symbols</li>\r\n\t<li>\r\n\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/text/DateFormat.html\" target=\"_blank\"><code>DateFormat</code></a>&nbsp;objects</li>\r\n\t<li>\r\n\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/text/DateFormatSymbols.html\" target=\"_blank\"><code>DateFormatSymbols</code></a>&nbsp;objects</li>\r\n\t<li>\r\n\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/text/NumberFormat.html\" target=\"_blank\"><code>NumberFormat</code></a>&nbsp;objects</li>\r\n\t<li>\r\n\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/text/DecimalFormatSymbols.html\" target=\"_blank\"><code>DecimalFormatSymbols</code></a>&nbsp;objects</li>\r\n</ul>\r\n<p>\r\n\tThe corresponding SPIs are contained both in&nbsp;<code>java.text.spi</code>&nbsp;and in&nbsp;<code>java.util.spi</code>&nbsp;packages:</p>\r\n<table border=\"1\" summary=\"SPIs for internationalization\">\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>\r\n\t\t\t\t<code>java.util.spi</code></td>\r\n\t\t\t<td>\r\n\t\t\t\t<code>java.text.spi</code></td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>\r\n\t\t\t\t<ul>\r\n\t\t\t\t\t<li>\r\n\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/spi/CurrencyNameProvider.html\" target=\"_blank\"><code>CurrencyNameProvider</code></a></li>\r\n\t\t\t\t\t<li>\r\n\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/spi/LocaleServiceProvider.html\" target=\"_blank\"><code>LocaleServiceProvider</code></a></li>\r\n\t\t\t\t\t<li>\r\n\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/spi/TimeZoneNameProvider.html\" target=\"_blank\"><code>TimeZoneNameProvider</code></a></li>\r\n\t\t\t\t</ul>\r\n\t\t\t</td>\r\n\t\t\t<td>\r\n\t\t\t\t<ul>\r\n\t\t\t\t\t<li>\r\n\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/text/spi/BreakIteratorProvider.html\" target=\"_blank\"><code>BreakIteratorProvider</code></a></li>\r\n\t\t\t\t\t<li>\r\n\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/text/spi/CollatorProvider.html\" target=\"_blank\"><code>CollatorProvider</code></a></li>\r\n\t\t\t\t\t<li>\r\n\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/text/spi/DateFormatProvider.html\" target=\"_blank\"><code>DateFormatProvider</code></a></li>\r\n\t\t\t\t\t<li>\r\n\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/text/spi/DateFormatSymbolsProvider.html\" target=\"_blank\"><code>DateFormatSymbolsProvider</code></a></li>\r\n\t\t\t\t\t<li>\r\n\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/text/spi/DecimalFormatSymbolsProvider.html\" target=\"_blank\"><code>DecimalFormatSymbolsProvider</code></a></li>\r\n\t\t\t\t\t<li>\r\n\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/8/docs/api/java/text/spi/NumberFormatProvider.html\" target=\"_blank\"><code>NumberFormatProvider</code></a></li>\r\n\t\t\t\t</ul>\r\n\t\t\t</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n<p>\r\n\tFor example, if you want to provide a&nbsp;<code>NumberFormat</code>&nbsp;object for a new locale, implement the&nbsp;<code>java.text.spi.NumberFormatProvider</code>&nbsp;class and implement these methods:</p>\r\n<ul>\r\n\t<li>\r\n\t\t<code>getCurrencyInstance(Locale locale)</code></li>\r\n\t<li>\r\n\t\t<code>getIntegerInstance(Locale locale)</code></li>\r\n\t<li>\r\n\t\t<code>getNumberInstance(Locale locale)</code></li>\r\n\t<li>\r\n\t\t<code>getPercentInstance(Locale locale)</code></li>\r\n</ul>\r\n<div>\r\n\t<pre>\r\n\t<code>Locale loc = new Locale(&quot;da&quot;, &quot;DK&quot;);\r\nNumberFormat nf = NumberFormatProvider.getNumberInstance(loc);\r\n</code></pre>\r\n</div>\r\n<p>\r\n\tThese methods first check whether the Java runtime environment supports the requested locale; if so, the methods use that support. Otherwise, the methods invoke the&nbsp;<code>getAvailableLocales</code>&nbsp;methods of installed providers for the appropriate interface to find a provider that supports the requested locale.</p>\r\n<p>\r\n\tFor an in-depth example of how to use service providers for internationalization, see&nbsp;&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/resourcebundlecontrolprovider.html\" target=\"_top\">Installing a Custom Resource Bundle as an Extension</a>. This section shows you how to implement the<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/spi/ResourceBundleControlProvider.html\" target=\"_blank\"><code>ResourceBundleControlProvider</code></a>&nbsp;interface, which enables you to use any custom&nbsp;<code>ResourceBundle.Control</code>&nbsp;classes without any additional changes to the source code of your application.</p>\r\n<div id=\"PageTitle\">\r\n\t<h2>\r\n\t\tInstalling a Custom Resource Bundle as an Extension</h2>\r\n</div>\r\n<div id=\"PageContent\">\r\n\t<p>\r\n\t\tThe section&nbsp;&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/resbundle/control.html\" target=\"_top\">Customizing Resource Bundle Loading</a>&nbsp;shows you how to change how resource bundles are loaded. This involves deriving a new class from the class<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.Control.html\" target=\"_blank\"><code>ResourceBundle.Control</code></a>, then retrieving the resource bundle by invoking the following method:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>ResourceBundle getBundle(\r\n  String baseName,\r\n  Locale targetLocale,\r\n  ResourceBundle.Control control)\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tThe parameter&nbsp;<code>control</code>&nbsp;is your implementation of&nbsp;<code>ResourceBundle.Control</code>.</p>\r\n\t<p>\r\n\t\tThe&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/spi/ResourceBundleControlProvider.html\" target=\"_blank\"><code>java.util.spi.ResourceBundleControlProvider</code></a>&nbsp;interface enables you to change how the following method loads resource bundles:</p>\r\n\t<div>\r\n\t\t<pre>\r\n\t\t<code>ResourceBundle getBundle(\r\n  String baseName,\r\n  Locale targetLocale)\r\n</code></pre>\r\n\t</div>\r\n\t<p>\r\n\t\tNote that this version of the&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html#getBundle-java.lang.String-java.util.Locale-\" target=\"_blank\"><code>ResourceBundle.getBundle</code></a>&nbsp;method does not require an instance of the&nbsp;<code>ResourceBundle.Control</code>&nbsp;class.&nbsp;<code>ResourceBundleControlProvider</code>&nbsp;is a service provider interface (SPI). SPIs enable you to create extensible applications, which are those that you can extend easily without modifying their original code base. See&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/ext/basics/spi.html\" target=\"_top\">Creating Extensible Applications</a>&nbsp;for more information.</p>\r\n\t<p>\r\n\t\tTo use SPIs, you first create a service provider by implementing an SPI like&nbsp;<code>ResourceBundleControlProvider</code>. When you implement an SPI, you specify how it will provide the service. The service that the&nbsp;<code>ResourceBundleControlProvider</code>&nbsp;SPI provides is to obtain an appropriate&nbsp;<code>ResourceBundle.Control</code>&nbsp;instance when your application invokes the method&nbsp;<code>ResourceBundle.getBundle(String baseName, Locale targetLocale)</code>. You package the service provider with the&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/ext/index.html\" target=\"_top\">Java Extension Mechanism</a>&nbsp;as an installed extension. When you run your application, you do not name your extensions in your class path; the runtime environment finds and loads these extensions.</p>\r\n\t<p>\r\n\t\tAn installed implementation of the&nbsp;<code>ResourceBundleControlProvider</code>&nbsp;SPI replaces the default&nbsp;<code>ResourceBundle.Control</code>&nbsp;class (which defines the default bundle loading process). Consequently, the&nbsp;<code>ResourceBundleControlProvider</code>&nbsp;interface enables you to use any of the custom&nbsp;<code>ResourceBundle.Control</code>&nbsp;classes without any additional changes to the source code of your application. In addition, this interface enables you to write applications without having to refer to any of your custom&nbsp;<code>ResourceBundle.Control</code>&nbsp;classes.</p>\r\n\t<p>\r\n\t\tThe&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/src/RBCPTest.java\" target=\"_blank\"><code>RBCPTest.java</code></a>&nbsp;sample shows how to implement the&nbsp;<code>ResourceBundleControlProvider</code>&nbsp;interface and how to package it as an installed extension. This sample, which is packaged in the zip file&nbsp;<code><a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/RBCPTest.zip\">RBCPTest.zip</a></code>, consists of the following files:</p>\r\n\t<ul>\r\n\t\t<li>\r\n\t\t\t<code>src</code>\r\n\t\t\t<ul>\r\n\t\t\t\t<li>\r\n\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/src/java.util.spi.ResourceBundleControlProvider\" target=\"_blank\"><code>java.util.spi.ResourceBundleControlProvider</code></a></li>\r\n\t\t\t\t<li>\r\n\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/src/RBCPTest.java\" target=\"_blank\"><code>RBCPTest.java</code></a></li>\r\n\t\t\t\t<li>\r\n\t\t\t\t\t<code>rbcp</code>\r\n\t\t\t\t\t<ul>\r\n\t\t\t\t\t\t<li>\r\n\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/src/rbcp/PropertiesResourceBundleControl.java\" target=\"_blank\"><code>PropertiesResourceBundleControl.java</code></a></li>\r\n\t\t\t\t\t\t<li>\r\n\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/src/rbcp/PropertiesResourceBundleControlProvider.java\" target=\"_blank\"><code>PropertiesResourceBundleControlProvider.java</code></a></li>\r\n\t\t\t\t\t\t<li>\r\n\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/src/rbcp/XMLResourceBundleControl.java\" target=\"_blank\"><code>XMLResourceBundleControl.java</code></a></li>\r\n\t\t\t\t\t\t<li>\r\n\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/src/rbcp/XMLResourceBundleControlProvider.java\" target=\"_blank\"><code>XMLResourceBundleControlProvider.java</code></a></li>\r\n\t\t\t\t\t</ul>\r\n\t\t\t\t</li>\r\n\t\t\t\t<li>\r\n\t\t\t\t\t<code>resources</code>\r\n\t\t\t\t\t<ul>\r\n\t\t\t\t\t\t<li>\r\n\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/src/resources/RBControl.properties\" target=\"_blank\"><code>RBControl.properties</code></a></li>\r\n\t\t\t\t\t\t<li>\r\n\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/src/resources/RBControl_zh.properties\" target=\"_blank\"><code>RBControl_zh.properties</code></a></li>\r\n\t\t\t\t\t\t<li>\r\n\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/src/resources/RBControl_zh_CN.properties\" target=\"_blank\"><code>RBControl_zh_CN.properties</code></a></li>\r\n\t\t\t\t\t\t<li>\r\n\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/src/resources/RBControl_zh_HK.properties\" target=\"_blank\"><code>RBControl_zh_HK.properties</code></a></li>\r\n\t\t\t\t\t\t<li>\r\n\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/src/resources/RBControl_zh_TW.properties\" target=\"_blank\"><code>RBControl_zh_TW.properties</code></a></li>\r\n\t\t\t\t\t\t<li>\r\n\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/src/resources/XmlRB.xml\" target=\"_blank\"><code>XmlRB.xml</code></a></li>\r\n\t\t\t\t\t\t<li>\r\n\t\t\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/src/resources/XmlRB_ja.xml\" target=\"_blank\"><code>XmlRB_ja.xml</code></a></li>\r\n\t\t\t\t\t</ul>\r\n\t\t\t\t</li>\r\n\t\t\t</ul>\r\n\t\t</li>\r\n\t\t<li>\r\n\t\t\t<code>lib</code>\r\n\t\t\t<ul>\r\n\t\t\t\t<li>\r\n\t\t\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/resourcebundlecontrolprovider.html#package-provider\"><code>rbcontrolprovider.jar</code></a></li>\r\n\t\t\t</ul>\r\n\t\t</li>\r\n\t\t<li>\r\n\t\t\t<code>build</code>: Contains all files packaged in&nbsp;<code>rbcontrolprovider.jar</code>&nbsp;as well as the class file&nbsp;<code>RBCPTest.class</code></li>\r\n\t\t<li>\r\n\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/build.xml\" target=\"_blank\"><code>build.xml</code></a></li>\r\n\t</ul>\r\n\t<p>\r\n\t\tThe following steps show you how to re-create the contents of the file&nbsp;<code>RBCPTest.zip</code>, how the&nbsp;<code>RBCPTest</code>&nbsp;sample works, and how to run it:</p>\r\n\t<ol>\r\n\t\t<li>\r\n\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/resourcebundlecontrolprovider.html#create-implementations-of-resourcebundle.control\">Create implementations of the ResourceBundle.Control class.</a></li>\r\n\t\t<li>\r\n\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/resourcebundlecontrolprovider.html#implement-resourcebundlecontrolprovider\">Implement the ResourceBundleControlProvider interface.</a></li>\r\n\t\t<li>\r\n\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/resourcebundlecontrolprovider.html#invoke-resourcebundle.getbundle\">In your application, invoke the method ResourceBundle.getBundle.</a></li>\r\n\t\t<li>\r\n\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/resourcebundlecontrolprovider.html#register-service-provider\">Register the service provider by creating a configuration file.</a></li>\r\n\t\t<li>\r\n\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/resourcebundlecontrolprovider.html#package-provider\">Package the provider, its required classes, and the configuration file in a JAR file.</a></li>\r\n\t\t<li>\r\n\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/resourcebundlecontrolprovider.html#run-rbcptest\">Run the RBCPTest program.</a></li>\r\n\t</ol>\r\n\t<h3>\r\n\t\t1. Create Implementations of the ResourceBundle.Control class.&nbsp;</h3>\r\n\t<p>\r\n\t\tThe&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/src/RBCPTest.java\" target=\"_blank\"><code>RBCPTest.java</code></a>&nbsp;sample uses two implementations of&nbsp;<code>ResourseBundle.Control</code>:</p>\r\n\t<ul>\r\n\t\t<li>\r\n\t\t\t<p>\r\n\t\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/src/rbcp/PropertiesResourceBundleControlProvider.java\" target=\"_blank\"><code>PropertiesResourceBundleControlProvider.java</code></a>: This is the same&nbsp;<code>ResourceBundle.Control</code>&nbsp;implementation that is defined in&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/resbundle/control.html\" target=\"_top\">Customizing Resource Bundle Loading</a>.</p>\r\n\t\t</li>\r\n\t\t<li>\r\n\t\t\t<p>\r\n\t\t\t\t<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/src/rbcp/XMLResourceBundleControl.java\" target=\"_blank\"><code>XMLResourceBundleControl.java</code></a>: This&nbsp;<code>ResourceBundle.Control</code>&nbsp;implementation loads XML-based bundles with the method&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#loadFromXML-java.io.InputStream-\" target=\"_blank\"><code>Properties.loadFromXML</code></a>.</p>\r\n\t\t</li>\r\n\t</ul>\r\n\t<h4>\r\n\t\tXML Properties Files</h4>\r\n\t<p>\r\n\t\tAs described in the section&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/resbundle/propfile.html\" target=\"_top\">Backing a ResourceBundle with Properties Files</a>, properties files are simple text files. They contain one key-value pair on each line. XML properties files are just like properties files: they contain key-value pairs except they have an XML structure. The following is the XML properties file&nbsp;<code>XmlRB.xml</code>:</p>\r\n\t<pre>\r\n\t<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\r\n\r\n&lt;!DOCTYPE properties [\r\n&lt;!ELEMENT properties ( comment?, entry* ) &gt;\r\n&lt;!ATTLIST properties version CDATA #FIXED &quot;1.0&quot;&gt;\r\n&lt;!ELEMENT comment (#PCDATA) &gt;\r\n&lt;!ELEMENT entry (#PCDATA) &gt;\r\n&lt;!ATTLIST entry key CDATA #REQUIRED&gt;\r\n]&gt;\r\n</code><code>\r\n&lt;properties&gt;\r\n    &lt;comment&gt;Test data for RBCPTest.java&lt;/comment&gt;\r\n    &lt;entry key=&quot;type&quot;&gt;XML&lt;/entry&gt;\r\n&lt;/properties&gt;</code>\r\n</pre>\r\n\t<p>\r\n\t\tThe following is the properties text file equivalent:</p>\r\n\t<pre>\r\n\t<code># Test data for RBCPTest.java\r\ntype = XML\r\n</code></pre>\r\n\t<p>\r\n\t\tAll XML properties text files have the same structure:</p>\r\n\t<ul>\r\n\t\t<li>\r\n\t\t\t<p>\r\n\t\t\t\tA DOCTYPE declaration that specifies the Document Type Definition (DTD): The DTD defines the structure of an XML file.&nbsp;<strong>Note</strong>: You can use the following DOCTYPE declaration instead in an XML properties file:</p>\r\n\t\t\t<pre>\r\n\t\t\t<code>&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;  \r\n</code></pre>\r\n\t\t\t<p>\r\n\t\t\t\tThe system URI (<code>http://java.sun.com/dtd/properties.dtd</code>) is not accessed when exporting or importing properties; it is a string that uniquely identifies the DTD of XML properties files.</p>\r\n\t\t</li>\r\n\t\t<li>\r\n\t\t\t<p>\r\n\t\t\t\tRoot element&nbsp;<code>&lt;properties&gt;</code>: This element contains all the other elements.</p>\r\n\t\t</li>\r\n\t\t<li>\r\n\t\t\t<p>\r\n\t\t\t\tAny number of&nbsp;<code>&lt;comment&gt;</code>&nbsp;elements: These are used for comments.</p>\r\n\t\t</li>\r\n\t\t<li>\r\n\t\t\t<p>\r\n\t\t\t\tAny number of&nbsp;<code>&lt;entry&gt;</code>&nbsp;elements: Use the attribute&nbsp;<code>key</code>&nbsp;to specify the key; specify the value of the key between the&nbsp;<code>&lt;entry&gt;</code>&nbsp;tags.</p>\r\n\t\t</li>\r\n\t</ul>\r\n\t<p>\r\n\t\tSee the&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html\" target=\"_blank\"><code>Properties</code></a>&nbsp;class for more information about XML properties files.</p>\r\n\t<h3>\r\n\t\t2. Implement the ResouceBundleControlProvider interface</h3>\r\n\t<p>\r\n\t\tThis interface contains one method, the&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/spi/ResourceBundleControlProvider.html#getControl-java.lang.String-\" target=\"_blank\"><code>ResourceBundle.Control getControl(String baseName)</code></a>&nbsp;method. The parameter&nbsp;<code>baseName</code>&nbsp;is the name of the resource bundle. In the method definition of&nbsp;<code>getBundle</code>, specify the instance of&nbsp;<code>ResourceBundle.Control</code>&nbsp;that should be returned given the name of the resource bundle.</p>\r\n\t<p>\r\n\t\tThe&nbsp;<code>RBCPTest</code>&nbsp;sample contains two implementations of the&nbsp;<code>ResourceBundleControlProvider</code>&nbsp;interface,&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/src/rbcp/PropertiesResourceBundleControlProvider.java\" target=\"_blank\"><code>PropertiesResourceBundleControlProvider.java</code></a>&nbsp;and<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/src/rbcp/XMLResourceBundleControlProvider.java\" target=\"_blank\"><code>XMLResourceBundleControlProvider.java</code></a>. The method&nbsp;<code>PropertiesResourceBundleControlProvider.getBundle</code>&nbsp;returns an instance of&nbsp;<code>PropertiesResourceBundleControl</code>&nbsp;if the base name of the resource bundle starts with&nbsp;<code>resources.RBControl</code>&nbsp;(in this example, all the resource files are contained in the package&nbsp;<code>resources</code>):</p>\r\n\t<pre>\r\n\t<code>package rbcp;\r\n\r\nimport java.util.ResourceBundle;\r\nimport java.util.spi.ResourceBundleControlProvider;\r\n\r\npublic class PropertiesResourceBundleControlProvider\r\n    implements ResourceBundleControlProvider {\r\n    static final ResourceBundle.Control PROPERTIESCONTROL =\r\n        new PropertiesResourceBundleControl();\r\n\r\n    public ResourceBundle.Control getControl(String baseName) {\r\n        System.out.println(&quot;Class: &quot; + getClass().getName() + &quot;.getControl&quot;);\r\n        System.out.println(&quot;    called for &quot; + baseName);\r\n\r\n        // Throws a NPE if baseName is null.\r\n        if (baseName.startsWith(&quot;resources.RBControl&quot;)) {\r\n            System.out.println(&quot;    returns &quot; + PROPERTIESCONTROL);\r\n            return PROPERTIESCONTROL;\r\n        }\r\n        System.out.println(&quot;    returns null&quot;);\r\n        System.out.println();\r\n        return null;\r\n    }\r\n}\r\n</code></pre>\r\n\t<p>\r\n\t\tSimilarly, the method&nbsp;<code>XMLResourceBundleControlProvider.getControl</code>&nbsp;returns an instance of&nbsp;<code>XMLResourceBundleControl</code>&nbsp;if the base name of the resource bundle starts with&nbsp;<code>resources.Xml</code>.</p>\r\n\t<blockquote>\r\n\t\t<p>\r\n\t\t\t<strong>Note</strong>: You can create one implementation of the&nbsp;<code>ResourceBundleControlProvider</code>&nbsp;interface that returns either an instance of&nbsp;<code>PropertiesResourceBundleControl</code>&nbsp;or&nbsp;<code>XMLResourceBundleControl</code>&nbsp;depending on the base name.</p>\r\n\t</blockquote>\r\n\t<h3>\r\n\t\t3. In your application, invoke the method ResourceBundle.getBundle.</h3>\r\n\t<p>\r\n\t\tThe class&nbsp;<code>RBCPTest</code>&nbsp;retrieves resource bundles with the method&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html#getBundle-java.lang.String-java.util.Locale-\" target=\"_blank\"><code>ResourceBundle.getBundle</code></a>:</p>\r\n\t<pre>\r\n\t<code>import java.io.*;\r\nimport java.net.*;\r\nimport java.util.*;\r\n\r\npublic class RBCPTest {\r\n    public static void main(String[] args) {\r\n        ResourceBundle rb = ResourceBundle.getBundle(\r\n            &quot;resources.XmlRB&quot;, Locale.ROOT);\r\n        String type = rb.getString(&quot;type&quot;);\r\n        System.out.println(&quot;Root locale. Key, type: &quot; + type);\r\n        System.out.println();\r\n\r\n        rb = ResourceBundle.getBundle(&quot;resources.XmlRB&quot;, Locale.JAPAN);\r\n        type = rb.getString(&quot;type&quot;);\r\n        System.out.println(&quot;Japan locale. Key, type: &quot; + type);\r\n        System.out.println();\r\n\r\n        test(Locale.CHINA);\r\n        test(new Locale(&quot;zh&quot;, &quot;HK&quot;));\r\n        test(Locale.TAIWAN);\r\n        test(Locale.CANADA);\r\n    }\r\n\r\n    private static void test(Locale locale) {\r\n        ResourceBundle rb = ResourceBundle.getBundle(\r\n            &quot;resources.RBControl&quot;, locale);\r\n        System.out.println(&quot;locale: &quot; + locale);\r\n        System.out.println(&quot;    region: &quot; + rb.getString(&quot;region&quot;));\r\n        System.out.println(&quot;    language: &quot; + rb.getString(&quot;language&quot;));\r\n        System.out.println();\r\n    }\r\n}\r\n</code></pre>\r\n\t<p>\r\n\t\tNote that no implementations of&nbsp;<code>ResourceBundle.Control</code>&nbsp;or&nbsp;<code>ResourceBundleControlProvider</code>&nbsp;appear in this class. Because the&nbsp;<code>ResourceBundleControlProvider</code>interface uses the Java Extension Mechanism, the runtime environment finds and loads these implementations. However,&nbsp;<code>ResourceBundleControlProvider</code>&nbsp;implementations and other service providers that are installed with the Java Extension Mechanism are loaded using the&nbsp;<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html\" target=\"_blank\"><code>ServiceLoader</code></a>class. Using this class means that you have to register the service provider with a configuration file, which is described in the next step.</p>\r\n\t<h3>\r\n\t\t4. Register the service provider by creating a configuration file</h3>\r\n\t<p>\r\n\t\tThe name of the configuration file is the fully qualified name of the interface or class that the provider implemented. The configuration file contains the fully qualified class name of your provider. The file&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/src/java.util.spi.ResourceBundleControlProvider\" target=\"_blank\"><code>java.util.spi.ResourceBundleControlProvider</code></a>&nbsp;contains the fully qualified names of&nbsp;<code>PropertiesResourceBundleControlProvider</code>&nbsp;and&nbsp;<code>XMLResourceBundleControlProvider</code>, one name per line:</p>\r\n\t<pre>\r\n\t<code>rbcp.XMLResourceBundleControlProvider\r\nrbcp.PropertiesResourceBundleControlProvider\r\n</code></pre>\r\n\t<h3>\r\n\t\t5. Package the provider, its required classes, and the configuration file in a JAR file.</h3>\r\n\t<p>\r\n\t\tCompile the source files. From the directory that contains the file&nbsp;<code>build.xml</code>, run the following command:</p>\r\n\t<pre>\r\n\t<code>javac -d build src/java.* src/rbcp/*.java</code></pre>\r\n\t<p>\r\n\t\tThis command will compile the source files contained in the&nbsp;<code>src</code>&nbsp;directory and put the class files in the&nbsp;<code>build</code>&nbsp;directory. On Windows, ensure that you use the backslash (<code>\\</code>) to separate directory and file names.</p>\r\n\t<p>\r\n\t\tCreate a JAR file that contains the compiled class files, resource files, and the configuration file in the following directory structure:</p>\r\n\t<ul>\r\n\t\t<li>\r\n\t\t\t<code>META-INF</code>\r\n\t\t\t<ul>\r\n\t\t\t\t<li>\r\n\t\t\t\t\t<code>services</code>\r\n\t\t\t\t\t<ul>\r\n\t\t\t\t\t\t<li>\r\n\t\t\t\t\t\t\t<code>java.util.spi.ResourceBundleControlProvider</code></li>\r\n\t\t\t\t\t</ul>\r\n\t\t\t\t</li>\r\n\t\t\t</ul>\r\n\t\t</li>\r\n\t\t<li>\r\n\t\t\t<code>rbcp</code>\r\n\t\t\t<ul>\r\n\t\t\t\t<li>\r\n\t\t\t\t\t<code>PropertiesResourceBundleControl.class</code></li>\r\n\t\t\t\t<li>\r\n\t\t\t\t\t<code>PropertiesResourceBundleControlProvider.class</code></li>\r\n\t\t\t\t<li>\r\n\t\t\t\t\t<code>XMLResourceBundleControl.class</code></li>\r\n\t\t\t\t<li>\r\n\t\t\t\t\t<code>XMLResourceBundleControlProvider.class</code></li>\r\n\t\t\t</ul>\r\n\t\t</li>\r\n\t\t<li>\r\n\t\t\t<code>resources</code>\r\n\t\t\t<ul>\r\n\t\t\t\t<li>\r\n\t\t\t\t\t<code>RBControl.properties</code></li>\r\n\t\t\t\t<li>\r\n\t\t\t\t\t<code>RBControl_zh.properties</code></li>\r\n\t\t\t\t<li>\r\n\t\t\t\t\t<code>RBControl_zh_CN.properties</code></li>\r\n\t\t\t\t<li>\r\n\t\t\t\t\t<code>RBControl_zh_HK.properties</code></li>\r\n\t\t\t\t<li>\r\n\t\t\t\t\t<code>RBControl_zh_TW.properties</code></li>\r\n\t\t\t\t<li>\r\n\t\t\t\t\t<code>XmlRB.xml</code></li>\r\n\t\t\t\t<li>\r\n\t\t\t\t\t<code>XmlRB_ja.xml</code></li>\r\n\t\t\t</ul>\r\n\t\t</li>\r\n\t</ul>\r\n\t<p>\r\n\t\tNote that the configuration file&nbsp;<code>java.util.spi.ResourceBundleControlProvider</code>&nbsp;must be packaged in the directory&nbsp;<code>/META-INF/services</code>. This sample packages these files in the JAR file&nbsp;<code>rbcontrolprovider.jar</code>&nbsp;in the&nbsp;<code>lib</code>&nbsp;directory.</p>\r\n\t<p>\r\n\t\tSee&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/deployment/jar/index.html\" target=\"_top\">Packaging Programs in JAR Files</a>&nbsp;for more information about creating JAR files.</p>\r\n\t<p>\r\n\t\tAlternatively, download and install&nbsp;<a href=\"http://ant.apache.org/\">Apache Ant</a>, which is a tool that enables you to automate build processes, such as compiling Java files and creating JAR files. Ensure that the Apache Ant executable file is in your&nbsp;<code>PATH</code>&nbsp;environment variable so that you can run it from any directory. Once you have installed Apache Ant, follow these steps:</p>\r\n\t<ol>\r\n\t\t<li>\r\n\t\t\t<p>\r\n\t\t\t\tEdit the file&nbsp;<a href=\"https://docs.oracle.com/javase/tutorial/i18n/serviceproviders/examples/rbcpsample/build.xml\" target=\"_blank\"><code>build.xml</code></a>&nbsp;and change&nbsp;<code>${JAVAC}</code>&nbsp;to the full path name of your Java compiler,&nbsp;<code>javac</code>, and&nbsp;<code>${JAVA}</code>&nbsp;to the full path name of your Java runtime executable,&nbsp;<code>java</code>.</p>\r\n\t\t</li>\r\n\t\t<li>\r\n\t\t\t<p>\r\n\t\t\t\tRun the following command from the same directory that contains the file&nbsp;<code>build.xml</code>:</p>\r\n\t\t\t<pre>\r\n\t\t\t<code>ant jar</code></pre>\r\n\t\t\t<p>\r\n\t\t\t\tThis command compiles the Java source files and packages them, along with the required resource and configuration files, into the JAR file&nbsp;<code>rbcontrolprovider.jar</code>&nbsp;in the&nbsp;<code>lib</code>&nbsp;directory.</p>\r\n\t\t</li>\r\n\t</ol>\r\n\t<h3>\r\n\t\t6. Run the RBCPTest program.</h3>\r\n\t<p>\r\n\t\tAt a command prompt, run the following command from the directory that contains the&nbsp;<code>build.xml</code>&nbsp;file:</p>\r\n\t<pre>\r\n\t<code>java -Djava.ext.dirs=lib -cp build RBCPTest</code></pre>\r\n\t<p>\r\n\t\tThis command assumes the following:</p>\r\n\t<ul>\r\n\t\t<li>\r\n\t\t\tThe JAR file that contains the compiled code of the RBCPTest sample is in the directory&nbsp;<code>lib</code>.</li>\r\n\t\t<li>\r\n\t\t\tThe compiled class,&nbsp;<code>RBCPTest.class</code>, is in the&nbsp;<code>build</code>&nbsp;directory.</li>\r\n\t</ul>\r\n\t<p>\r\n\t\tAlternatively, use Apache Ant and run the following command from the directory that contains the&nbsp;<code>build.xml</code>&nbsp;file:</p>\r\n\t<pre>\r\n\t<code>ant run</code></pre>\r\n\t<p>\r\n\t\tWhen you install a Java extension, you typically put the JAR file of the extension in the&nbsp;<code>lib/ext</code>&nbsp;directory of your JRE. However, this command specifies the directory that contains Java extensions with the system property&nbsp;<code>java.ext.dirs</code>.</p>\r\n\t<p>\r\n\t\tThe&nbsp;<code>RBCPTest</code>&nbsp;program first attempts to retrieve resource bundles with the base name&nbsp;<code>resources.XmlRB</code>&nbsp;and the locales&nbsp;<code>Locale.ROOT</code>&nbsp;and&nbsp;<code>Local.JAPAN</code>. The output of the program retrieving these resource bundles is similar to the following:</p>\r\n\t<pre>\r\n\t<code>Class: rbcp.XMLResourceBundleControlProvider.getControl\r\n    called for resources.XmlRB\r\n    returns rbcp.XMLResourceBundleControl@16c1857\r\nRoot locale. Key, type: XML\r\n\r\nClass: rbcp.XMLResourceBundleControlProvider.getControl\r\n    called for resources.XmlRB\r\n    returns rbcp.XMLResourceBundleControl@16c1857\r\nJapan locale. Key, type: Value from Japan locale\r\n</code></pre>\r\n\t<p>\r\n\t\tThe program successfully obtains an instance of&nbsp;<code>XMLResourceBundleControl</code>&nbsp;and accesses the properties files&nbsp;<code>XmlRB.xml</code>&nbsp;and&nbsp;<code>XmlRB_ja.xml</code>.</p>\r\n\t<p>\r\n\t\tWhen the&nbsp;<code>RBCPTest</code>&nbsp;program tries to retrieve a resource bundle, it calls all the classes defined in the configuration file&nbsp;<code>java.util.spi.ResourceBundleControlProvider</code>. For example, when the program retrieves the resource bundle with the base name&nbsp;<code>resources.RBControl</code>&nbsp;and the locale&nbsp;<code>Locale.CHINA</code>, it prints the following output:</p>\r\n\t<pre>\r\n\t<code>Class: rbcp.XMLResourceBundleControlProvider.getControl\r\n    called for resources.RBControl\r\n    returns null\r\n\r\nClass: rbcp.PropertiesResourceBundleControlProvider.getControl\r\n    called for resources.RBControl\r\n    returns rbcp.PropertiesResourceBundleControl@1ad2911\r\nlocale: zh_CN\r\n    region: China\r\n    language: Simplified Chinese</code></pre>\r\n</div>"
          }
        }
      ]
    }
  }
]