[
  {
    "query": "math-for-data-science",
    "llm_version": "gpt_4",
    "language": "English",
    "course_content": {
      "course_name": "Math for data science",
      "lessons": [
        {
          "title": "Logistic Regression",
          "topics": []
        },
        {
          "title": "Decision Trees",
          "topics": []
        },
        {
          "title": "Random Forest",
          "topics": []
        },
        {
          "title": "k-means clustering",
          "topics": []
        },
        {
          "title": "Matplotlib Tutorial",
          "topics": []
        },
        {
          "title": "Pandas Tutorial part I",
          "topics": []
        },
        {
          "title": "NumPy Tutorial",
          "topics": []
        },
        {
          "title": "SciPy Tutorial",
          "topics": []
        },
        {
          "title": "Pandas Tutorial part II",
          "topics": []
        }
      ],
      "content": [
        {
          "Logistic Regression": {
            "content": "<p>\r\n\tWe can generalize [[ link | lr-one-variable]] linear regression[[ endl ]] to the classi\ufb01cation scenario by de\ufb01ning a di\ufb00erent family of probability distributions. If we have two classes, class 0 and class 1, then we need only specify the probability of one of these classes. The probability of class 1 determines the probability of class 0, because these two values must add up to 1.The normal distribution over real-valued numbers that we used for linear regression is parametrized in terms of a mean. Any value we supply for this mean is valid. A distribution over a binary variable is slightly more complicated, because its mean must always be between 0 and 1. One way to solve this problem is to use the logistic sigmoid function to squash the output of the linear function into the interval (0, 1) and interpret that value as a probability:</p>\r\n<blockquote>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? p(y=1|x; \\theta)=\\sigma(\\theta^Tx)\" /></p>\r\n</blockquote>\r\n<p>\r\n\tThis approach is known as logistic regression(a somewhat strange name since we use the model for classi\ufb01cation rather than regression).</p>\r\n<h3>\r\n\tCost Function</h3>\r\n<p>\r\n\tWe cannot use the same cost function that we use for [[ link | lr-one-variable]] linear regression[[ endl ]]because the Logistic Function will cause the output to be wavy, causing many local optima. In other words, it will not be a convex function.</p>\r\n<p>\r\n\tInstead, our cost function for logistic regression looks like:</p>\r\n<blockquote>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? J(\\theta)=\\frac{1}{m}\\sum_{i=1}^{m}Cost(h_\\theta(x^{(i)}),y^{(i)})\" /></p>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? Cost(h_\\theta(x),y)=-\\log(h_\\theta(x))\" /> if &nbsp;<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? y=1\" /></p>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? Cost(h_\\theta(x),y)=-\\log(1-h_\\theta(x))\" /> if &nbsp;<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? y=0\" /></p>\r\n</blockquote>\r\n<h3>\r\n\tSimplified Cost Function and Gradient Descent</h3>\r\n<p>\r\n\tWe can compress our cost function&#39;s two conditional cases into one case:</p>\r\n<blockquote>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? Cost(h_\\theta(x),y)=-y\\log(h_\\theta(x))-(1-y)\\log(1-h_\\theta(x))\" /></p>\r\n</blockquote>\r\n<p>\r\n\tNotice that when y is equal to 1, then the second term <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? (1-y)\\log(1-h_\\theta(x))\" /> will be zero and will not affect the result. If y is equal to 0, then the first term <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? -y\\log(h_\\theta(x))\" /> will be zero and will not affect the result.</p>\r\n<p>\r\n\tWe can fully write out our entire cost function as follows:</p>\r\n<blockquote>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? J(\\theta)=-\\frac{1}{m}\\sum_{i=1}^{m}[y^{(i)}\\log(h_\\theta(x^{(i)}))+(1-y)\\log(1-h_\\theta(x^{(i)})]\" /></p>\r\n</blockquote>\r\n<p>\r\n\tA vectorized implementation is:</p>\r\n<blockquote>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? h=g(X\\theta)\" /> <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? J(\\theta)=\\frac{1}{m}(-y^T\\log(h)-(1-y)^T\\log(1-h))\" /></p>\r\n</blockquote>\r\n<h3>\r\n\tGradient Descent</h3>\r\n<p>\r\n\tRemember that the general form of gradient descent is:</p>\r\n<blockquote>\r\n\t<p>\r\n\t\tRepeat:</p>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? \\{\" /></p>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? \\theta_j:=\\theta_j-\\alpha\\frac{\\delta}{\\delta\\theta_j}J(\\theta)\" /></p>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? \\}\" /></p>\r\n</blockquote>\r\n<p>\r\n\tWe can work out the derivative part using calculus to get:</p>\r\n<blockquote>\r\n\t<p>\r\n\t\tRepeat:</p>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? \\{\" /></p>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? \\theta_j:=\\theta_j-\\frac{\\alpha}{m}\\sum_{i=1}^{m}(h_\\theta(x^{(i)})-y^{(i)})x_j^{(i)}\" /></p>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? \\}\" /></p>\r\n</blockquote>\r\n<p>\r\n\tNotice that this algorithm is identical to the one we used in [[ link | lr-one-variable]] linear regression[[ endl ]]. We still have to simultaneously update all values in theta.</p>\r\n<p>\r\n\tA vectorized implementation is:</p>\r\n<blockquote>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? \\theta:=\\theta-\\frac{\\alpha}{m}X^T(g(X\\theta)-\\overrightarrow{y})\" /></p>\r\n</blockquote>\r\n<h3>\r\n\tMulticlass Classification: One-vs-all</h3>\r\n<p>\r\n\tNow we will approach the classification of data when we have more than two categories. Instead of <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? y=\\{0,1\\}\" /> we will expand our definition so that <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? y=\\{0,1\\dots n \\}\" />.</p>\r\n<p>\r\n\tSince <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? y=\\{0,1\\dots n \\}\" />, we divide our problem into <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? n+1\" /> (+1 because the index starts at 0) binary classification problems; in each one, we predict the probability that <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? y\" /> is a member of one of our classes.</p>\r\n<blockquote>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? y\\in\\{0,1\\dots n\\}\" /></p>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? h_\\theta^{(0)}(x)=P(y=0|x;\\theta)\" /></p>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? h_\\theta^{(1)}(x)=P(y=1|x;\\theta)\" /></p>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? \\dots\" /></p>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? h_\\theta^{(n)}(x)=P(y=n|x;\\theta)\" /></p>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? prediction=\\max_{i}(h_\\theta^{(i)}(x))\" /></p>\r\n</blockquote>\r\n<p>\r\n\tWe are basically choosing one class and then lumping all the others into a single second class. We do this repeatedly, applying binary logistic regression to each case, and then use the hypothesis that returned the highest value as our prediction.</p>\r\n<p>\r\n\tTrain a logistic regression classifier <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? h_\\theta(x)\" /> for each class\ufffc to predict the probability that \ufffc <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? y=i\" />\ufffc. To make a prediction on a new x, pick the class \ufffcthat maximizes <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? h_\\theta(x)\" />.</p>"
          }
        },
        {
          "Decision Trees": {
            "content": "<p>\r\n\tDecision Trees (DTs) are a non-parametric supervised learning method used for classification and regression. The goal is to create a model that predicts the value of a target variable by learning simple decision rules inferred from the data features.</p>\r\n<div>\r\n\t[[ image(data-science/DT1.png, center) ]]</div>\r\n<p>\r\n\tAs shown in picture, each node of the decision tree is associated with a region in the input space, and internal nodes break that region into one subregion for each child of the node (typically using an axis-aligned cut). Space is thus subdivided into nonoverlapping regions, with a one-to-one correspondence between leaf nodes and input regions. Each leaf node usually maps every point in its input region to the same output. Decision trees are usually trained with specialized algorithms. The learning algorithm can be considered nonparametric if it is allowed to learn a tree of arbitrary size, though decision trees are usually regularized with size constraints that turn them into parametric models in practice. Decision trees as they are typically used, with axis-aligned splits and constant outputs within each node struggle to solve some problems that are easy even for logistic regression. For example, if we have a two-class problem, and the positive class occurs wherever <img border=\"0\" src=\"http://latex.codecogs.com/svg.latex?x_2&gt;x_1\" />, the decision boundary is not axis aligned. The decision tree will thus need to approximate the decision boundary with many nodes, implementing a step function that constantly walks back and forth across the true decision function with axis-aligned steps.</p>\r\n<h3>\r\n\tUsing Entropy to Find Optimal Splits</h3>\r\n<p>\r\n\tThe real problem here is not in using a decision tree, but in constructing one from data alone. At any step in the process we outlined in the example above, we need to determine which feature is the right one to split the data on. That is, we need to choose the labels for the interior nodes in so that the resulting data subsets are as homogeneous as possible. In particular, it would be nice to have a quantitative way to measure the quality of a split. Then at each step we could simply choose the feature whose split yields the highest value under this measurement.</p>\r\n<p>\r\n\tWhile we won&rsquo;t derive such a measurement, we will use one that has an extensive history of applications: Shannon entropy.</p>\r\n<blockquote>\r\n\t<p>\r\n\t\tLet <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? D\" />&nbsp;be a discrete probability distribution <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? (p_1, p_2, \\dots, p_n)\" />. Then the Shannon entropy of <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? D\" />, denoted <img border=\"0\" src=\"http://latex.codecogs.com/svg.latex? E(p_1, \\dots, p_n)\" /> is</p>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? \\displaystyle E(p_1, \\dots , p_n) = - \\sum_{i=1}^n p_i \\log(p_i)\" /></p>\r\n\t<p>\r\n\t\tWhere the logarithms are taken in base 2.</p>\r\n</blockquote>\r\n<p>\r\n\tIn English, there are n possible outcomes numbered 1 to <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? n\" />, and the probability that an instance drawn from <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? D\" /> results in the outcome <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? k\" /> is <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? p_k\" />. Then Shannon&rsquo;s entropy function computes a numerical quantity describing how &ldquo;dispersed&rdquo; the outcomes are.</p>\r\n<p>\r\n\tWhile there are many other useful interpretations of Shannon entropy, we only need it to describe how well the data is split into its classes. For our purposes, the probability distribution will simply be the observed proportions of data with respect to their class labels. In the case of Arya&rsquo;s horse riding, the initial distribution would be (1/2, 1/2), giving an entropy of 1.</p>\r\n<p>\r\n\tLet&rsquo;s verify that Shannon&rsquo;s entropy function makes sense for our problem. Specifically, the best scenario for splitting the data on a feature is a perfect split; that is, each subset only has data from one class. On the other hand, the worst case would be where each subset is uniformly distributed across all classes (if there are <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? n\" /> classes, then each subset has <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? 1/n\" /> of its data from each class).</p>\r\n<p>\r\n\tIndeed, if we adopt the convention that <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? \\log(0) = 0\" />, then the entropy of <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? (1,0, \\dots, 0)\" /> consists of a single term <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? -1 \\log(1) = 0\" />. It is clear that this does not depend on the position of the 1 within the probability distribution. On the other hand, the entropy of <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? (1/n, \\dots, 1/n)\" /> is</p>\r\n<p>\r\n\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? \\displaystyle -\\sum_{i=1}^n\\frac{1}{n}\\log \\left (\\frac{1}{n} \\right ) = -\\log \\left (\\frac{1}{n} \\right ) = -(0 - \\log(n)) = \\log(n)\" /></p>\r\n<p>\r\n\tA well-known property of the entropy function tells us that this is in fact the maximum value for this function.</p>\r\n<p>\r\n\tSummarizing this, in the best case entropy is minimized after the split, and in the worst case entropy is maximized. But we can simply look at the entropy of each subset after splitting. We need a sensible way to combine these entropies and to compare them with the entropy of the data before splitting. In particular, we would quantify the &ldquo;decrease&rdquo; in entropy caused by a split, and maximize that quantity.</p>\r\n<blockquote>\r\n\t<p>\r\n\t\t&nbsp;Let <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? S\" /> be a data set and <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? A\" /> a feature with values <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? v \\in V\" />, and let <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? E\" /> denote Shannon&rsquo;s entropy function. Moreover, let <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? S_v\" /> denote the subset of <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? S\" /> for which the feature <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? A\" /> has the value <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? v\" />. The gain of a split along the feature <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? A\" />, denoted <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? G(S,A)\" /> is</p>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? \\displaystyle G(S,A) = E(S) - \\sum_{v \\in V} \\frac{|S_v|}{|S|} E(S_v)\" /></p>\r\n</blockquote>\r\n<p>\r\n\tThat is, we are taking the difference of the entropy before the split, and subtracting off the entropies of each part after splitting, with an appropriate weight depending on the size of each piece. Indeed, if the entropy grows after the split (that is if the data becomes more mixed), then this number will be small. On the other hand if the split separates the classes nicely, each subset <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? S_v\" /> will have small entropy, and hence the value will be large.</p>\r\n<blockquote>\r\n\t<p>\r\n\t\tSo now the algorithm for building trees is apparent: at each stage, simply pick the feature for which the gain function is maximized, and split the data on that feature. Create a child node for each of the subsets in the split, and connect them via edges with labels corresponding to the chosen feature value for that piece.</p>\r\n</blockquote>"
          }
        },
        {
          "Random Forest": {
            "content": "<p>\r\n\tRandom forests or random decision forests are an ensemble learning method for classification, regression and other tasks, that operate by constructing a multitude of decision trees at training time and outputting the class that is the mode of the classes (classification) or mean prediction (regression) of the individual trees. Random decision forests correct for decision trees&#39; habit of overfitting to their training set.</p>\r\n<h3>\r\n\tPreliminaries: decision tree learning</h3>\r\n<p>\r\n\tDecision trees are a popular method for various machine learning tasks. Tree learning &quot;come[s] closest to meeting the requirements for serving as an off-the-shelf procedure for data mining&quot;, say Hastie et al., &quot;because it is invariant under scaling and various other transformations of feature values, is robust to inclusion of irrelevant features, and produces inspectable models. However, they are seldom accurate&quot;.</p>\r\n<p>\r\n\tIn particular, trees that are grown very deep tend to learn highly irregular patterns: they overfit their training sets, i.e. have low bias, but very high variance. Random forests are a way of averaging multiple deep decision trees, trained on different parts of the same training set, with the goal of reducing the variance. This comes at the expense of a small increase in the bias and some loss of interpretability, but generally greatly boosts the performance in the final model.</p>\r\n<h3>\r\n\tTree bagging</h3>\r\n<p>\r\n\tThe training algorithm for random forests applies the general technique of bootstrap aggregating, or bagging, to tree learners. Given a training set<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? X = x_1, \\dots, x_n\" /> with responses <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? Y = y_1, \\dots, y_n\" />, bagging repeatedly (<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? B\" /> times) selects a random sample with replacement of the training set and fits trees to these samples:</p>\r\n<blockquote>\r\n\t<p>\r\n\t\tFor <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? b = 1, \\dots, B\" />:</p>\r\n\t<ol>\r\n\t\t<li>\r\n\t\t\tSample, with replacement, n training examples from <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? X, Y\" />; call these <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? X_b, Y_b\" />.</li>\r\n\t\t<li>\r\n\t\t\tTrain a classification or regression tree <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? f_b\" /> on <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? X_b, Y_b\" />.</li>\r\n\t</ol>\r\n</blockquote>\r\n<blockquote>\r\n\t<p>\r\n\t\tAfter training, predictions for unseen samples <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? x'\" />; can be made by averaging the predictions from all the individual regression trees on <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? x'\" />:</p>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? \\widehat{f}= \\frac{1}{B}\\sum_{b=1}^{B}f_b(x')\" /></p>\r\n\t<p>\r\n\t\tor by taking the majority vote in the case of classification trees.</p>\r\n</blockquote>\r\n<p>\r\n\tThis bootstrapping procedure leads to better model performance because it decreases the variance of the model, without increasing the bias. This means that while the predictions of a single tree are highly sensitive to noise in its training set, the average of many trees is not, as long as the trees are not correlated. Simply training many trees on a single training set would give strongly correlated trees (or even the same tree many times, if the training algorithm is deterministic); bootstrap sampling is a way of de-correlating the trees by showing them different training sets.</p>\r\n<blockquote>\r\n\t<p>\r\n\t\tAdditionally, an estimate of the uncertainty of the prediction can be made as the standard deviation of the predictions from all the individual regression trees on <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? x'\" />:</p>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? \\sigma = \\sqrt{\\frac{\\sum_{b=1}^{B}(f_b(x')-\\widehat{f})^2}{B-1}}\" /></p>\r\n</blockquote>\r\n<p>\r\n\tThe number of samples/trees, <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? B\" />, is a free parameter. Typically, a few hundred to several thousand trees are used, depending on the size and nature of the training set. An optimal number of trees <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? B\" /> can be found using cross-validation, or by observing the out-of-bag error: the mean prediction error on each training sample <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? x_i\" />, using only the trees that did not have <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? x_i\" /> in their bootstrap sample. The training and test error tend to level off after some number of trees have been fit.</p>\r\n<h3>\r\n\tFrom bagging to random forests</h3>\r\n<p>\r\n\tThe above procedure describes the original bagging algorithm for trees. Random forests differ in only one way from this general scheme: they use a modified tree learning algorithm that selects, at each candidate split in the learning process, a random subset of the features. This process is sometimes called &quot;feature bagging&quot;. The reason for doing this is the correlation of the trees in an ordinary bootstrap sample: if one or a few features are very strong predictors for the response variable (target output), these features will be selected in many of the <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? B\" /> trees, causing them to become correlated. An analysis of how bagging and random subspace projection contribute to accuracy gains under different conditions is given by <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? H_0\" />.</p>\r\n<p>\r\n\tTypically, for a classification problem with <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? p\" /> features, <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? \\sqrt{p}\" /> (rounded down) features are used in each split. For regression problems the inventors recommend <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? p/3\" /> (rounded down) with a minimum node size of 5 as the default.</p>\r\n<h3>\r\n\tExtra Trees</h3>\r\n<p>\r\n\tAdding one further step of randomization yields extremely randomized trees, or ExtraTrees. While similar to ordinary random forests in that they are an ensemble of individual trees, there are two main differences: first, each tree is trained using the whole learning sample (rather than a bootstrap sample), and second, the top-down splitting in the tree learner is randomized. Instead of computing the locally optimal cut-point for each feature under consideration (based on, e.g., information gain or the Gini impurity), a random cut-point is selected. This value is selected from a uniform distribution within the feature&#39;s empirical range (in the tree&#39;s training set). Then, of all the randomly generated splits, the split that yields the highest score is chosen to split the node. Similar to ordinary random forests, the number of randomly selected features to be considered at each node can be specified. Default values for this parameter are <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? \\sqrt {n}\" /> for classification and <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? n\" /> for regression, where <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? n\" /> is the number of features in the model.&nbsp;</p>"
          }
        },
        {
          "k-means clustering": {
            "content": "<p>\r\n\tk-means clustering is a method of vector quantization, originally from signal processing, that is popular for cluster analysis in data mining. k-means clustering aims to partition n observations into k clusters in which each observation belongs to the cluster with the nearest mean, serving as a prototype of the cluster. This results in a partitioning of the data space into Voronoi cells.</p>\r\n<p>\r\n\tThe problem is computationally difficult (NP-hard); however, there are efficient heuristic algorithms that are commonly employed and converge quickly to a local optimum. These are usually similar to the expectation-maximization algorithm for mixtures of Gaussian distributions via an iterative refinement approach employed by both k-means and Gaussian mixture modeling. Additionally, they both use cluster centers to model the data; however, k-means clustering tends to find clusters of comparable spatial extent, while the expectation-maximization mechanism allows clusters to have different shapes.</p>\r\n<p>\r\n\tThe algorithm has a loose relationship to the k-nearest neighbor classifier, a popular machine learning technique for classification that is often confused with k-means due to the k in the name. One can apply the 1-nearest neighbor classifier on the cluster centers obtained by k-means to classify new data into the existing clusters. This is known as nearest centroid classifier or Rocchio algorithm.</p>\r\n<h3>\r\n\tStandard algorithm</h3>\r\n<p>\r\n\tThe most common algorithm uses an iterative refinement technique. Due to its ubiquity it is often called the k-means algorithm; it is also referred to as Lloyd`s algorithm, particularly in the computer science community.</p>\r\n<p>\r\n\tGiven an initial set of <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? k\" /> means <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? m_1^{(1)},\\dots,m_k^{(1)}\" /> (see below), the algorithm proceeds by alternating between two steps:</p>\r\n<blockquote>\r\n\t<p>\r\n\t\tAssignment step: Assign each observation to the cluster whose mean has the least squared Euclidean distance, this is intuitively the &quot;nearest&quot; mean.(Mathematically, this means partitioning the observations according to the Voronoi diagram generated by the means).</p>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? S_i^{(t)}={x_p:||x_p-m_i^{(t)}||^{2} \\leq ||x_p-m_j^{(t)}||^{2} \\forall j, 1 \\leq j \\leq k},\" /></p>\r\n\t<p>\r\n\t\twhere each <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? x_p\" /> is assigned to exactly one <img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? S^{(t)}\" /> , even if it could be assigned to two or more of them.</p>\r\n</blockquote>\r\n<blockquote>\r\n\t<p>\r\n\t\tUpdate step: Calculate the new means to be the centroids of the observations in the new clusters.</p>\r\n\t<p>\r\n\t\t<img a=\"\" be=\"\" border=\"0\" discrete=\"\" distribution=\"\" img=\"\" probability=\"\" src=\"http://latex.codecogs.com/svg.latex? m_i^{(t+1)}= \\frac{1}{|S_i^{(t)}|}\\sum_{x_j \\in S_i^{(t)}}x_j\" /></p>\r\n</blockquote>\r\n<p>\r\n\tThe algorithm has converged when the assignments no longer change. There is no guarantee that the optimum is found using this algorithm.</p>\r\n<p>\r\n\tThe algorithm is often presented as assigning objects to the nearest cluster by distance. Using a different distance function other than (squared) Euclidean distance may stop the algorithm from converging. Various modifications of k-means such as spherical k-means and k-medoids have been proposed to allow using other distance measures.</p>\r\n<h3>\r\n\tDemonstration of the standart algorithm</h3>\r\n<div>\r\n\t[[ image(data-science/km.png, center) ]]</div>\r\n<p>\r\n\t1. k initial &quot;means&quot; (in this case k=3) are randomly generated within the data domain (shown in color).</p>\r\n<div>\r\n\t[[ image(data-science/km2.png, center) ]]</div>\r\n<p>\r\n\t2. k clusters are created by associating every observation with the nearest mean. The partitions here represent the Voronoi diagram generated by the means.</p>\r\n<div>\r\n\t[[ image(data-science/km3.png, center) ]]</div>\r\n<p>\r\n\t3.&nbsp; The centroid of each of the k clusters becomes the new mean.</p>\r\n<div>\r\n\t[[ image(data-science/km3.png, center) ]]</div>\r\n<p>\r\n\t4. Steps 2 and 3 are repeated until convergence has been reached.</p>"
          }
        },
        {
          "Matplotlib Tutorial": {
            "content": "<p>\r\n\tMatplotlib is a Python 2D plotting library which produces publication quality figures in a variety of hardcopy formats and interactive environments across platforms. Matplotlib can be used in Python scripts, the Python and IPython shells, the Jupyter notebook, web application servers, and four graphical user interface toolkits.</p>\r\n<p>\r\n\tMatplotlib tries to make easy things easy and hard things possible. You can generate plots, histograms, power spectra, bar charts, errorcharts, scatterplots, etc., with just a few lines of code. For examples, see the sample plots and thumbnail gallery.</p>\r\n<p>\r\n\tIt is used along with NumPy to provide an environment that is an effective open source alternative for MatLab. It can also be used with graphics toolkits like PyQt and wxPython.</p>\r\n<h2>\r\n\t2D plots</h2>\r\n<p>\r\n\tConventionally, the package is imported into the Python script by adding the following statement</p>\r\n<pre>\r\n<code class=\"python\">from <span _fck_bookmark=\"1\" style=\"display: none;\"> </span>matplotlib import pyplot as plt<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><span _fck_bookmark=\"1\" style=\"display: none;\"> </span><span _fck_bookmark=\"1\" style=\"display: none;\"> </span></code></pre>\r\n<p>\r\n\tHere <code class=\"python\">pyplot()</code> is the most important function in matplotlib library, which is used to plot 2D data. The following script plots the equation y = 2x + 5</p>\r\n<pre>\r\n<code class=\"python\">import numpy as np\r\nfrom matplotlib import pyplo<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>t as plt \r\n\r\nx = np.arange(1,11)\r\ny = 2 * x + 5\r\nplt.title(&quot;Matplotlib demo&quot;)\r\nplt.xlabel(&quot;x axis caption&quot;)\r\nplt.ylabel(&quot;y axis caption&quot;)\r\nplt.plot(x,y)\r\nplt.show() </code></pre>\r\n<p>\r\n\tAn ndarray object x is created from <code class=\"python\">np.arange()</code> function as the values on the x axis. The corresponding values on the y axis are stored in another ndarray object y. These values are plotted using <code class=\"python\">plot()</code> function of pyplot submodule of matplotlib package. The graphical representation is displayed by <code class=\"python\">show() </code>function.</p>\r\n<p>\r\n\tThe above code should produce the following output</p>\r\n<div>\r\n\t[[ image(data-science/mpl1.png, center) ]]</div>\r\n<p>\r\n\tInstead of the linear graph, the values can be displayed discretely by adding a format string to the <code class=\"python\">plot()</code> function. Following formatting characters can be used.</p>\r\n<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width: 500px\">\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tCharacter</th>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tDescription</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;-&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tSolid line style</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;--&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tDashed line style</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;-.&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tDash-dot line style</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;:&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tDotted line style</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;.&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tPoint marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;,&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tPixel marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;o&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tCircle marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;v&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tTriangle_down marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;^&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tTriangle_up marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;&lt;&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tTriangle_left marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;&gt;&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tTriangle_right marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;1&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tTri_down marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;2&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tTri_up marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;3&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tTri_left marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;4&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tTri_right marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;s&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tSquare marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;p&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tPentagon marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;*&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tStar marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;h&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tHexagon1 marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;H&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tHexagon2 marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;+&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tPlus marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;x&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tX marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;D&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tDiamond marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;d&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tThin_diamond marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;|&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tVline marker</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;_&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tHline marker</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n<p>\r\n\tThe following color abbreviations are also defined.</p>\r\n<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width: 500px\">\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tCharacter</th>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tColor</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;b&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tBlue</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;g&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tGreen</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;r&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tRed</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;c&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tCyan</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;m&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tMagenta</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;y&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tYellow</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;k&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tBlack</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&#39;w&#39;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tWhite</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n<p>\r\n\tTo display the circles representing points, instead of the line in the above example, use &ldquo;ob&rdquo; as the format string in <code class=\"python\">plot()</code> function.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\">import numpy as np \r\nfrom matplotlib import pyplot as plt\r\n \r\nx = np.arange(1,11) \r\ny = 2 * x + 5 \r\nplt.title(&quot;Matplotlib demo&quot;) \r\nplt.xlabel(&quot;x axis caption&quot;) \r\nplt.ylabel(&quot;y axis caption&quot;) \r\nplt.plot(x,y,&quot;ob&quot;) \r\nplt.show() \r\n\r\n</code></pre>\r\n<p>\r\n\tThe above code should produce the following output</p>\r\n<div>\r\n\t[[ image(data-science/mpl2.png, center) ]]</div>\r\n<h3>\r\n\tSine Wave Plot</h3>\r\n<p>\r\n\tThe following script produces the sine wave plot using matplotlib.</p>\r\n<pre>\r\n<code class=\"python\"><code>import numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\n# Compute the x and y coordinates for points on a sine curve\r\nx = np.arange(0, 3 * np.pi, 0.1)\r\ny = np.sin(x)\r\nplt.title(&quot;sine wave form&quot;)\r\n\r\n# Plot the points using matplotlib\r\nplt.plot(x, y)\r\nplt.show() </code></code><span _fck_bookmark=\"1\" style=\"display: none;\"> </span> </pre>\r\n<div>\r\n\t[[ image(data-science/mpl3.png, center) ]]</div>\r\n<h3>\r\n\t<code class=\"python\">subplot()</code></h3>\r\n<p>\r\n\tThe <code class=\"python\">subplot()</code> function allows you to plot different things in the same figure. In the following script, sine and cosine values are plotted.</p>\r\n<pre>\r\n<code class=\"python\">import numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\n# Compute the x and y coordinates for points on sine and cosine curves\r\nx = np.arange(0, 3 * np.pi, 0.1)\r\ny_sin = np.sin(x)\r\ny_cos = np.cos(x)\r\n\r\n# Set up a subplot grid that has height 2 and width 1,\r\n# and set the first such subplot as active.\r\nplt.subplot(2, 1, 1)\r\n\r\n# Make the first plot\r\nplt.plot(x, y_sin)\r\nplt.title(&#39;Sine&#39;)\r\n\r\n# Set the second subplot as active, and make the second plot.\r\nplt.subplot(2, 1, 2)\r\nplt.plot(x, y_cos)\r\nplt.title(&#39;Cosine&#39;)\r\n\r\n# Show the figure.\r\nplt.show()<span _fck_bookmark=\"1\" style=\"display: none;\"> </span> </code></pre>\r\n<div>\r\n\t[[ image(data-science/mpl4.png, center) ]]</div>\r\n<h3>\r\n\t<code class=\"python\">bar()</code></h3>\r\n<p>\r\n\tThe pyplot submodule provides <code class=\"python\">bar()</code> function to generate bar graphs. The following example produces the bar graph of two sets of x and y arrays.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\">from matplotlib import pyplot as plt \r\nx = [5,8,10] \r\ny = [12,16,6]  \r\n\r\nx2 = [6,9,11] \r\ny2 = [6,15,7] \r\nplt.bar(x, y, align = &#39;center&#39;) \r\nplt.bar(x2, y2, color = &#39;g&#39;, align = &#39;center&#39;) \r\nplt.title(&#39;Bar graph&#39;) \r\nplt.ylabel(&#39;Y axis&#39;) \r\nplt.xlabel(&#39;X axis&#39;)  \r\n\r\nplt.show()\r\n\r\n</code></pre>\r\n<div>\r\n\t[[ image(data-science/mpl5.png, center) ]]</div>\r\n<h2>\r\n\tHistogram Using Matplotlib</h2>\r\n<p>\r\n\tNumPy has a <code class=\"python\">numpy.histogram()</code> function that is a graphical representation of the frequency distribution of data. Rectangles of equal horizontal size corresponding to class interval called bin and variable height corresponding to frequency.</p>\r\n<h3>\r\n\t<code class=\"python\">numpy.histogram()</code></h3>\r\n<p>\r\n\tThe <code class=\"python\">numpy.histogram()</code> function takes the input array and bins as two parameters. The successive elements in bin array act as the boundary of each bin.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\">import numpy as np \r\n   \r\na = np.array([22,87,5,43,56,73,55,54,11,20,51,5,79,31,27]) \r\nnp.histogram(a,bins = [0,20,40,60,80,100]) \r\nhist,bins = np.histogram(a,bins = [0,20,40,60,80,100]) \r\nprint hist \r\nprint bins \r\n\r\n</code></pre>\r\n<p>\r\n\tIt will produce the following output</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>[3 4 5 2 1]\r\n[0 20 40 60 80 100]\r\n\r\n</pre>\r\n<h3>\r\n\t<code class=\"python\">plt()</code></h3>\r\n<p>\r\n\tMatplotlib can convert this numeric representation of histogram into a graph. The <code class=\"python\">plt()</code> function of pyplot submodule takes the array containing the data and bin array as parameters and converts into a histogram.</p>\r\n<pre>\r\n<code class=\"python\">from matplotlib import pyplot as plt\r\nimport numpy as np\r\n\r\na = np.array([22,87,5,43,56,73,55,54,11,20,51,5,79,31,27])\r\nplt.hist(a, bins = [0,20,40,60,80,100])\r\nplt.title(&quot;histogram&quot;)\r\nplt.show()<span _fck_bookmark=\"1\" style=\"display: none;\"> </span> </code></pre>\r\n<div>\r\n\t[[ image(data-science/mpl6.png, center) ]]</div>"
          }
        },
        {
          "Pandas Tutorial part I": {
            "content": "<p>\r\n\tPandas is an open-source Python Library providing high-performance data manipulation and analysis tool using its powerful data structures. The name Pandas is derived from the word Panel Data &ndash; an Econometrics from Multidimensional data.</p>\r\n<p>\r\n\tPrior to Pandas, Python was majorly used for data munging and preparation. It had very little contribution towards data analysis. Pandas solved this problem. Using Pandas, we can accomplish five typical steps in the processing and analysis of data, regardless of the origin of data &mdash; load, prepare, manipulate, model, and analyze.</p>\r\n<p>\r\n\tPython with Pandas is used in a wide range of fields including academic and commercial domains including finance, economics, Statistics, analytics, etc.</p>\r\n<h2>\r\n\tKey Features of Pandas</h2>\r\n<ul>\r\n\t<li>\r\n\t\tFast and efficient DataFrame object with default and customized indexing.</li>\r\n\t<li>\r\n\t\tTools for loading data into in-memory data objects from different file formats.</li>\r\n\t<li>\r\n\t\tData alignment and integrated handling of missing data.</li>\r\n\t<li>\r\n\t\tReshaping and pivoting of date sets.</li>\r\n\t<li>\r\n\t\tLabel-based slicing, indexing and subsetting of large data sets.</li>\r\n\t<li>\r\n\t\tColumns from a data structure can be deleted or inserted.</li>\r\n\t<li>\r\n\t\tGroup by data for aggregation and transformations.</li>\r\n\t<li>\r\n\t\tHigh performance merging and joining of data.</li>\r\n\t<li>\r\n\t\tTime Series functionality</li>\r\n</ul>\r\n<h2>\r\n\tIntroduction to Data Structures</h2>\r\n<p>\r\n\tPandas deals with the following three data structures &minus;</p>\r\n<ul>\r\n\t<li>\r\n\t\tSeries</li>\r\n\t<li>\r\n\t\tDataFrame</li>\r\n\t<li>\r\n\t\tPanel</li>\r\n</ul>\r\n<p>\r\n\tThese data structures are built on top of Numpy array, which means they are fast.</p>\r\n<h3>\r\n\tDimension &amp; Description</h3>\r\n<p>\r\n\tThe best way to think of these data structures is that the higher dimensional data structure is a container of its lower dimensional data structure. For example, DataFrame is a container of Series, Panel is a container of DataFrame.</p>\r\n<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width: 500px\">\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tData Structure</th>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tDimensions</th>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tDescription</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tSeries</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t1</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t1D labeled homogeneous array, sizeimmutable.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tDataFrame</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t2</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tGeneral 2D labeled, size-mutable tabular structure with potentially heterogeneously typed columns.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tPanel</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t3</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tGeneral 3D labeled, size-mutable array.</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n<p>\r\n\tBuilding and handling two or more dimensional arrays is a tedious task, burden is placed on the user to consider the orientation of the data set when writing functions. But using Pandas data structures, the mental effort of the user is reduced.</p>\r\n<p>\r\n\tFor example, with tabular data (DataFrame) it is more semantically helpful to think of the index (the rows) and the columns rather than axis 0 and axis 1.</p>\r\n<h4>\r\n\tMutability</h4>\r\n<p>\r\n\tAll Pandas data structures are value mutable (can be changed) and except Series all are size mutable. Series is size immutable.</p>\r\n<p>\r\n\tNote &minus; DataFrame is widely used and one of the most important data structures. Panel is used much less.</p>\r\n<h3>\r\n\tSeries</h3>\r\n<p>\r\n\tSeries is a one-dimensional array like structure with homogeneous data. For example, the following series is a collection of integers 10, 23, 56, &hellip;</p>\r\n<div>\r\n\t<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width: 500px\">\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t10</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t23</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t56</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t17</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t52</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t61</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t73</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t90</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t26</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t72</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<h4>\r\n\tKey Points</h4>\r\n<ul>\r\n\t<li>\r\n\t\tHomogeneous data</li>\r\n\t<li>\r\n\t\tSize Immutable</li>\r\n\t<li>\r\n\t\tValues of Data Mutable</li>\r\n</ul>\r\n<h3>\r\n\tDataFrame</h3>\r\n<p>\r\n\tDataFrame is a two-dimensional array with heterogeneous data. For example</p>\r\n<div>\r\n\t<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width: 500px\">\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th scope=\"col\">\r\n\t\t\t\t\tName</th>\r\n\t\t\t\t<th scope=\"col\">\r\n\t\t\t\t\tAge</th>\r\n\t\t\t\t<th scope=\"col\">\r\n\t\t\t\t\tGender</th>\r\n\t\t\t\t<th scope=\"col\">\r\n\t\t\t\t\tRating</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\tSteve</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t32</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\tMale</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t3.45</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\tLia</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t28</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\tFemale</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t4.6</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\tVin</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t45</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\tMale</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t3.9</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\tKatie</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t38</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\tFemale</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t2.78</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<p>\r\n\tThe table represents the data of a sales team of an organization with their overall performance rating. The data is represented in rows and columns. Each column represents an attribute and each row represents a person.</p>\r\n<h4>\r\n\tData Type of Columns</h4>\r\n<p>\r\n\tThe data types of the four columns are as follows</p>\r\n<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width: 500px\">\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tColumn</th>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tType</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tName</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tString</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tAge</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tInteger</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tGender</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tString</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tRating</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tFloat</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n<h4>\r\n\tKey Points</h4>\r\n<ul>\r\n\t<li>\r\n\t\tHeterogeneous data</li>\r\n\t<li>\r\n\t\tSize Mutable</li>\r\n\t<li>\r\n\t\tData Mutable</li>\r\n</ul>\r\n<h3>\r\n\tPanel</h3>\r\n<p>\r\n\tPanel is a three-dimensional data structure with heterogeneous data. It is hard to represent the panel in graphical representation. But a panel can be illustrated as a container of DataFrame.</p>\r\n<h4>\r\n\tKey Points</h4>\r\n<ul>\r\n\t<li>\r\n\t\tHeterogeneous data</li>\r\n\t<li>\r\n\t\tSize Mutable</li>\r\n\t<li>\r\n\t\tData Mutable</li>\r\n</ul>\r\n<h2>\r\n\tPython Pandas - Series</h2>\r\n<p>\r\n\tSeries is a one-dimensional labeled array capable of holding data of any type (integer, string, float, python objects, etc.). The axis labels are collectively called index.</p>\r\n<h3>\r\n\t<code class=\"python\">pandas.Series</code></h3>\r\n<p>\r\n\tA pandas Series can be created using the following constructor</p>\r\n<pre>\r\n<code class=\"python\">pandas.Series( data, index, dtype, copy)\r\n</code><span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<p>\r\n\tThe parameters of the constructor are as follows</p>\r\n<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width: 500px\">\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tParameter</th>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tDescription</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tdata</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tdata takes various forms like ndarray, list, constants</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tindex</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tindex values must be unique and hashable, same length as data. Default <code class=\"python\">np.arrange(n)</code> if no index is passed.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tdtype</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tdtype is for data type. If None, data type will be inferred</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tcopy</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tCopy data. Default False</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n<p>\r\n\tA series can be created using various inputs like</p>\r\n<ul>\r\n\t<li>\r\n\t\tArray</li>\r\n\t<li>\r\n\t\tDict</li>\r\n\t<li>\r\n\t\tScalar value or constant</li>\r\n</ul>\r\n<h3>\r\n\tCreate a Series</h3>\r\n<h4>\r\n\tCreate an Empty Series</h4>\r\n<p>\r\n\tA basic series, which can be created is an Empty Series.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\">#import the pandas library and aliasing as pd\r\nimport pandas as pd\r\ns = pd.Series()\r\nprint s\r\n\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>Series([], dtype: float64) \r\n</pre>\r\n<h4>\r\n\tCreate a Series from ndarray</h4>\r\n<p>\r\n\tIf data is an ndarray, then index passed must be of the same length. If no index is passed, then by default index will be <code class=\"python\">range(n)</code> where n is array length, i.e., [0,1,2,3&hellip;. range(len(array))-1].</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\">#import the pandas library and aliasing as pd\r\nimport pandas as pd\r\nimport numpy as np\r\ndata = np.array([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\r\ns = pd.Series(data)\r\nprint s\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>0   a\r\n1   b\r\n2   c\r\n3   d\r\ndtype: object\r\n\r\n</pre>\r\n<p>\r\n\tWe did not pass any index, so by default, it assigned the indexes ranging from 0 to len(data)-1, i.e., 0 to 3.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\">#import the pandas library and aliasing as pd\r\nimport pandas as pd\r\nimport numpy as np\r\ndata = np.array([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])\r\ns = pd.Series(data,index=[100,101,102,103])\r\nprint s\r\n\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>100  a\r\n101  b\r\n102  c\r\n103  d\r\ndtype: object\r\n\r\n</pre>\r\n<p>\r\n\tWe passed the index values here. Now we can see the customized indexed values in the output.</p>\r\n<h4>\r\n\tCreate a Series from dict</h4>\r\n<p>\r\n\tA dict can be passed as input and if no index is specified, then the dictionary keys are taken in a sorted order to construct index. If index is passed, the values in data corresponding to the labels in the index will be pulled out.</p>\r\n<pre>\r\n<code class=\"python\">#import the pandas library and aliasing as pd\r\nimport pandas as pd\r\nimport numpy as np\r\ndata = {&#39;a&#39; : 0., &#39;b&#39; : 1., &#39;c&#39; : 2.}\r\ns = pd.Series(data)\r\nprint s\r\n</code><span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<p>\r\n\tIts output is as follows</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>a 0.0\r\nb 1.0\r\nc 2.0\r\ndtype: float64 \r\n</pre>\r\n<p>\r\n\tObserve &minus; Dictionary keys are used to construct index.</p>\r\n<pre>\r\n<code class=\"python\">#import the pandas library and aliasing as pd\r\nimport pandas as pd\r\nimport numpy as np\r\ndata = {&#39;a&#39; : 0., &#39;b&#39; : 1., &#39;c&#39; : 2.}\r\ns = pd.Series(data,index=[&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;a&#39;])\r\nprint s\r\n</code><span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<p>\r\n\tIts output is as follows</p>\r\n<pre>\r\nb 1.0\r\nc 2.0\r\nd NaN\r\na 0.0\r\ndtype: float64<span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<p>\r\n\tObserve &minus; Index order is persisted and the missing element is filled with NaN (Not a Number).</p>\r\n<h4>\r\n\tCreate a Series from Scalar</h4>\r\n<p>\r\n\tIf data is a scalar value, an index must be provided. The value will be repeated to match the length of index</p>\r\n<pre>\r\n<code class=\"python\">#import the pandas library and aliasing as pd\r\nimport pandas as pd\r\nimport numpy as np\r\ns = pd.Series(5, index=[0, 1, 2, 3])\r\nprint s</code><span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<p>\r\n\tIts output is as follows</p>\r\n<pre>\r\n0 5\r\n1 5\r\n2 5\r\n3 5\r\ndtype: int64<span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<h3>\r\n\tAccessing Data from Series with Position</h3>\r\n<p>\r\n\tData in the series can be accessed similar to that in an ndarray.</p>\r\n<h4>\r\n\tExample 1</h4>\r\n<p>\r\n\tRetrieve the first element. As we already know, the counting starts from zero for the array, which means the first element is stored at zeroth position and so on.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\ns = pd.Series([1,2,3,4,5],index = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])\r\n#retrieve the first element\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>print s[0]</code></pre>\r\n<p>\r\n\tIts output is as follows</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>1</pre>\r\n<h4>\r\n\tExample 2</h4>\r\n<p>\r\n\tRetrieve the first three elements in the Series. If a : is inserted in front of it, all items from that index onwards will be extracted. If two parameters (with : between them) is used, items between the two indexes (not including the stop index)</p>\r\n<pre>\r\n<code class=\"python\"><code class=\"ruby\">import pandas as pd\r\ns = pd.Series([1,2,3,4,5],index = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])\r\n#retrieve the first three element\r\nprint s[:3]</code></code><span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>a 1\r\nb 2\r\nc 3\r\ndtype: int64<span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<h4>\r\n\tExample 3</h4>\r\n<p>\r\n\tRetrieve the last three elements.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\ns = pd.Series([1,2,3,4,5],index = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])\r\n#retrieve the last three element\r\nprint s[-3:]</code><span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<p>\r\n\tIts output is as follows</p>\r\n<pre>\r\nc 3\r\nd 4\r\ne 5\r\ndtype: int64 \r\n</pre>\r\n<h3>\r\n\tRetrieve Data Using Label (Index)</h3>\r\n<p>\r\n\tA Series is like a fixed-size dict in that you can get and set values by index label.</p>\r\n<h4>\r\n\tExample 1</h4>\r\n<p>\r\n\tRetrieve a single element using index label value.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\ns = pd.Series([1,2,3,4,5],index = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])\r\n#retrieve a single element\r\nprint s[&#39;a&#39;]</code><span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<p>\r\n\tIts output is as follows</p>\r\n<pre>\r\n1<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tExample 2</h4>\r\n<p>\r\n\tRetrieve multiple elements using a list of index label values.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\ns = pd.Series([1,2,3,4,5],index = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])\r\n#retrieve multiple elements\r\nprint s[[&#39;a&#39;,&#39;c&#39;,&#39;d&#39;]]<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows</p>\r\n<pre>\r\na 1\r\nc 3\r\nd 4\r\ndtype: int64<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tExample 3</h4>\r\n<p>\r\n\tIf a label is not contained, an exception is raised.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\ns = pd.Series([1,2,3,4,5],index = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])\r\n#retrieve multiple elements<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint s[&#39;f&#39;]\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows</p>\r\n<pre>\r\n&hellip;<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nKeyError: &#39;f&#39; </pre>\r\n<h2>\r\n\tPython Pandas - DataFrame</h2>\r\n<p>\r\n\tA Data frame is a two-dimensional data structure, i.e., data is aligned in a tabular fashion in rows and columns.</p>\r\n<h4>\r\n\tFeatures of DataFrame</h4>\r\n<ul>\r\n\t<li>\r\n\t\tPotentially columns are of different types</li>\r\n\t<li>\r\n\t\tSize &ndash; Mutable</li>\r\n\t<li>\r\n\t\tLabeled axes (rows and columns)</li>\r\n\t<li>\r\n\t\tCan Perform Arithmetic operations on rows and columns</li>\r\n</ul>\r\n<h4>\r\n\tStructure</h4>\r\n<p>\r\n\tLet us assume that we are creating a data frame with student&rsquo;s data.</p>\r\n<div>\r\n\t<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width: 500px\">\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th scope=\"col\">\r\n\t\t\t\t\tRegd.No</th>\r\n\t\t\t\t<th scope=\"col\">\r\n\t\t\t\t\tName</th>\r\n\t\t\t\t<th scope=\"col\">\r\n\t\t\t\t\tMarks%</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t1000</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\tSteve</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t86.29</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t1001</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\tMathew</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t91.63</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t1002</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\tJose</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t72.90</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t1003</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\tPatty</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t69.23</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t1004</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\tVin</td>\r\n\t\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t\t88.30</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<p>\r\n\tYou can think of it as an SQL table or a spreadsheet data representation.</p>\r\n<h3>\r\n\t<code class=\"python\">pandas.DataFrame</code></h3>\r\n<p>\r\n\tA pandas DataFrame can be created using the following constructor&nbsp;</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\">pandas.DataFrame( data, index, columns, dtype, copy)</code></pre>\r\n<p>\r\n\tThe parameters of the constructor are as follows&nbsp;</p>\r\n<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width: 500px\">\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tParameter</th>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tDescription</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tdata</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tdata takes various forms like ndarray, series, map, lists, dict, constants and also another DataFrame.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tindex</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tFor the row labels, the Index to be used for the resulting frame is Optional Default <code class=\"python\"><code class=\"ruby\">np.arrange(n)</code></code> if no index is passed.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tcolumns</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tFor column labels, the optional default syntax is - <code class=\"python\">np.arrange(n)</code>. This is only true if no index is passed.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tdtype</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tData type of each column.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tcopy</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tThis command (or whatever it is) is used for copying of data, if the default is False.</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n<h3>\r\n\tCreate DataFrame</h3>\r\n<p>\r\n\tA pandas DataFrame can be created using various inputs like&nbsp;</p>\r\n<ul>\r\n\t<li>\r\n\t\tLists</li>\r\n\t<li>\r\n\t\tdict</li>\r\n\t<li>\r\n\t\tSeries</li>\r\n\t<li>\r\n\t\tNumpy ndarrays</li>\r\n\t<li>\r\n\t\tAnother DataFrame</li>\r\n</ul>\r\n<p>\r\n\tIn the subsequent sections of this chapter, we will see how to create a DataFrame using these inputs.</p>\r\n<h4>\r\n\tCreate an Empty DataFrame</h4>\r\n<p>\r\n\tA basic DataFrame, which can be created is an Empty Dataframe.</p>\r\n<h4>\r\n\tExample</h4>\r\n<pre>\r\n<code class=\"python\">#import the pandas library and aliasing as pd\r\nimport pandas as pd\r\ndf = pd.DataFrame()\r\nprint df</code><span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>Empty DataFrame\r\nColumns: []\r\nIndex: []</pre>\r\n<h4>\r\n\tCreate a DataFrame from Lists</h4>\r\n<p>\r\n\tThe DataFrame can be created using a single list or a list of lists.</p>\r\n<h4>\r\n\tExample 1</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\ndata = [1,2,3,4,5]\r\ndf = pd.DataFrame(data)\r\nprint df</code><span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0\r\n0 1\r\n1 2\r\n2 3\r\n3 4\r\n4 5</pre>\r\n<h4>\r\n\tExample 2</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\ndata = [[&#39;Alex&#39;,10],[&#39;Bob&#39;,12],[&#39;Clarke&#39;,1<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>3]]\r\ndf = pd.DataFrame(data,columns=[&#39;Name&#39;,&#39;Age&#39;])\r\nprint df</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;  Name    Age\r\n0   Alex    10<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n1   Bob     12\r\n2   Clarke  13</pre>\r\n<h4>\r\n\tExample 3</h4>\r\n<pre>\r\n<code class=\"python\"><span _fck_bookmark=\"1\" style=\"display: none;\"> </span>import pandas as pd\r\ndata = [[&#39;Alex&#39;,10],[&#39;Bob&#39;,12],[&#39;Clarke&#39;,13]]\r\ndf = pd.DataFrame(data,columns=[&#39;Name&#39;,&#39;Age&#39;],dtype=float)\r\nprint df<span _fck_bookmark=\"1\" style=\"display: none;\"> </span></code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt; Name   Age\r\n0  Alex   10.0<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n1  Bob    12.0\r\n2  Clarke 13.0</pre>\r\n<p>\r\n\tNote &minus; Observe, the dtype parameter changes the type of Age column to floating point.</p>\r\n<h4>\r\n\tCreate a DataFrame from Dict of ndarrays / Lists</h4>\r\n<p>\r\n\tAll the ndarrays must be of same length. If index is passed, then the length of the index should equal to the length of the arrays.</p>\r\n<p>\r\n\tIf no index is passed, then by default, index will be <code class=\"python\">range(n)</code>, where n is the array length.</p>\r\n<h4>\r\n\tExample 1</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\ndata = {&#39;Name&#39;:[&#39;Tom&#39;, &#39;Jack&#39;, &#39;Steve&#39;, &#39;Ricky&#39;],&#39;Age&#39;:[28,34,29,42]}\r\ndf = pd.DataFrame(data<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>)\r\nprint df</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;Age Name\r\n0 28  Tom<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n1 34  Jack\r\n2 29  Steve\r\n3 42  Ricky</pre>\r\n<p>\r\n\tNote &minus; Observe the values 0,1,2,3. They are the default index assigned to each using the function range(n).</p>\r\n<h4>\r\n\tExample 2</h4>\r\n<p>\r\n\tLet us now create an indexed DataFrame using arrays.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\ndata = {&#39;Name&#39;:[&#39;Tom&#39;, &#39;Jack&#39;, &#39;Steve&#39;, &#39;Ricky&#39;],&#39;Age&#39;:[28,34,29,42]}\r\ndf = pd.DataFrame(data, index=[&#39;rank1&#39;,&#39;rank2&#39;,&#39;rank3&#39;,&#39;rank4&#39;])\r\nprint df</code><span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;.   Age Name\r\nrank1 28  Tom<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nrank2 34  Jack\r\nrank3 29  Steve\r\nrank4 42  Ricky</pre>\r\n<p>\r\n\tNote &minus; Observe, the index parameter assigns an index to each row.</p>\r\n<h4>\r\n\tCreate a DataFrame from List of Dicts</h4>\r\n<p>\r\n\tList of Dictionaries can be passed as input data to create a DataFrame. The dictionary keys are by default taken as column names.</p>\r\n<h4>\r\n\tExample 1</h4>\r\n<p>\r\n\tThe following example shows how to create a DataFrame by passing a list of dictionaries.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\ndata = [{&#39;a&#39;: 1, &#39;b&#39;: 2},{&#39;a&#39;: 5, &#39;b&#39;: 10, &#39;c&#39;: 20}]\r\ndf = pd.DataFrame(data)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint df</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt; a b  c\r\n0  1 2  NaN<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n1  5 10 20.0</pre>\r\n<p>\r\n\tNote &minus; Observe, NaN (Not a Number) is appended in missing areas.</p>\r\n<h4>\r\n\tExample 2</h4>\r\n<p>\r\n\tThe following example shows how to create a DataFrame by passing a list of dictionaries and the row indices.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\ndata = [{&#39;a&#39;: 1, &#39;b&#39;: 2},{&#39;a&#39;: 5, &#39;b&#39;: 10, &#39;c&#39;: 20}]\r\ndf = pd.DataFrame(data, index=[&#39;first&#39;, &#39;second&#39;])\r\nprint df</code><span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;     a  b   c\r\nfirst  1  2   NaN<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nsecond 5  10  20.0</pre>\r\n<h4>\r\n\tExample 3</h4>\r\n<p>\r\n\tThe following example shows how to create a DataFrame with a list of dictionaries, row indices, and column indices.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\ndata = [{&#39;a&#39;: 1, &#39;b&#39;: 2},{&#39;a&#39;: 5, &#39;b&#39;: 10, &#39;c&#39;: 20}]\r\n\r\n#With two colu<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>mn indices, values same as dictionary keys\r\ndf1 = pd.DataFrame(data, index=[&#39;first&#39;, &#39;second&#39;], columns=[&#39;a&#39;, &#39;b&#39;])\r\n#With two column indices with one index with other name\r\ndf2 = pd.DataFrame(data, index=[&#39;first&#39;, &#39;second&#39;], columns=[&#39;a&#39;, &#39;b1&#39;])\r\nprint df1\r\nprint df2</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#df1 output\r\n       a b<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nfirst  1 2\r\nsecond 5 10\r\n\r\n#df2 output\r\n       a b1\r\nfirst  1 NaN\r\nsecond 5 NaN</pre>\r\n<p>\r\n\tNote &minus; Observe, df2 DataFrame is created with a column index other than the dictionary key; thus, appended the NaN&rsquo;s in place. Whereas, df1 is created with column indices same as dictionary keys, so NaN&rsquo;s appended.</p>\r\n<h4>\r\n\tCreate a DataFrame from Dict of Series</h4>\r\n<p>\r\n\tDictionary of Series can be passed to form a DataFrame. The resultant index is the union of all the series indexes passed.</p>\r\n<h4>\r\n\tExample</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nd = {&#39;one&#39; : pd.Series([1, 2, 3], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]),\r\n      &#39;two&#39; : pd.Series([1, 2, 3, 4], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])}\r\ndf = pd.DataFrame(d)\r\nprint df</code><span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;one two<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\na 1.0  1\r\nb 2.0  2\r\nc 3.0  3\r\nd NaN  4</pre>\r\n<p>\r\n\tNote &minus; Observe, for the series one, there is no label &lsquo;d&rsquo; passed, but in the result, for the d label, NaN is appended with NaN.</p>\r\n<p>\r\n\tLet us now understand column selection, addition, and deletion through examples.</p>\r\n<h3>\r\n\tColumn Selection</h3>\r\n<p>\r\n\tWe will understand this by selecting a column from the DataFrame.</p>\r\n<h4>\r\n\tExample</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nd = {&#39;one&#39; : pd.Series([1, 2, 3], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]),\r\n      &#39;two&#39; : pd.Series([1, 2, 3, 4], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])}\r\ndf = pd.DataFrame(d)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint df [&#39;one&#39;]</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\na 1.0<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nb 2.0\r\nc 3.0\r\nd NaN\r\nName: one, dtype: float64</pre>\r\n<h3>\r\n\tColumn Addition</h3>\r\n<p>\r\n\tWe will understand this by adding a new column to an existing data frame.</p>\r\n<h4>\r\n\tExample</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nd = {&#39;one&#39; : pd.Series([1, 2, 3], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]),\r\n      &#39;two&#39; : pd.Series([1, 2, 3, 4], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])}\r\ndf = pd.DataFrame(d)\r\n# Adding a new column to an existing DataFrame object with column label by passing new series\r\nprint (&quot;Adding a new column by passing as Series:&quot;)\r\ndf[&#39;three&#39;]=pd.Series([10,20,30],index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])\r\nprint df\r\nprint (&quot;Adding a new column using the existing columns in DataFrame:&quot;)\r\ndf[&#39;four&#39;]=df[&#39;one&#39;]+df[&#39;three&#39;]\r\nprint df</code><span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\nAdding a new column by passing as Series:\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>  one two three\r\na 1.0  1  10.0\r\nb 2.0  2  20.0<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nc 3.0  3  30.0\r\nd NaN  4  NaN\r\n\r\nAdding a new column using the existing columns in DataFrame:\r\n  one two three four\r\na 1.0  1  10.0  11.0\r\nb 2.0  2  20.0  22.0\r\nc 3.0  3  30.0  33.0<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nd NaN  4  NaN   NaN</pre>\r\n<h3>\r\n\tColumn Deletion</h3>\r\n<p>\r\n\tColumns can be deleted or popped; let us take an example to understand how.</p>\r\n<h4>\r\n\tExample</h4>\r\n<pre>\r\n<code class=\"python\"># Using the previous DataFrame, we will delete a column\r\n# using del function\r\nimport pandas as pd\r\nd = {&#39;one&#39; : pd.Series([1, 2, 3], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]),\r\n&#39;two&#39; : pd.Series([1, 2, 3, 4], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]),\r\n&#39;three&#39; : pd.Series([10,20,30], index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])}\r\ndf = pd.DataFrame(d)\r\nprint (&quot;Our dataframe is:&quot;)\r\nprint df\r\n# using del function\r\nprint (&quot;Deleting the first column using DEL function:&quot;)\r\ndel df[&#39;one&#39;]\r\nprint df\r\n# using pop function\r\nprint (&quot;Deleting anoth<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>er column using POP function:&quot;)\r\ndf.pop(&#39;two&#39;)\r\nprint df\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\nOur dataframe is:\r\n  one three two<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\na 1.0 10.0   1\r\nb 2.0 20.0   2\r\nc 3.0 30.0   3\r\nd NaN NaN    4\r\nDeleting the first column using DEL function:\r\n three two\r\na 10.0  1\r\nb 20.0  2\r\nc 30.0  3\r\nd NaN   4\r\nDeleting another column using POP function:\r\n  three\r\na 10.0\r\nb 20.0\r\nc 30.0\r\nd NaN\r\n</pre>\r\n<h3>\r\n\tRow Selection, Addition, and Deletion</h3>\r\n<p>\r\n\tWe will now understand row selection, addition and deletion through examples. Let us begin with the concept of selection.</p>\r\n<h4>\r\n\tSelection by Label</h4>\r\n<p>\r\n\tRows can be selected by passing row label to a loc function.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nd = {&#39;one&#39; : pd.Series([1, 2, 3], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]),\r\n&#39;two&#39; : pd.Series([1, 2, 3, 4], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])}\r\ndf = pd.DataFrame(d)\r\nprint df.loc[&#39;b&#39;]<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\none 2.0\r\ntwo 2.0<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nName: b, dtype: float64\r\n</pre>\r\n<p>\r\n\tThe result is a series with labels as column names of the DataFrame. And, the Name of the series is the label with which it is retrieved.</p>\r\n<h4>\r\n\tSelection by integer location</h4>\r\n<p>\r\n\tRows can be selected by passing integer location to an iloc function.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nd = {&#39;one&#39; : pd.Series([1, 2, 3], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]),\r\n&#39;two&#39; : pd.Series([1, 2, 3, 4], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])}\r\ndf = pd.DataFrame(d)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint df.iloc[2]\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\none 3.0\r\ntwo 3.0\r\nName: c, dtype: float64<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h3>\r\n\tSlice Rows</h3>\r\n<p>\r\n\tMultiple rows can be selected using &lsquo; : &rsquo; operator.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nd = {&#39;one&#39; : pd.Series([1, 2, 3], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]),\r\n&#39;two&#39; : pd.Series([1, 2, 3, 4], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])}\r\ndf = pd.DataFrame(d)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint df[2:4]\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;one two\r\nc 3.0  3<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nd NaN  4\r\n</pre>\r\n<h4>\r\n\tAddition of Rows</h4>\r\n<p>\r\n\tAdd new rows to a DataFrame using the append function. This function will append the rows at the end.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\ndf = pd.DataFrame([[1, 2], [3, 4]], columns = [&#39;a&#39;,&#39;b&#39;])\r\ndf2 = pd.DataFrame([[5, 6], [7, 8]], columns = [&#39;a&#39;,&#39;b&#39;])\r\ndf = df.append(df2)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint df\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;a b\r\n0 1 2<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n1 3 4\r\n0 5 6\r\n1 7 8\r\n</pre>\r\n<h4>\r\n\tDeletion of Rows</h4>\r\n<p>\r\n\tUse index label to delete or drop rows from a DataFrame. If label is duplicated, then multiple rows will be dropped.</p>\r\n<p>\r\n\tIf you observe, in the above example, the labels are duplicate. Let us drop a label and will see how many rows will get dropped.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\ndf = pd.DataFrame([[1, 2], [3, 4]], columns = [&#39;a&#39;,&#39;b&#39;])\r\ndf2 = pd.DataFrame([[5, 6], [7, 8]], columns = [&#39;a&#39;,&#39;b&#39;])\r\ndf = df.append(df2)\r\n# Drop rows with label 0\r\ndf = df.drop(0)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint df\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;a b<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n1 3 4\r\n1 7 8\r\n</pre>\r\n<p>\r\n\tIn the above example, two rows were dropped because those two contain the same label 0.&nbsp;</p>\r\n<h2>\r\n\tPython Pandas - Panel</h2>\r\n<p>\r\n\tA panel is a 3D container of data. The term Panel data is derived from econometrics and is partially responsible for the name pandas &minus; pan(el)-da(ta)-s.<br />\r\n\tThe names for the 3 axes are intended to give some semantic meaning to describing operations involving panel data. They are</p>\r\n<ul>\r\n\t<li>\r\n\t\titems &minus; axis 0, each item corresponds to a DataFrame contained inside.</li>\r\n\t<li>\r\n\t\tmajor_axis &minus; axis 1, it is the index (rows) of each of the DataFrames.</li>\r\n\t<li>\r\n\t\tminor_axis &minus; axis 2, it is the columns of each of the DataFrames.</li>\r\n</ul>\r\n<h3>\r\n\t<code class=\"python\">pandas.Panel()</code></h3>\r\n<p>\r\n\tA Panel can be created using the following constructor</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\">pandas.Panel(data, items, major_axis, minor_axis, dtype, copy)\r\n</code></pre>\r\n<p>\r\n\tThe parameters of the constructor are as follows</p>\r\n<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width: 500px\">\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tParameter</th>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tDescription</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tdata</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tData takes various forms like ndarray, series, map, lists, dict, constants and also another DataFrame</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\titems</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\taxis=0</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tmajor_axis</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\taxis=1</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tminor_axis</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\taxis=2</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tdtype</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tData type of each column</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tcopy</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tCopy data. Default, false</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n<h3>\r\n\tCreate Panel</h3>\r\n<p>\r\n\tA Panel can be created using multiple ways like</p>\r\n<ul>\r\n\t<li>\r\n\t\tFrom ndarrays</li>\r\n\t<li>\r\n\t\tFrom dict of DataFrames&nbsp;</li>\r\n</ul>\r\n<h4>\r\n\tFrom 3D ndarray</h4>\r\n<pre>\r\n<code class=\"python\"># creating an empty panel\r\nimport pandas as pd\r\nimport numpy as np\r\ndata = np.random.rand(2,4,5)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\np = pd.Panel(data)\r\nprint p</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n&lt;class &#39;pandas.core.panel.Panel&#39;&gt;\r\nDimensions: 2 (items) x 4 (major_axis) x 5 (minor_axis)\r\nItems axis: 0 to 1\r\nMajor_axis axis: 0 to 3\r\nMinor_axis axis: 0 to 4<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<p>\r\n\tNote &minus; Observe the dimensions of the empty panel and the above panel, all the objects are different.</p>\r\n<h4>\r\n\tFrom dict of DataFrame Objects</h4>\r\n<pre>\r\n<code class=\"python\">#creating an empty panel\r\nimport pandas as pd\r\nimport numpy as np\r\ndata = {&#39;Item1&#39; : pd.DataFrame(np.random.randn(4, 3)),\r\n&#39;Item2&#39; : pd.DataFrame(np.random.randn(4, 2))}\r\np = pd.Panel(data)\r\nprint p<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows</p>\r\n<pre>\r\n&lt;class &#39;pandas.core.panel.Panel&#39;&gt;\r\nDimensions: 2 (items) x 4 (major_axis) x 5 (minor_axis)\r\nItems axis: 0 to 1\r\nMajor_axis axis: 0 to 3\r\nMinor_axis axis: 0 to 4<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tCreate an Empty Panel</h4>\r\n<pre>\r\n<code class=\"python\">An empty panel can be created using the Panel constructor as follows\r\n#creating an empty panel\r\nimport pandas as pd\r\np = pd.Panel()\r\nprint p<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows</p>\r\n<pre>\r\n&lt;class &#39;pandas.core.panel.Panel&#39;&gt;\r\nDimensions: 0 (items) x 0 (major_axis) x 0 (minor_axis)\r\nItems axis: None\r\nMajor_axis axis: None\r\nMinor_axis axis: None <span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<h3>\r\n\tSelecting the Data from Panel</h3>\r\n<p>\r\n\tSelect the data from the panel using</p>\r\n<ul>\r\n\t<li>\r\n\t\tItems</li>\r\n\t<li>\r\n\t\tMajor_axis</li>\r\n\t<li>\r\n\t\tMinor_axis</li>\r\n</ul>\r\n<h4>\r\n\tUsing Items</h4>\r\n<pre>\r\n<code class=\"python\"># creating an empty panel\r\nimport pandas as pd\r\nimport numpy as np\r\ndata = {&#39;Item1&#39; : pd.DataFrame(np.random.randn(4, 3)),\r\n&#39;Item2&#39; : pd.DataFrame(np.random.randn(4, 2))}\r\np = pd.Panel(data)\r\nprint p[&#39;Item1&#39;]<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows</p>\r\n<pre>\r\n#&gt; 0         1        2\r\n0  0.488224 -0.128637 0.930817<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n1  0.417497  0.896681 0.576657\r\n2 -2.775266  0.571668 0.290082\r\n3 -0.400538 -0.144234 1.110535\r\n</pre>\r\n<p>\r\n\tWe have two items, and we retrieved item1. The result is a DataFrame with 4 rows and 3 columns, which are the Major_axis and Minor_axis dimensions.&nbsp;</p>\r\n<h4>\r\n\tUsing major_axis</h4>\r\n<p>\r\n\tData can be accessed using the method panel.major_axis(index).</p>\r\n<pre>\r\n<code class=\"python\"># creating an empty panel\r\nimport pandas as pd\r\nimport numpy as np\r\ndata = {&#39;Item1&#39; : pd.DataFrame(np.random.randn(4, 3)),\r\n&#39;Item2&#39; : pd.DataFrame(np.random.randn(4, 2))}\r\np = pd.Panel(data)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint p.major_xs(1)\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows</p>\r\n<pre>\r\n#&gt;   Item1      Item2\r\n0  0.417497   0.748412<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n1  0.896681  -0.557322\r\n2  0.576657   NaN</pre>\r\n<h4>\r\n\tUsing minor_axis</h4>\r\n<p>\r\n\tData can be accessed using the method panel.minor_axis(index).</p>\r\n<pre>\r\n<code class=\"python\"># creating an empty panel\r\nimport pandas as pd\r\nimport numpy as np\r\ndata = {&#39;Item1&#39; : pd.DataFrame(np.random.randn(4, 3)),\r\n&#39;Item2&#39; : pd.DataFrame(np.random.randn(4, 2))}\r\np = pd.Panel(data)\r\nprint p.minor_xs(1)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows</p>\r\n<pre>\r\n#&gt;Item1            Item2\r\n0 -0.128637    -1.047032<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n1  0.896681    -0.557322\r\n2  0.571668     0.431953\r\n3 -0.144234     1.302466\r\n</pre>\r\n<p>\r\n\tNote &minus; Observe the changes in the dimensions.&nbsp;</p>\r\n<h2>\r\n\tPython Pandas - Basic Functionality</h2>\r\n<p>\r\n\tBy now, we learnt about the three Pandas DataStructures and how to create them. We will majorly focus on the DataFrame objects because of its importance in the real time data processing and also discuss a few other DataStructures.</p>\r\n<h3>\r\n\tSeries Basic Functionality</h3>\r\n<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width: 500px\">\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tAtribute or Method</th>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tDescription</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\taxes</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReturns a list of the row axis labels.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tdtype</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReturns the dtype of the object.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tempty</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReturns True if series is empty.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tndim</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReturns the number of dimensions of the underlying data, by definition 1.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tsize</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReturns the number of elements in the underlying data.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tvalues</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReturns the Series as ndarray.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\thead()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReturns the first n rows.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\ttail()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReturns the last n rows.</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n<p>\r\n\tLet us now create a Series and see all the above tabulated attributes operation.</p>\r\n<h4>\r\n\tExample</h4>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\">import pandas as pd\r\nimport numpy as np\r\n\r\n#Create a series with 100 random numbers\r\ns = pd.S<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>e<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>ries(np.random.randn(4))\r\nprint s</code>\r\n</pre>\r\n<p>\r\n\t<span _fck_bookmark=\"1\" style=\"display: none;\">&nbsp;</span>Its output is as follows&nbsp;</p>\r\n<pre>\r\n0    0.967853\r\n1   -0.148368\r\n2   -1.395906\r\n3   -1.758394\r\ndtype: float64<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\taxes</h4>\r\n<p>\r\n\tReturns the list of the labels of the series.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nimport numpy as np\r\n\r\n#Create a series with 100 random numbers\r\ns = pd.Series(np.random.randn(4))\r\nprint (&quot;The axes are:&quot;)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint s.axes\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\nThe axes are:<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n[RangeIndex(start=0, stop=4, step=1)]\r\n</pre>\r\n<p>\r\n\tThe above result is a compact format of a list of values from 0 to 5, i.e., [0,1,2,3,4].</p>\r\n<h4>\r\n\tempty</h4>\r\n<p>\r\n\tReturns the Boolean value saying whether the Object is empty or not. True indicates that the object is empty.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\n#Create a series with 100 random numbers\r\ns = pd.Series(np.random.randn(4))\r\nprint (&quot;Is the Object empty?&quot;)\r\nprint s.empty<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\nIs the Object empty?\r\nFalse<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tndim</h4>\r\n<p>\r\n\tReturns the number of dimensions of the object. By definition, a Series is a 1D data structure, so it returns</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\">import pandas as pd\r\nimport numpy as np\r\n\r\n#Create a series with 4 random numbers\r\ns = pd.Series(np.rando<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>m.randn(4))\r\nprint s\r\n\r\nprint (&quot;The dimensions of the object:&quot;)\r\nprint s.ndim<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0  0.175898\r\n1  0.166197\r\n2 -0.609712<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n3 -1.377000\r\ndtype: float64\r\n\r\nThe dimensions of the object:\r\n1<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tsize</h4>\r\n<p>\r\n\tReturns the size(length) of the series.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\n#Create a series with 4 random numbers\r\ns = pd.Series(np.random.randn(2))\r\nprint s\r\nprint (&quot;The siz<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>e of the object:&quot;)\r\nprint s.size\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;<span _fck_bookmark=\"1\" style=\"display: none;\">&nbsp;</span></p>\r\n<pre>\r\n0  3.078058\r\n1 -1.207803\r\ndtype: float64<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\nThe size of the object:\r\n2<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tvalues</h4>\r\n<p>\r\n\tReturns the actual data in the series as an array.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nimport numpy as np\r\n\r\n#Create a series with 4 random numb<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>ers\r\ns = pd.Series(np.random.randn(4))\r\nprint s\r\n\r\nprint (&quot;The actual data series is:&quot;)\r\nprint s.values<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0  1.787373\r\n1 -0.605159\r\n2  0.180477\r\n3 -0.140922<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\ndtype: float64\r\n\r\nThe actual data s<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>eries is:\r\n[ 1.78737302 -0.60515881 0.18047664 -0.1409218 ]\r\n</pre>\r\n<h4>\r\n\tHead &amp; Tail</h4>\r\n<p>\r\n\tTo view a small sample of a Series or the DataFrame object, use the head() and the tail() methods.</p>\r\n<p>\r\n\thead() returns the first n rows(observe the index values). The default number of elements to display is five, but you may pass a custom number.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\n#Create a series with 4 random numbers\r\ns = pd.Series(np.random.ran<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>dn(4))\r\nprint (&quot;The original series is:&quot;)\r\nprint s\r\n\r\nprint (&quot;The first two rows of the data series:&quot;)\r\nprint s.head(2)</code>\r\n</pre>\r\n<p>\r\n\t<span _fck_bookmark=\"1\" style=\"display: none;\">&nbsp;</span>Its output is as follows&nbsp;</p>\r\n<pre>\r\nThe original series is:\r\n0  0.720876\r\n1 -0.765898\r\n2  0.479221\r\n3 -0.139547<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\ndtype: float64\r\n\r\nThe first two rows of the data series:\r\n0  0.720876\r\n1 -0.765898\r\ndtype: float64<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<p>\r\n\ttail() returns the last n rows(observe the index values). The default number of elements to display is five, but you may pass a custom number.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nimport numpy as np\r\n\r\n#Create a series with 4 random numbers\r\ns = pd.Series(np.random.randn(4))\r\nprint (&quot;The original series is:&quot;)\r\nprint s<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\nprint (&quot;The last two rows of the data series:&quot;)\r\nprint s.tail(2)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\nThe original series is:\r\n0 -0.655091<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n1 -0.881407\r\n2 -0.608592\r\n3 -2.341413\r\ndtype: float64\r\n\r\nThe last two rows of the data series:\r\n2 -0.608592\r\n3 -2.341413\r\ndtype: float64<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h3>\r\n\tDataFrame Basic Functionality</h3>\r\n<p>\r\n\tLet us now understand what DataFrame Basic Functionality is. The following tables lists down the important attributes or methods that help in DataFrame Basic Functionality.</p>\r\n<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width: 500px\">\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tAtribute or Method</th>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tDescription</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tT</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tTransposes rows and columns.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\taxes&nbsp;</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReturns a list with the row axis labels and column axis labels as the only members.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tdtypes</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReturns the dtypes in this object.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tempty</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tTrue if NDFrame is entirely empty [no items]; if any of the axes are of length 0.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tndim</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tNumber of axes / array dimensions.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tshape</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReturns a tuple representing the dimensionality of the DataFrame.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tsize</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tNumber of elements in the NDFrame.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tvalues</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tNumpy representation of NDFrame.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\thead()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReturns the first n rows.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\ttail()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReturns last n rows.</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n<p>\r\n\tLet us now create a DataFrame and see all how the above mentioned attributes operate.</p>\r\n<h4>\r\n\tExample</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\n#Create a Dictionary of series\r\nd = {&#39;Name&#39;:pd.Series([&#39;Tom&#39;,&#39;James&#39;,&#39;Ricky&#39;,&#39;Vin&#39;,&#39;Steve&#39;,&#39;Smith&#39;,&#39;Jack&#39;]),\r\n   &#39;Age&#39;:pd.Series([25,26,25,23,30,29,23]),\r\n   &#39;Rating&#39;:pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\n#Create a DataFrame\r\ndf = pd.DataFrame(d)\r\nprint (&quot;Our data series is:&quot;)\r\nprint df<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows</p>\r\n<pre>\r\nOur data series is:\r\n  Age Name   Rating\r\n0 25  Tom    4.23\r\n1 26  James  3.24\r\n2 25  Ricky  3.98\r\n3 23  Vin    2.56\r\n4 30  Steve  3.20\r\n5 29  Smith  4.60\r\n6 23  Jack   3.80\r\n</pre>\r\n<h4>\r\n\tT (Transpose)</h4>\r\n<p>\r\n\tReturns the transpose of the DataFrame. The rows and columns will interchange.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\n# Create a Dictionary of series\r\nd = {&#39;Name&#39;:pd.Series([&#39;Tom&#39;,&#39;James&#39;,&#39;Ricky&#39;,&#39;Vin&#39;,&#39;Steve&#39;,&#39;Smith&#39;,&#39;Jack&#39;]),\r\n   &#39;Age&#39;:pd.Series([25,26,25,23,30,29,23]),\r\n   &#39;Rating&#39;:pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}\r\n\r\n# Create a DataFrame\r\ndf = pd.DataFrame(d)\r\nprint (&quot;The transpose of the <span _fck_bookmark=\"1\" style=\"display: none;\"> </span>data series is:&quot;)\r\nprint df.T\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\nThe transpose of the data series is:\r\n       0    1     2     3    4     5     6\r\nAge    25   26    25    23   30    29    23\r\nName   Tom  James Ricky Vin  Steve Smith Jack\r\nRating 4.23 3.24  3.98  2.56 3.2   4.6   3.8<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\taxes</h4>\r\n<p>\r\n\tReturns the list of row axis labels and column axis labels.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\n#Create a Dictionary of series\r\nd = {&#39;Name&#39;:pd.Series([&#39;Tom&#39;,&#39;James&#39;,&#39;Ricky&#39;,&#39;Vin&#39;,&#39;Steve&#39;,&#39;Smith&#39;,&#39;Jack&#39;]),\r\n   &#39;Age&#39;:pd.Series([25,26,25,23,30,29,23]<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>),\r\n   &#39;Rating&#39;:pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}\r\n\r\n#Create a DataFrame\r\ndf = pd.DataFrame(d)\r\nprint (&quot;Row axis l<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>abels and column axis labels are:&quot;)\r\nprint df.axes\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>Row axis labels and column axis labels are:\r\n[RangeIndex(start=0, stop=7, step=1), Index([u&#39;Age&#39;, u&#39;Name&#39;, u&#39;Rating&#39;],\r\ndtype=&#39;object&#39;)]<span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<h4>\r\n\tdtypes</h4>\r\n<p>\r\n\tReturns the data type of each column.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\n#Create a Dictionary of series\r\nd = {&#39;Name&#39;:pd.Series([&#39;Tom&#39;,&#39;James&#39;,&#39;Ricky&#39;,&#39;Vin&#39;,&#39;Steve&#39;,&#39;Smith&#39;,&#39;Jack&#39;]),\r\n   &#39;Age&#39;:pd.Series([25,26,25,23,30,29,23]),\r\n   &#39;Rating&#39;:pd.Series([4.23,3.24,3.98<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>,2.56,3.20,4.6,3.8])}\r\n\r\n#Create a DataFrame\r\ndf = pd.DataFrame(d)\r\nprint (&quot;The data types of each column are:&quot;)\r\nprint df.dtyp<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>es\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\nThe data types of each column are:\r\nAge int64\r\nName object<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nRating float64\r\ndtype: object\r\n</pre>\r\n<p>\r\n\tempty</p>\r\n<p>\r\n\tReturns the Boolean value saying whether the Object is empty or not; True indicates that the object is empty.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy <span _fck_bookmark=\"1\" style=\"display: none;\"> </span>as np\r\n\r\n#Create a Dictionary of series\r\nd = {&#39;Name&#39;:pd.Series([&#39;Tom&#39;,&#39;James&#39;,&#39;Ricky&#39;,&#39;Vin&#39;,&#39;Steve&#39;,&#39;Smith&#39;,&#39;Jack&#39;]),\r\n   &#39;Age&#39;:pd.Series([25,26,25,23,30,29,23]),\r\n   &#39;Rating&#39;:pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}\r\n\r\n#Create a DataFrame\r\ndf = pd.DataFrame(d)\r\nprint (&quot;Is the object empty?&quot;)\r\nprint df.empty\r\n\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;<span _fck_bookmark=\"1\" style=\"display: none;\">&nbsp;</span></p>\r\n<pre>\r\nIs the object empty?\r\nFalse<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tndim</h4>\r\n<p>\r\n\tReturns the number of dimensions of the object. By definition, DataFrame is a 2D object.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\n#Create a Dictionary of series\r\nd = {&#39;Name&#39;:pd.Series([&#39;Tom&#39;,&#39;James&#39;,<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>&#39;Ricky&#39;,&#39;Vin&#39;,&#39;Steve&#39;,&#39;Smith&#39;,&#39;Jack&#39;]),\r\n   &#39;Age&#39;:pd.Series([25,26,25,23,30,29,23]),\r\n   &#39;Rating&#39;:pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}\r\n\r\n#Create a DataFrame\r\ndf = pd.DataFrame(d)\r\nprint (&quot;Our object is:<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>&quot;)\r\nprint df\r\nprint (&quot;The dimension of the object is:&quot;)\r\nprint df.ndim\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\nOur object is:\r\n      Age Name   Rating\r\n0    25   Tom     4.23\r\n1    26   James   3.24\r\n2    25   Ricky   3.98<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n3    23   Vin     2.56\r\n4    30   Steve   3.20\r\n5    29   Smith   4.60\r\n6    23   Jack    3.80\r\n\r\nThe<span _fck_bookmark=\"1\" style=\"display: none;\"> </span> dimension of the object is:\r\n2\r\n</pre>\r\n<h4>\r\n\tshape</h4>\r\n<p>\r\n\tReturns a tuple representing the dimensionality of the DataFrame. Tuple (a,b), where a represents the number of rows and b represents the number of columns.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np\r\n\r\n#Create a Dictionary of series\r\nd = {&#39;Name&#39;:pd.Series([&#39;Tom&#39;,&#39;James&#39;,&#39;Ricky&#39;,&#39;Vin&#39;,&#39;Steve&#39;,&#39;Smith&#39;,&#39;Jack&#39;]),\r\n   &#39;Age&#39;:pd.Series([25,26,25,23,30,29,23]),\r\n   &#39;Rating&#39;:pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}\r\n\r\n#Create a DataFrame\r\ndf = pd.DataFrame(d)\r\nprint (&quot;Our object is:&quot;)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint df\r\nprint (&quot;The shape of the object is:&quot;)\r\nprint df.shape\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\nOur object is:<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n  Age Name   Rating\r\n0 25  Tom    4.23\r\n1 26  James  3.24\r\n2 25  Ricky  3.98\r\n3 23  Vin    2.56\r\n4 30  Steve  3.20\r\n5 29  Smith  4.60\r\n6 23  Jack   3.80\r\n\r\nThe shape of the object is:\r\n(7, 3)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tsize</h4>\r\n<p>\r\n\tReturns the number of elements in the DataFrame.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np\r\n\r\n#Create a Dictionary of series\r\nd = {&#39;Name&#39;:pd.Series([&#39;Tom&#39;,&#39;James&#39;,&#39;Ricky&#39;,&#39;Vin&#39;,&#39;Steve&#39;,&#39;Smith&#39;,&#39;Jack&#39;]),\r\n   &#39;Age&#39;:pd.Series([25,26,25,23,30,29,23]),\r\n   &#39;Rating&#39;:pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n#Create a DataFrame\r\ndf = pd.DataFrame(d)\r\nprint (&quot;Our object is:&quot;)\r\nprint df\r\nprint (&quot;The total number of elements in our object is:&quot;)\r\nprint df.size\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\nOur object is:\r\n  Age Name   Rating\r\n0 25  Tom    4.23\r\n1 26  James  3.24\r\n2 25  Ricky  3.98\r\n3 23  Vin    2.56\r\n4 30  Steve  3.20\r\n5 29  Smith  4.60\r\n6 23  Jack   3.80\r\n\r\nThe total number of elements in our object is: 21    </pre>\r\n<h4>\r\n\tvalues</h4>\r\n<p>\r\n\tReturns the actual data in the DataFrame as an NDarray.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np\r\n\r\n#Create a Dictionary of series\r\nd = {&#39;Name&#39;:pd.Series([&#39;Tom&#39;,&#39;James&#39;,&#39;Ricky&#39;,&#39;Vin&#39;,&#39;Steve&#39;,&#39;Smith&#39;,&#39;Jack&#39;]),\r\n   &#39;Age&#39;:pd.Series([25,26,25,23,30,29,23]),\r\n   &#39;Rating&#39;:pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}\r\n\r\n#Create a DataFrame\r\ndf = pd.DataFrame(d)\r\nprint (&quot;Our object is:&quot;)\r\nprint df<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint (&quot;The actual data in our data frame is:&quot;)\r\nprint df.values\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\nOur object is:\r\n  Age Name   Rating\r\n0 25  Tom    4.23\r\n1 26  James  3.24\r\n2 25  Ricky  3.98\r\n3 23  Vin    2.56\r\n4 30  Steve  3.20\r\n5 29  Smith  4.60\r\n6 23  Jack   3.80\r\n\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>The actual data in our data frame <span _fck_bookmark=\"1\" style=\"display: none;\"> </span>is: \r\n[ [25 &#39;Tom&#39; 4.23] \r\n  [26 &#39;James&#39; 3.24] \r\n  [25 &#39;Ricky&#39; 3.98]\r\n  [23 &#39;Vin&#39; 2.56]\r\n  [30 &#39;Steve&#39; 3.2]\r\n  [29 &#39;Smith&#39; 4.6]\r\n  [23 &#39;Jack&#39; 3.8] ]</pre>\r\n<h4>\r\n\tHead &amp; Tail</h4>\r\n<p>\r\n\tTo view a small sample of a DataFrame object, use the head() and tail() methods. head() returns the first n rows (observe the index values). The default number of elements to display is five, but you may pass a custom number.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np\r\n\r\n#Create a Dictionary of series\r\nd = {&#39;Name&#39;:pd.Series([&#39;Tom&#39;,&#39;James&#39;,&#39;Ricky&#39;,&#39;Vin&#39;,&#39;Steve&#39;,&#39;Smith&#39;,&#39;Jack&#39;]),\r\n   &#39;Age&#39;:pd.Series([25,26,25,23,30,29,23]),\r\n   &#39;Rating&#39;:pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\n#Create a DataFrame<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\ndf = pd.DataFrame(d)\r\nprint (&quot;Our data frame is:&quot;)\r\nprint df\r\nprint (&quot;The first two rows of the data frame is:&quot;)\r\nprint df.head(2)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\nOur object is:\r\n  Age Name   Rating\r\n0 25  Tom    4.23\r\n1 26  James  3.24\r\n2 25  Ricky  3.98\r\n3 23  Vin    2.56\r\n4 30  Steve  3.20\r\n5 29  Smith  4.60\r\n6 23  Jack   3.80\r\n\r\nThe first two rows of the data frame is:\r\n  Age Name  Rating \r\n0 25  Tom   4.23 \r\n1 26  James 3.24</pre>\r\n<p>\r\n\ttail() returns the last n rows (observe the index values). The default number of elements to display is five, but you may pass a custom number.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nimport numpy as np\r\n\r\n#Create a Dictionary of series<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nd = {&#39;Name&#39;:pd.Series([&#39;Tom&#39;,&#39;James&#39;,&#39;Ricky&#39;,&#39;Vin&#39;,&#39;Steve&#39;,&#39;Smith&#39;,&#39;Jack&#39;]),\r\n   &#39;Age&#39;:pd.Series([25,26,25,23,30,29,23]),\r\n&#39;Rating&#39;:pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}\r\n\r\n#Create a DataFrame\r\ndf = pd.DataFrame(d)\r\nprint (&quot;Our data frame is:&quot;)\r\nprint df\r\nprint (&quot;The last two rows of the data frame is:&quot;)\r\nprint df.tail(2)</code>\r\n</pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\nOur object is:\r\n  Age Name   Rating\r\n0 25  Tom    4.23\r\n1 26  James  3.24\r\n2 25  Ricky  3.98\r\n3 23  Vin    2.56\r\n4 30  Steve  3.20\r\n5 29  Smith  4.60\r\n6 23  Jack   3.80\r\n\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>The last two rows of the data frame is:\r\n   Age Name  Rating\r\n 5 29  Smith 4.6<span _fck_bookmark=\"1\" style=\"display: none;\"> </span> \r\n 6 23  Jack  3.8\r\n</pre>"
          }
        },
        {
          "NumPy Tutorial": {
            "content": "<p>\r\n\tNumpy is the most basic and a powerful package for working with data in python. If you are going to work on data analysis or machine learning projects, then having a solid understanding of numpy is nearly mandatory. Because other packages for data analysis (like pandas) is built on top of numpy and the scikit-learn package which is used to build machine learning applications works heavily with numpy as well.</p>\r\n<p>\r\n\tSo what does numpy provide?</p>\r\n<p>\r\n\tAt the core, numpy provides the excellent ndarray objects, short for n-dimensional arrays. In a &lsquo;ndarray&rsquo; object, aka &lsquo;array&rsquo;, you can store multiple items of the same data type. It is the facilities around the array object that makes numpy so convenient for performing math and data manipulations.</p>\r\n<h2>\r\n\tHow to create a numpy array</h2>\r\n<p>\r\n\tThere are multiple ways to create a numpy array, most of which will be covered as you read this. However one of the most common ways is to create one from a list or a list like an object by passing it to the np.array function.</p>\r\n<h3>\r\n\tCreate an 1d array from a list</h3>\r\n<pre>\r\n<code class=\"python\">import numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nlist1 = [0,1,2,3,4]\r\narr1d = np.array(list1)\r\n# Print the array and its type\r\nprint(type(arr1d))\r\narr1d</code>\r\n\r\n#&gt;class &#39;numpy.ndarray&#39;\r\n#&gt;array([0, 1, 2, 3, 4])</pre>\r\n<p>\r\n\tThe key difference between an array and a list is, arrays are designed to handle vectorized operations while a python list is not.</p>\r\n<p>\r\n\tThat means, if you apply a function it is performed on every item in the array, rather than on the whole array object.</p>\r\n<p>\r\n\tLet&rsquo;s suppose you want to add the number 2 to every item in the list. The intuitive way to do it is something like this:</p>\r\n<pre>\r\n<code class=\"python\">list1 + 2 # error<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tThat was not possible with a list. But you can do that on a ndarray.</p>\r\n<pre>\r\n<code class=\"python\"># Add 2 to each element of arr1d<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\narr1d + 2\r\n</code>#&gt;array([2, 3, 4, 5, 6])</pre>\r\n<p>\r\n\tAnother characteristic is that, once a numpy array is created, you cannot increase its size. To do so, you will have to create a new array. But such a behavior of extending the size is natural in a list.</p>\r\n<p>\r\n\tNevertheless, there are so many more advantages. Let&rsquo;s find out.</p>\r\n<p>\r\n\tSo, that&rsquo;s about 1d array.</p>\r\n<h3>\r\n\t2d array from a list of the lists</h3>\r\n<pre>\r\n<code class=\"python\"># Create a 2d array from a list of lists\r\nlist2 = [ [0,1,2], [3,4,5], [6,7,8] ]<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\narr2d = np.array(list2)\r\narr2d\r\n</code>\r\n#&gt;array([ [0, 1, 2],\r\n#&gt;        [3, 4, 5],\r\n#&gt;        [6, 7, 8] ])</pre>\r\n<p>\r\n\tYou may also specify the datatype by setting the dtype argument. Some of the most commonly used numpy dtypes are: &#39;float&#39;, &#39;int&#39;, &#39;bool&#39;, &#39;str&#39; and &#39;object&#39;.</p>\r\n<p>\r\n\tTo control the memory allocations you may choose to use one of &lsquo;float32&rsquo;, &lsquo;float64&rsquo;, &lsquo;int8&rsquo;, &lsquo;int16&rsquo; or &lsquo;int32&rsquo;.</p>\r\n<pre>\r\n<code class=\"python\"># Create a float 2d array\r\narr2d_f = np.array(list2, dtype=&#39;float&#39;)\r\narr2d_f</code>\r\n\r\n#&gt; array([ [ 0.,  1.,  2.],\r\n#&gt;         [ 3.,  4.,  5.],\r\n#&gt;         [ 6.,  7.,  8.] ])\r\n</pre>\r\n<p>\r\n\tThe decimal point after each number is indicative of the float datatype. You can also convert it to a different datatype using the astype method.</p>\r\n<pre>\r\n<code> # Convert to &#39;int&#39; datatype\r\narr2d_f.astype(&#39;int&#39;)\r\n\r\n</code>#&gt; array([ [0, 1, 2],\r\n#&gt;         [3, 4, 5],\r\n#&gt;         [6, 7, 8] ])</pre>\r\n<p>\r\n\t<span style=\"font-family: Arial, Verdana, sans-serif;\">Convert to int then to str datatype<span _fck_bookmark=\"1\" style=\"display: none;\">&nbsp;</span></span></p>\r\n<pre>\r\n<code>arr2d_f.astype(&#39;int&#39;).astype(&#39;str&#39;)\r\n\r\n</code>#&gt; array([ [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;],\r\n#&gt;         [&#39;3&#39;, &#39;4&#39;, &#39;5&#39;],\r\n#&gt;         [&#39;6&#39;, &#39;7&#39;, &#39;8&#39;] ],dtype=&#39;U21&#39;)<code>\r\n\r\n</code></pre>\r\n<p>\r\n\tA numpy array must have all items to be of the same data type, unlike lists. This is another significant difference.</p>\r\n<p>\r\n\tHowever, if you are uncertain about what datatype your array will hold or if you want to hold characters and numbers in the same array, you can set the dtype as &#39;object&#39;.</p>\r\n<pre>\r\n<code class=\"python\"><span _fck_bookmark=\"1\" style=\"display: none;\"> </span># Create a boolean array\r\narr2d_b = np.array([1, 0, 10], dtype=&#39;bool&#39;)\r\narr2d_b\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span></code><span style=\"font-family: Arial, Verdana, sans-serif;\">\r\n</span>#&gt;array([ True, False, True], dtype=bool)</pre>\r\n<pre>\r\n<code class=\"python\"># Create an object array to hold numbers as well as strings\r\narr1d_obj = np.array([1, &#39;a&#39;], dtype=&#39;object&#39;)\r\narr1d_obj\r\n</code>\r\n#&gt; array([1, &#39;a&#39;], dtype=object)</pre>\r\n<h3>\r\n\tConvert an array back to a python list using tolist().</h3>\r\n<pre>\r\n<code class=\"python\"><span _fck_bookmark=\"1\" style=\"display: none;\"> </span># Convert an array back to a list\r\narr1d_obj.tolist()\r\n\r\n</code>#&gt; [1, &#39;a&#39;]</pre>\r\n<p>\r\n\tTo summarise, the main differences with python lists are:</p>\r\n<ul>\r\n\t<li>\r\n\t\tArrays support vectorised operations, while lists don&rsquo;t.</li>\r\n\t<li>\r\n\t\tOnce an array is created, you cannot change its size. You will have to create a new array or overwrite the existing one.</li>\r\n\t<li>\r\n\t\tEvery array has one and only one dtype. All items in it should be of that dtype.</li>\r\n\t<li>\r\n\t\tAn equivalent numpy array occupies much less space than a python list of lists.</li>\r\n</ul>\r\n<h2>\r\n\tHow to inspect the size and shape of a numpy array</h2>\r\n<p>\r\n\tEvery array has some properties I want to understand in order to know about the array.</p>\r\n<p>\r\n\tLet&rsquo;s consider the array, arr2d. Since it was created from a list of lists, it has 2 dimensions that can be shown as rows and columns, like in a matrix.</p>\r\n<p>\r\n\tHad I created one from a list of list of lists, it would have 3 dimensions, as in a cube. And so on.</p>\r\n<p>\r\n\tLet&rsquo;s suppose you were handed a numpy vector that you didn&rsquo;t create yourself. What are the things you would want to explore in order to know about that array?</p>\r\n<p>\r\n\tWell, I want to know:</p>\r\n<ul>\r\n\t<li>\r\n\t\tIf it is a 1D or a 2D array or more. (ndim)</li>\r\n\t<li>\r\n\t\tHow many items are present in each dimension (shape)</li>\r\n\t<li>\r\n\t\tWhat is its datatype (dtype)</li>\r\n\t<li>\r\n\t\tWhat is the total number of items in it (size)</li>\r\n\t<li>\r\n\t\tSamples of first few items in the array (through indexing)</li>\r\n</ul>\r\n<pre>\r\n<code class=\"python\"># Create a 2d array with 3 rows and 4 columns\r\nlist2 = [ [1, 2, 3, 4],[3, 4, 5, 6], [5, 6, 7, 8] ]\r\narr2 = np.array(list2, dtype=&#39;float&#39;)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\narr2</code>\r\n\r\n#&gt; array([ [ 1.,  2.,  3.,  4.],\r\n#&gt;         [ 3.,  4.,  5.,  6.],\r\n#&gt;         [ 5.,  6.,  7.,  8.] ])</pre>\r\n<pre>\r\n<code class=\"python\"># dtype\r\nprint(&#39;Datatype: &#39;, arr2.dtype)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\n# size\r\nprint(&#39;Size: &#39;, arr2.size)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\n# ndim\r\nprint(&#39;Num Dimensions: &#39;, arr2.ndim)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\n</code><code class=\"python\">#&gt; Shape:  (3, 4)\r\n#&gt; Datatype:  float64\r\n#&gt; Size:  12\r\n#&gt; Num Dimensions:  2\r\n</code><code class=\"python\">\r\n</code></pre>\r\n<h2>\r\n\tHow to extract specific items from an array</h2>\r\n<pre>\r\n<code class=\"python\">arr2</code><span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\n#&gt; array([ [ 1., 2., 3., 4.],\r\n#&gt;         [ 3., 4., 5., 6.],<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n#&gt;         [ 5., 6., 7., 8.] ])</pre>\r\n<p>\r\n\tYou can extract specific portions on an array using indexing starting with 0, something similar to how you would do with python lists.</p>\r\n<p>\r\n\tBut unlike lists, numpy arrays can optionally accept as many parameters in the square brackets as there is number of dimensions.</p>\r\n<pre>\r\n<code class=\"python\"># Extract the first 2 rows and columns\r\narr2[:2, :2]<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nlist2[:2, :2] # error</code><span _fck_bookmark=\"1\" style=\"display: none;\"> </span><span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\n#&gt; array([ [ 1., 2.],<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n#&gt;         [ 3., 4.] ])</pre>\r\n<p>\r\n\tAdditionally, numpy arrays support boolean indexing.</p>\r\n<p>\r\n\tA boolean index array is of the same shape as the array-to-be-filtered and it contains only True and False values. The values corresponding to True positions are retained in the output.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\"># Get the boolean output by applying the condition to each element.\r\nb = arr2 &gt; 4\r\nb</code>\r\n\r\n#&gt; array([ [False, False, False, False],\r\n#&gt;         [False, False,  True,  True],\r\n#&gt;         [ True,  True,  True,  True] ], dtype=bool)\r\n\r\n</pre>\r\n<pre>\r\n<code class=\"python\">arr2[b]</code>\r\n\r\n#&gt; array([ 5.,  6.,  5.,  6.,  7.,  8.])\r\n\r\n</pre>\r\n<h3>\r\n\t&nbsp;How to reverse the rows and the whole array</h3>\r\n<p>\r\n\tReversing an array works like how you would do with lists, but you need to do for all the axes (dimensions) if you want a complete reversal.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\"># Reverse only the row positions\r\narr2[::-1, ]</code>\r\n\r\n#&gt; array([ [ 5.,  6.,  7.,  8.],\r\n#&gt;         [ 3.,  4.,  5.,  6.],\r\n#&gt;         [ 1.,  2.,  3.,  4.] ])\r\n</pre>\r\n<pre>\r\n<code class=\"python\"># Reverse the row and column positions\r\narr2[::-1, ::-1]</code>\r\n\r\n#&gt; array([ [ 8.,  7.,  6.,  5.],\r\n#&gt;         [ 6.,  5.,  4.,  3.],\r\n#&gt;         [ 4.,  3.,  2.,  1.] ])\r\n\r\n</pre>\r\n<h3>\r\n\tHow to represent missing values and infinite</h3>\r\n<p>\r\n\tMissing values can be represented using np.nan object, while np.inf represents infinite. Let&rsquo;s place some in arr2d.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\"># Insert a nan and an inf\r\narr2[1,1] = np.nan  # not a number\r\narr2[1,2] = np.inf  # infinite\r\narr2</code>\r\n\r\n#&gt; array([ [  1.,   2.,   3.,   4.],\r\n#&gt;         [  3.,  nan,  inf,   6.],\r\n#&gt;         [  5.,   6.,   7.,   8.] ])\r\n</pre>\r\n<pre>\r\n<code class=\"python\"># Replace nan and inf with -1. Don&#39;t use arr2 == np.nan\r\nmissing_bool = np.isnan(arr2) | np.isinf(arr2)\r\narr2[missing_bool] = -1  \r\narr2</code>\r\n\r\n#&gt; array([ [ 1.,  2.,  3.,  4.],\r\n#&gt;         [ 3., -1., -1.,  6.],\r\n#&gt;         [ 5.,  6.,  7.,  8.] ])\r\n\r\n</pre>\r\n<h3>\r\n\tHow to compute mean, min, max on the ndarray</h3>\r\n<p>\r\n\tThe ndarray has the respective methods to compute this for the whole array.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\"># mean, max and min\r\nprint(&quot;Mean value is: &quot;, arr2.mean())\r\nprint(&quot;Max value is: &quot;, arr2.max())\r\nprint(&quot;Min value is: &quot;, arr2.min())</code>\r\n\r\n#&gt; Mean value is:  3.58333333333\r\n#&gt; Max value is:  8.0\r\n#&gt; Min value is:  -1.0\r\n\r\n</pre>\r\n<p>\r\n\tHowever, if you want to compute the minimum values row wise or column wise, use the np.amin version instead.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\"># Row wise and column wise min\r\nprint(&quot;Column wise minimum: &quot;, np.amin(arr2, axis=0))\r\nprint(&quot;Row wise minimum: &quot;, np.amin(arr2, axis=1))</code>\r\n\r\n#&gt; Column wise minimum:  [ 1. -1. -1.  4.]\r\n#&gt; Row wise minimum:  [ 1. -1.  5.]\r\n\r\n</pre>\r\n<p>\r\n\tComputing the minimum row-wise is fine. But what if you want to do some other computation/function row-wise? It can be done using the <code class=\"python\">np.apply_over_axis</code> which you will see in the upcoming topic.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\"># Cumulative Sum\r\nnp.cumsum(arr2)</code>\r\n\r\n#&gt; array([  1.,   3.,   6.,  10.,  13.,  12.,  11.,  17.,  22.,  28.,  35., 43.])\r\n\r\n\r\n</pre>\r\n<h2>\r\n\tHow to create a new array from an existing array<span _fck_bookmark=\"1\" id=\"cke_bm_193S\" style=\"display: none;\">&nbsp;</span></h2>\r\n<p>\r\n\tIf you just assign a portion of an array to another array, the new array you just created actually refers to the parent array in memory.<br />\r\n\tThat means, if you make any changes to the new array, it will reflect in the parent array as well.<br />\r\n\tSo to avoid disturbing the parent array, you need to make a copy of it using copy(). All numpy arrays come with the copy() method.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\"># Assign portion of arr2 to arr2a. Doesn&#39;t really create a new array.\r\narr2a = arr2[:2,:2]  \r\narr2a[:1, :1] = 100  # 100 will reflect in arr2\r\narr2</code>\r\n\r\n#&gt; array([ [ 100.,    2.,    3.,    4.],\r\n#&gt;         [   3.,   -1.,   -1.,    6.],\r\n#&gt;         [   5.,    6.,    7.,    8.] ])\r\n\r\n</pre>\r\n<pre>\r\n<code class=\"python\"># Copy portion of arr2 to arr2b\r\narr2b = arr2[:2, :2].copy()\r\narr2b[:1, :1] = 101  # 101 will not reflect in arr2\r\narr2</code>\r\n\r\n#&gt; array([ [ 100.,    2.,    3.,    4.],\r\n#&gt;         [   3.,   -1.,   -1.,    6.],\r\n#&gt;         [   5.,    6.,    7.,    8.] ])\r\n\r\n</pre>\r\n<h2>\r\n\tReshaping and Flattening Multidimensional arrays</h2>\r\n<p>\r\n\tReshaping is changing the arrangement of items so that shape of the array changes while maintaining the same number of dimensions.<br />\r\n\tFlattening, however, will convert a multi-dimensional array to a flat 1d array. And not any other shape.<br />\r\n\tFirst, let&rsquo;s reshape the arr2 array from 3&times;4 to 4&times;3 shape.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\"># Reshape a 3x4 array to 4x3 array\r\narr2.reshape(4, 3)</code>\r\n\r\n#&gt; array([ [ 100.,    2.,    3.],\r\n#&gt;         [   4.,    3.,   -1.],\r\n#&gt;         [  -1.,    6.,    5.],\r\n#&gt;         [   6.,    7.,    8.] ])\r\n\r\n</pre>\r\n<h3>\r\n\tWhat is the difference between <code class=\"python\">flatten()</code> and <code class=\"python\">ravel()</code></h3>\r\n<p>\r\n\tThere are 2 popular ways to implement flattening. That is using the flatten() method and the other using the ravel() method.<br />\r\n\tThe difference between ravel and flatten is, the new array created using ravel is actually a reference to the parent array. So, any changes to the new array will affect the parent as well. But is memory efficient since it does not create a copy.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\"># Flatten it to a 1d array\r\narr2.flatten()</code>\r\n\r\n#&gt; array([ 100.,    2.,    3.,    4.,    3.,   -1.,   -1.,    6.,    5., 6.,    7.,    8.])\r\n</pre>\r\n<pre>\r\n<code class=\"python\"># Changing the flattened array does not change parent\r\nb1 = arr2.flatten()  \r\nb1[0] = 100  # changing b1 does not affect arr2\r\narr2</code>\r\n\r\n#&gt; array([ [ 100.,    2.,    3.,    4.],\r\n#&gt;         [   3.,   -1.,   -1.,    6.],\r\n#&gt;         [   5.,    6.,    7.,    8.] ])\r\n\r\n</pre>\r\n<pre>\r\n<code class=\"python\"># Changing the raveled array changes the parent also.\r\nb2 = arr2.ravel()  \r\nb2[0] = 101  # changing b2 changes arr2 also\r\narr2</code>\r\n\r\n#&gt; array([ [ 101.,    2.,    3.,    4.],\r\n#&gt;         [   3.,   -1.,   -1.,    6.],\r\n#&gt;         [   5.,    6.,    7.,    8.] ])\r\n\r\n</pre>\r\n<h2>\r\n\tHow to create sequences, repetitions and random numbers using numpy</h2>\r\n<p>\r\n\tThe np.arange function comes handy to create customised number sequences as ndarray.</p>\r\n<pre>\r\n<code class=\"python\"> # Lower limit is 0 be default\r\nprint(np.arange(5))  \r\n\r\n# 0 to 9\r\nprint(np.arange(0, 10))  \r\n\r\n# 0 to 9 with step of 2\r\nprint(np.arange(0, 10, 2))  \r\n\r\n# 10 to 1, decreasing order\r\nprint(np.arange(10, 0, -1))</code>\r\n\r\n#&gt; [0 1 2 3 4]\r\n#&gt; [0 1 2 3 4 5 6 7 8 9]\r\n#&gt; [0 2 4 6 8]\r\n#&gt; [10  9  8  7  6  5  4  3  2  1]\r\n\r\n</pre>\r\n<p>\r\n\tYou can set the starting and end positions using np.arange. But if you are focussed on the number of items in the array you will have to manually calculate the appropriate step value.<br />\r\n\tSay, you want to create an array of exactly 10 numbers between 1 and 50, Can you compute what would be the step value?<br />\r\n\tWell, I am going to use the np.linspace instead.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\"># Start at 1 and end at 50\r\nnp.linspace(start=1, stop=50, num=10, dtype=int)</code>\r\n\r\n#&gt; array([ 1,  6, 11, 17, 22, 28, 33, 39, 44, 50])\r\n\r\n</pre>\r\n<p>\r\n\tNotice since I explicitly forced the dtype to be int, the numbers are not equally spaced because of the rounding.<br />\r\n\tSimilar to np.linspace, there is also np.logspace which rises in a logarithmic scale. In np.logspace, the given start value is actually base^start and ends with base^stop, with a default based value of 10.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\"># Limit the number of digits after the decimal to 2\r\nnp.set_printoptions(precision=2)  \r\n\r\n# Start at 10^1 and end at 10^50\r\nnp.logspace(start=1, stop=50, num=10, base=10)</code> \r\n\r\n#&gt; array([  1.00e+01,   2.78e+06,   7.74e+11,   2.15e+17,   5.99e+22,\r\n#&gt;          1.67e+28,   4.64e+33,   1.29e+39,   3.59e+44,   1.00e+50])\r\n\r\n</pre>\r\n<p>\r\n\tThe np.zeros and np.ones functions lets you create arrays of desired shape where all the items are either 0&rsquo;s or 1&rsquo;s.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\">np.zeros([2,2])</code>\r\n\r\n#&gt; array([ [ 0.,  0.],\r\n#&gt;         [ 0.,  0.] ])\r\n\r\n\r\n</pre>\r\n<pre>\r\n<code class=\"python\">np.ones([2,2])</code>\r\n\r\n#&gt; array([ [ 1.,  1.],\r\n#&gt;         [ 1.,  1.] ])\r\n\r\n</pre>\r\n<h3>\r\n\tHow to create repeating sequences</h3>\r\n<p>\r\n\tnp.tile will repeat a whole list or array n times. Whereas, np.repeat repeats each item n times.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\">a = [1,2,3] \r\n\r\n# Repeat whole of &#39;a&#39; two times\r\nprint(&#39;Tile:   &#39;, np.tile(a, 2))\r\n\r\n# Repeat each element of &#39;a&#39; two times\r\nprint(&#39;Repeat: &#39;, np.repeat(a, 2))</code>\r\n\r\n#&gt; Tile:    [1 2 3 1 2 3]\r\n#&gt; Repeat:  [1 1 2 2 3 3]\r\n\r\n</pre>\r\n<h3>\r\n\tHow to generate random numbers</h3>\r\n<p>\r\n\tThe random module provides nice functions to generate random numbers (and also statistical distributions) of any given shape.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\"># Random numbers between [0,1) of shape 2,2\r\nprint(np.random.rand(2,2))\r\n\r\n# Normal distribution with mean=0 and variance=1 of shape 2,2\r\nprint(np.random.randn(2,2))\r\n\r\n# Random integers between [0, 10) of shape 2,2\r\nprint(np.random.randint(0, 10, size=[2,2]))\r\n\r\n# One random number between [0,1)\r\nprint(np.random.random())\r\n\r\n# Random numbers between [0,1) of shape 2,2\r\nprint(np.random.random(size=[2,2]))\r\n\r\n# Pick 10 items from a given list, with equal probability\r\nprint(np.random.choice([&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;], size=10))  \r\n\r\n# Pick 10 items from a given list with a predefined probability &#39;p&#39;\r\nprint(np.random.choice([&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;], size=10, p=[0.3, .1, 0.1, 0.4, 0.1]))  # picks more o&#39;s</code>\r\n\r\n#&gt; [ [ 0.84  0.7 ]\r\n#&gt;   [ 0.52  0.8 ] ]\r\n\r\n#&gt; [ [-0.06 -1.55]\r\n#&gt;   [ 0.47 -0.04] ]\r\n\r\n#&gt; [ [4 0]\r\n#&gt;   [8 7] ]\r\n\r\n#&gt; 0.08737272424956832\r\n\r\n#&gt; [ [ 0.45  0.78]\r\n#&gt;   [ 0.03  0.74] ]\r\n\r\n#&gt; [&#39;i&#39; &#39;a&#39; &#39;e&#39; &#39;e&#39; &#39;a&#39; &#39;u&#39; &#39;o&#39; &#39;e&#39; &#39;i&#39; &#39;u&#39;]\r\n#&gt; [&#39;o&#39; &#39;a&#39; &#39;e&#39; &#39;a&#39; &#39;a&#39; &#39;o&#39; &#39;o&#39; &#39;o&#39; &#39;a&#39; &#39;o&#39;]\r\n\r\n</pre>\r\n<p>\r\n\tNow, everytime you run any of the above functions, you get a different set of random numbers.<br />\r\n\tIf you want to repeat the same set of random numbers every time, you need to set the seed or the random state. The see can be any value. The only requirement is you must set the seed to the same value every time you want to generate the same set of random numbers.<br />\r\n\tOnce np.random.RandomState is created, all the functions of the np.random module becomes available to the created randomstate object.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\"># Create the random state\r\nrn = np.random.RandomState(100)\r\n\r\n# Create random numbers between [0,1) of shape 2,2\r\nprint(rn.rand(2,2))</code>\r\n\r\n#&gt; [ [ 0.54  0.28]\r\n#&gt;   [ 0.42  0.84] ]\r\n</pre>\r\n<pre>\r\n<code class=\"python\"># Set the random seed\r\nnp.random.seed(100)\r\n\r\n# Create random numbers between [0,1) of shape 2,2\r\nprint(np.random.rand(2,2))</code>\r\n\r\n#&gt; [ [ 0.54  0.28]\r\n#&gt;   [ 0.42  0.84] ]\r\n\r\n</pre>\r\n<h3>\r\n\tHow to get the unique items and the counts</h3>\r\n<p>\r\n\tThe np.unique method can be used to get the unique items. If you want the repetition counts of each item, set the return_counts parameter to True.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\"># Create random integers of size 10 between [0,10)\r\nnp.random.seed(100)\r\narr_rand = np.random.randint(0, 10, size=10)\r\nprint(arr_rand)</code>\r\n\r\n#&gt; [8 8 3 7 7 0 4 2 5 2]\r\n</pre>\r\n<pre>\r\n<code class=\"python\"># Get the unique items and their counts\r\nuniqs, counts = np.unique(arr_rand, return_counts=True)\r\nprint(&quot;Unique items : &quot;, uniqs)\r\nprint(&quot;Counts       : &quot;, counts)\r\n</code>\r\n#&gt; Unique items :  [0 2 3 4 5 7 8]\r\n#&gt; Counts       :  [1 2 1 1 1 2 2]</pre>"
          }
        },
        {
          "SciPy Tutorial": {
            "content": "<p>\r\n\tSciPy, pronounced as Sigh Pi, is a scientific python open source, distributed under the BSD licensed library to perform Mathematical, Scientific and Engineering Computations.</p>\r\n<p>\r\n\tThe SciPy library depends on NumPy, which provides convenient and fast N-dimensional array manipulation. The SciPy library is built to work with NumPy arrays and provides many user-friendly and efficient numerical practices such as routines for numerical integration and optimization. Together, they run on all popular operating systems, are quick to install and are free of charge. NumPy and SciPy are easy to use, but powerful enough to depend on by some of the world&#39;s leading scientists and engineers.</p>\r\n<h2>\r\n\tBasic Functionality</h2>\r\n<p>\r\n\tBy default, all the NumPy functions have been available through the SciPy namespace. There is no need to import the NumPy functions explicitly, when SciPy is imported. The main object of NumPy is the homogeneous multidimensional array. It is a table of elements (usually numbers), all of the same type, indexed by a tuple of positive integers. In NumPy, dimensions are called as axes. The number of axes is called as rank.</p>\r\n<p>\r\n\tNow, let us revise the basic functionality of Vectors and Matrices in NumPy. As SciPy is built on top of NumPy arrays, understanding of NumPy basics is necessary. As most parts of linear algebra deals with matrices only.</p>\r\n<h3>\r\n\tNumPy Vector</h3>\r\n<p>\r\n\tA Vector can be created in multiple ways. Some of them are described below.</p>\r\n<p>\r\n\tConverting Python array-like objects to NumPy<br />\r\n\tLet us consider the following example.</p>\r\n<pre>\r\n<code class=\"python\">import numpy as np\r\nlist = [1,2,3,4]\r\narr = np.array(list)\r\nprint arr</code><span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<p>\r\n\tThe output of the above program will be as follows.</p>\r\n<pre>\r\n[1 2 3 4]<span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<h3>\r\n\tIntrinsic NumPy Array Creation</h3>\r\n<p>\r\n\tNumPy has built-in functions for creating arrays from scratch. Some of these functions are explained below.</p>\r\n<h4>\r\n\tUsing <code class=\"python\">zeros()</code></h4>\r\n<p>\r\n\tThe zeros(shape) function will create an array filled with 0 values with the specified shape. The default dtype is float64. Let us consider the following example.</p>\r\n<pre>\r\n<code class=\"python\">import numpy as np\r\nprint np.zeros((2, 3))<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tThe output of the above program will be as follows.</p>\r\n<pre>\r\narray([ [ 0., 0., 0.]<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>,\r\n[ 0., 0., 0.] ])\r\n</pre>\r\n<h4>\r\n\tUsing <code class=\"python\">ones()</code></h4>\r\n<p>\r\n\tThe ones(shape) function will create an array filled with 1 values. It is identical to zeros in all the other respects. Let us consider the following example.</p>\r\n<pre>\r\n<code class=\"python\">import numpy as np\r\nprint np.ones((2, 3))<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tThe output of the above program will be as follows.</p>\r\n<pre>\r\narray([ [ 1., 1., 1.],\r\n[ 1., 1., 1.] ])<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tUsing <code class=\"python\">arange()</code></h4>\r\n<p>\r\n\tThe arange() function will create arrays with regularly incrementing values. Let us consider the following example.</p>\r\n<pre>\r\n<code class=\"python\">import numpy as np\r\nprint np.arange(7)</code><span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<p>\r\n\tThe above program will generate the following output.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>array([0, 1, 2, 3, 4, 5, 6])<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tDefining the data type of the values</h4>\r\n<p>\r\n\tLet us consider the following example.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\">import numpy as np\r\narr = np.arange(2, 10, dtype = np.float)\r\nprint arr\r\nprint &quot;Array Data Type :&quot;,arr.dtype<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tThe above program will generate the following output.</p>\r\n<pre>\r\n[ 2. 3. 4. 5. 6. 7. 8. 9.]\r\nArray Data Type : float64<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tUsing linspace()</h4>\r\n<p>\r\n\tThe linspace() function will create arrays with a specified number of elements, which will be spaced equally between the specified beginning and end values. Let us consider the following example.</p>\r\n<pre>\r\n<code class=\"python\">import numpy as np\r\nprint np.linspace(1., 4., 6)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tThe above program will generate the following output.</p>\r\n<pre>\r\narray([ 1. , 1.6, 2.2, 2.8, 3.4, 4. ])<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tMatrix</h4>\r\n<p>\r\n\tA matrix is a specialized 2-D array that retains its 2-D nature through operations. It has certain special operators, such as * (matrix multiplication) and ** (matrix power). Let us consider the following example.</p>\r\n<pre>\r\n<code class=\"python\">import numpy as np\r\nprint np.matrix(&#39;1 2; 3 4&#39;)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tThe above program will generate the following output.</p>\r\n<pre>\r\nmatrix([ [1, 2],\r\n[3, 4] <span _fck_bookmark=\"1\" style=\"display: none;\"> </span>])\r\n</pre>\r\n<h4>\r\n\tConjugate Transpose of Matrix</h4>\r\n<p>\r\n\tThis feature returns the (complex) conjugate transpose of self. Let us consider the following example.</p>\r\n<pre>\r\n<code class=\"python\"><code class=\"ruby\">import numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nmat = np.matrix(&#39;1 2; 3 4&#39;)\r\nprint mat.H\r\n</code></code></pre>\r\n<p>\r\n\tThe above program will generate the following output.</p>\r\n<pre>\r\nmatrix([ [1, 3],\r\n        [2, 4] ])<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tTranspose of Matrix</h4>\r\n<p>\r\n\tThis feature returns the transpose of self. Let us consider the following example.</p>\r\n<pre>\r\n<code class=\"python\">import numpy as np\r\nmat = np.matrix(&#39;1 2; 3 4&#39;)\r\nmat.T</code><span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<p>\r\n\tThe above program will generate the following output.</p>\r\n<pre>\r\nmatrix([ [1, 3],\r\n        [2, 4] <span _fck_bookmark=\"1\" style=\"display: none;\"> </span>])</pre>\r\n<p>\r\n\tWhen we transpose a matrix, we make a new matrix whose rows are the columns of the original. A conjugate transposition, on the other hand, interchanges the row and the column index for each matrix element. The inverse of a matrix is a matrix that, if multiplied with the original matrix, results in an identity matrix.</p>\r\n<h2>\r\n\tCluster</h2>\r\n<p>\r\n\tK-means clustering is a method for finding clusters and cluster centers in a set of unlabelled data. Intuitively, we might think of a cluster as &ndash; comprising of a group of data points, whose inter-point distances are small compared with the distances to points outside of the cluster. Given an initial set of K centers, the K-means algorithm iterates the following two steps &minus;</p>\r\n<ul>\r\n\t<li>\r\n\t\tFor each center, the subset of training points (its cluster) that is closer to it is identified than any other center.</li>\r\n\t<li>\r\n\t\tThe mean of each feature for the data points in each cluster are computed, and this mean vector becomes the new center for that cluster.</li>\r\n</ul>\r\n<p>\r\n\tThese two steps are iterated until the centers no longer move or the assignments no longer change. Then, a new point x can be assigned to the cluster of the closest prototype. The SciPy library provides a good implementation of the K-Means algorithm through the cluster package. Let us understand how to use it.</p>\r\n<h3>\r\n\tK-Means Implementation</h3>\r\n<p>\r\n\tWe will understand how to implement K-Means in SciPy.</p>\r\n<h4>\r\n\tImport K-Means</h4>\r\n<p>\r\n\tWe will see the implementation and usage of each imported function.</p>\r\n<pre>\r\n<code class=\"python\">from SciPy.cluster.vq import kmeans,vq,whiten<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<h4>\r\n\tData generation</h4>\r\n<p>\r\n\tWe have to simulate some data to explore the clustering.</p>\r\n<pre>\r\n<code class=\"python\">from numpy import vstack,array<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nfrom numpy.random import rand\r\n<span style=\"font-family: Arial, Verdana, sans-serif;\"># data generation with three features\r\n</span><span style=\"font-family: Arial, Verdana, sans-serif;\">data = vstack((rand(100,3) + array</span><span style=\"font-family: Arial, Verdana, sans-serif;\">([.5,.5,.5]),rand(100,3))\r\n</span>\r\n</code></pre>\r\n<p>\r\n\t<span style=\"font-family: Arial, Verdana, sans-serif;\">N<span _fck_bookmark=\"1\" style=\"display: none;\">&nbsp;</span>ow, we have to check for data. The above program will generate the following output.</span></p>\r\n<pre>\r\narray([ [ 1.48598868e+00, 8.17445796e-01, 1.00834051e+00],\r\n       [ 8.45299768e-01, 1.35450732e+00, 8.66323621e-01],\r\n       [ 1.27725864e+00, 1.00622682e+<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>00, 8.43735610e-01],\r\n       &hellip;&hellip;&hellip;&hellip;&hellip;.\r\n</pre>\r\n<p>\r\n\tNormalize a group of observations on a per feature basis. Before running K-Means, it is beneficial to rescale each feature dimension of the observation set with whitening. Each feature is divided by its standard deviation across all observations to give it unit variance.</p>\r\n<h4>\r\n\tWhiten the data</h4>\r\n<p>\r\n\tWe have to use the following code to whiten the data.</p>\r\n<pre>\r\n<code class=\"python\"># whitening of data\r\ndata = whiten(data)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<h4>\r\n\tCompute K-Means with Three Clusters</h4>\r\n<p>\r\n\tLet us now compute K-Means with three clusters using the following code.</p>\r\n<pre>\r\n<code class=\"python\"># computing K-Means with K = 3 (2 clusters)\r\ncentroids,_ = kmeans(data,3)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tThe above code performs K-Means on a set of observation vectors forming K clusters. The K-Means algorithm adjusts the centroids until sufficient progress cannot be made, i.e. the change in distortion, since the last iteration is less than some threshold. Here, we can observe the centroid of the cluster by printing the centroids variable using the code given below.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\">print(centroids)\r\n</code></pre>\r\n<p>\r\n\tThe above code will generate the following output.</p>\r\n<pre>\r\nprint(centroids)[ [ 2.26034702 1.43924335 1.3697022 ]<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n                  [ 2.63788572 2.81446462 2.85163854]\r\n                  [ 0.73507256 1.30801855 1.44477558] ]\r\n</pre>\r\n<p>\r\n\tAssign each value to a cluster by using the code given below.</p>\r\n<pre>\r\n<code class=\"python\"># assign each sample to a cluster<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nclx,_ = vq(data,centroids)\r\n</code></pre>\r\n<p>\r\n\tThe vq function compares each observation vector in the &lsquo;M&rsquo; by &lsquo;N&rsquo; obs array with the centroids and assigns the observation to the closest cluster. It returns the cluster of each observation and the distortion. We can check the distortion as well. Let us check the cluster of each observation using the following code.</p>\r\n<pre>\r\n<code class=\"python\"># check clusters of observation\r\nprint (clx)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tThe above code will generate the following output.</p>\r\n<pre>\r\narray([1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 2, 0, 2, 0, 1, 1, 1,\r\n0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0,\r\n0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,\r\n0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 0, 2, 2, 2, 2, 2, 0, 0,<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n2, 2, 2, 1, 0, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\r\n2, 2, 0, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\r\n2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], dtype=int32)\r\n</pre>\r\n<p>\r\n\tThe distinct values 0, 1, 2 of the above array indicate the clusters.</p>\r\n<h2>\r\n\tConstants</h2>\r\n<p>\r\n\tSciPy constants package provides a wide range of constants, which are used in the general scientific area.</p>\r\n<h3>\r\n\tSciPy Constants Package</h3>\r\n<p>\r\n\tThe scipy.constants package provides various constants. We have to import the required constant and use them as per the requirement. Let us see how these constant variables are imported and used.</p>\r\n<p>\r\n\tTo start with, let us compare the &lsquo;pi&rsquo; value by considering the following example.</p>\r\n<pre>\r\n<code class=\"python\"><code>#Import pi constant from both the packages\r\nfrom scipy.constants import pi\r\nfrom math import pi\r\n</code>print(&quot;sciPy - pi = %.16f&quot;%scipy.constants.pi)\r\nprint(&quot;math - pi = %.16f&quot;%math.pi)</code></pre>\r\n<p>\r\n\tThe above program will generate the following output.</p>\r\n<pre>\r\nsciPy - pi = 3.1415926535897931\r\nmath - pi = 3.1415926535897931 <span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<p>\r\n\tThe easy way to get which key is for which function is with the scipy.constants.find() method. Let us consider the following example.</p>\r\n<pre>\r\n<code class=\"python\">import scipy.constants\r\nres = scipy.constants.physical_constants[&quot;alpha particle mass&quot;]\r\nprint res</code><span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<p>\r\n\tThe above program will generate the following output.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>[\r\n   &#39;alpha particle mass&#39;,\r\n   &#39;alpha particle mass energy equivalent&#39;,\r\n   &#39;alpha particle mass energy equivalent in MeV&#39;,\r\n   &#39;alpha particle mass in u&#39;,\r\n   &#39;electron to alpha particle mass ratio&#39;\r\n]\r\n</pre>\r\n<p>\r\n\t<span _fck_bookmark=\"1\" style=\"display: none;\">&nbsp;</span>The list of keys, else nothing if the keyword does not match.</p>\r\n<h2>\r\n\tIntegrate</h2>\r\n<p>\r\n\tWhen a function cannot be integrated analytically, or is very difficult to integrate analytically, one generally turns to numerical integration methods. SciPy has a number of routines for performing numerical integration. Most of them are found in the same scipy.integrate library.</p>\r\n<h3>\r\n\tSingle Integrals</h3>\r\n<p>\r\n\tThe Quad function is the workhorse of SciPy&rsquo;s integration functions. Numerical integration is sometimes called quadrature, hence the name. It is normally the default choice for performing single integrals of a function f(x) over a given fixed range from a to b.</p>\r\n<p>\r\n\tThe general form of quad is scipy.integrate.quad(f, a, b), Where &lsquo;f&rsquo; is the name of the function to be integrated. Whereas, &lsquo;a&rsquo; and &lsquo;b&rsquo; are the lower and upper limits, respectively. Let us see an example of the Gaussian function, integrated over a range of 0 and 1.</p>\r\n<p>\r\n\tWe first need to define the function &rarr; f(x)=e&minus;x^2, this can be done using a lambda expression and then call the quad method on that function.</p>\r\n<pre>\r\n<code class=\"python\">import scipy.integrate\r\nfrom numpy import exp<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nf= lambda x:exp(-x**2)\r\ni = scipy.integrate.quad(f, 0, 1)\r\nprint i</code></pre>\r\n<p>\r\n\tThe above program will generate the following output.</p>\r\n<pre>\r\n(0.7468241328124271, 8.291413475940725e-15)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span></pre>\r\n<p>\r\n\tThe quad function returns the two values, in which the first number is the value of integral and the second value is the estimate of the absolute error in the value of integral.</p>\r\n<blockquote>\r\n\t<p>\r\n\t\tNote &minus; Since quad requires the function as the first argument, we cannot directly pass exp as the argument. The Quad function accepts positive and negative infinity as limits. The Quad function can integrate standard predefined NumPy functions of a single variable, such as exp, sin and cos.</p>\r\n</blockquote>\r\n<h3>\r\n\tMultiple Integrals</h3>\r\n<p>\r\n\tThe mechanics for double and triple integration have been wrapped up into the functions dblquad, tplquad and nquad. These functions integrate four or six arguments, respectively. The limits of all inner integrals need to be defined as functions.</p>\r\n<h3>\r\n\tDouble Integrals</h3>\r\n<p>\r\n\tThe general form of dblquad is scipy.integrate.dblquad(func, a, b, gfun, hfun). Where, func is the name of the function to be integrated, &lsquo;a&rsquo; and &lsquo;b&rsquo; are the lower and upper limits of the x variable, respectively, while gfun and hfun are the names of the functions that define the lower and upper limits of the y variable.</p>\r\n<p>\r\n\tWe define the functions f, g, and h, using the lambda expressions. Note that even if g and h are constants, as they may be in many cases, they must be defined as functions, as we have done here for the lower limit.</p>\r\n<pre>\r\n<code class=\"python\">import scipy.integrate\r\nfrom numpy import exp\r\nfrom math import sqrt\r\nf = lambda x, y : 16*x*y\r\ng = lambda x : 0\r\nh = lambda y : sqrt(1-4*y**2)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\ni = scipy.integrate.dblquad(f, 0, 0.5, g, h)\r\nprint i</code></pre>\r\n<p>\r\n\tThe above program will generate the following output.</p>\r\n<pre>\r\n(0.5, 1.70923500125<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>94845e-14)</pre>\r\n<p>\r\n\tIn addition to the routines described above, scipy.integrate has a number of other integration routines, including nquad, which performs n-fold multiple integration, as well as other routines that implement various integration algorithms. However, quad and dblquad will meet most of our needs for numerical integration.</p>"
          }
        },
        {
          "Pandas Tutorial part II": {
            "content": "<h2>\r\n\tPython Pandas - Descriptive Statistics</h2>\r\n<p>\r\n\tA large number of methods collectively compute descriptive statistics and other related operations on DataFrame. Most of these are aggregations like sum(), mean(), but some of them, like sumsum(), produce an object of the same size. Generally speaking, these methods take an axis argument, just like ndarray.{sum, std, ...}, but the axis can be specified by name or integer</p>\r\n<ul>\r\n\t<li>\r\n\t\tDataFrame &minus; &ldquo;index&rdquo; (axis=0, default), &ldquo;columns&rdquo; (axis=1)</li>\r\n</ul>\r\n<p>\r\n\tLet us create a DataFrame and use this object throughout this chapter for all the operations.</p>\r\n<h4>\r\n\tExample</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\n#Create a Dictionary of series\r\nd = {&#39;Name&#39;:pd.Series([&#39;Tom&#39;,&#39;James&#39;,&#39;Ricky&#39;,&#39;Vin&#39;,&#39;Steve&#39;,&#39;Smith&#39;,&#39;Jack&#39;,\r\n   &#39;Lee&#39;,&#39;David&#39;,&#39;Gasper&#39;,&#39;Betina&#39;,&#39;Andres&#39;]),\r\n   &#39;Age&#39;:pd.Series([25,26,25,23,30,29,23,34,40,30,51,46]),\r\n   &#39;Rating&#39;:pd.Series([4.23,3.24,3.98<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])}\r\n\r\n#Create a DataFrame\r\ndf = pd.DataFrame(d)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint df\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt; Age Name   Rating\r\n0  25  Tom    4.23\r\n1  26  James  3.24<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n2  25  Ricky  3.98\r\n3  23  Vin    2.56\r\n4  30  Steve  3.20\r\n5  29  Smith  4.60\r\n6  23  Jack   3.80\r\n7  34  Lee    3.78\r\n8  40  David  2.98\r\n9  30  Gasper 4.80\r\n10 51  Betina 4.10\r\n11 46  Andres 3.65\r\n</pre>\r\n<h4>\r\n\t<span _fck_bookmark=\"1\" style=\"display: none;\">&nbsp;</span>sum()</h4>\r\n<p>\r\n\tReturns the sum of the values for the requested axis. By default, axis is index (axis=0).</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np\r\n\r\n#Create a Dictionary of series<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nd = {&#39;Name&#39;:pd.Series([&#39;Tom&#39;,&#39;James&#39;,&#39;Ricky&#39;,&#39;Vin&#39;,&#39;Steve&#39;,&#39;Smith&#39;,&#39;Jack&#39;,\r\n   &#39;Lee&#39;,&#39;David&#39;,&#39;Gasper&#39;,&#39;Betina&#39;,&#39;Andres&#39;]),\r\n   &#39;Age&#39;:pd.Series([25,26,25,23,30,29,23,34,40,30,51,46]),\r\n   &#39;Rating&#39;:pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])}\r\n\r\n#Create a DataFrame\r\ndf = pd.DataFrame(d)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint df.sum()\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\nAge 382\r\nName TomJamesRickyVin<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>SteveSmithJackLeeDavidGasperBe...\r\nRating 44.92\r\ndtype: object\r\n</pre>\r\n<p>\r\n\tEach individual column is added individually (Strings are appended).</p>\r\n<h4>\r\n\taxis=1</h4>\r\n<p>\r\n\tThis syntax will give the output as shown below.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np\r\n\r\n#Create a Dictionary of series\r\nd = {&#39;Name&#39;:pd.Series([&#39;Tom&#39;,&#39;James&#39;,&#39;Ricky&#39;,&#39;Vin&#39;,&#39;Steve&#39;,&#39;Smith&#39;,&#39;Jack&#39;,\r\n   &#39;Lee&#39;,&#39;David&#39;,&#39;Gasper&#39;,&#39;Betina&#39;,&#39;Andres&#39;]),\r\n   &#39;Age&#39;:pd.Series([25,26,25,23,30,29,23,34,40,30,51,46]),\r\n   &#39;Rating&#39;:pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])}\r\n\r\n#Create a DataFrame\r\ndf = pd.DataFrame(d)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint df.sum(1)\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0  29.23\r\n1  29.24\r\n2  28.98\r\n3  25.56\r\n4  33.20<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n5  33.60\r\n6  26.80\r\n7  37.78\r\n8  42.98\r\n9  34.80\r\n10 55.10\r\n11 49.65\r\ndtype: float64\r\n\r\n</pre>\r\n<h4>\r\n\tmean()</h4>\r\n<p>\r\n\tRe<span _fck_bookmark=\"1\" style=\"display: none;\">&nbsp;</span>turns the average value</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\n#Create a Dictionary of series\r\nd = {&#39;Name&#39;:pd.Series([&#39;Tom&#39;,&#39;James&#39;,&#39;Ricky&#39;,&#39;Vin&#39;,&#39;<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>Steve&#39;,&#39;Smith&#39;,&#39;Jack&#39;,\r\n   &#39;Lee&#39;,&#39;David&#39;,&#39;Gasper&#39;,&#39;Betina&#39;,&#39;Andres&#39;]),\r\n   &#39;Age&#39;:pd.Series([25,26,25,23,30,29,23,34,40,30,51,46]),\r\n   &#39;Rating&#39;:pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])}\r\n\r\n#Create a DataFrame\r\ndf = pd.DataFrame(d)\r\nprint df.mean()<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\nAge 31.833333\r\nRating 3.743333\r\ndtype: float64<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tstd()</h4>\r\n<p>\r\n\tReturns the Bressel standard deviation of the numerical columns.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nimport numpy as np\r\n\r\n#Create a Dictionary of series\r\nd = {&#39;Name&#39;:pd.Series([&#39;Tom&#39;,&#39;James&#39;,&#39;Ricky&#39;,&#39;Vin&#39;,&#39;Steve&#39;,&#39;Smith&#39;,&#39;Jack&#39;,\r\n   &#39;Lee&#39;,&#39;David&#39;,&#39;Gasper&#39;,&#39;Betina&#39;,&#39;Andres&#39;]),\r\n   &#39;Age&#39;:pd.Series([25,26,25,23,30,29,23,34,40,30,51,46]),\r\n   &#39;Rating&#39;:pd.Series([4.23,3.24,3<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])}\r\n\r\n#Create a DataFrame\r\ndf = pd.DataFrame(d)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint df.std()\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>Age 9.232682\r\nRating 0.661628\r\ndtype: float64<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h3>\r\n\tFunctions &amp; Description</h3>\r\n<p>\r\n\tLet us now understand the functions under Descriptive Statistics in Python Pandas. The following table list down the important functions &minus;</p>\r\n<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width: 500px\">\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tFunction</th>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tDescription</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tcount()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tNumber of non-null observations</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tsum()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tSum of values</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tmean()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tMean of Values</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tmedian()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tMedian of Values</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tmode()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tMode of values</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tstd()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tStandard Deviation of the Values</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tmin()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tMinimum Value</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tmax()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tMaximum Value</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tabs()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tAbsolute Value</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tprod()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tProduct of Values</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tcumsum()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tCumulative Sum</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&nbsp;cumprod()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tCumulative Product</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n<p>\r\n\tNote &minus; Since DataFrame is a Heterogeneous data structure. Generic operations don&rsquo;t work with all functions. Functions like sum(), cumsum() work with both numeric and character (or) string data elements without any error. Though n practice, character aggregations are never used generally, these functions do not throw any exception. Functions like abs(), cumprod() throw exception when the DataFrame contains character or string data because such operations cannot be performed.</p>\r\n<h3>\r\n\tSummarizing Data</h3>\r\n<p>\r\n\tThe describe() function computes a summary of statistics pertaining to the DataFrame columns.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nimport numpy as np\r\n\r\n#Create a Dictionary of series<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nd = {&#39;Name&#39;:pd.Series([&#39;Tom&#39;,&#39;James&#39;,&#39;Ricky&#39;,&#39;Vin&#39;,&#39;Steve&#39;,&#39;Smith&#39;,&#39;Jack&#39;,\r\n   &#39;Lee&#39;,&#39;David&#39;,&#39;Gasper&#39;,&#39;Betina&#39;,&#39;Andres&#39;]),\r\n   &#39;Age&#39;:pd.Series([25,26,25,23,30,29,23,34,40,30,51,46]),\r\n   &#39;Rating&#39;:pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])}\r\n\r\n#Create a DataFrame\r\ndf = pd.DataFrame(d)\r\nprint df.describe()<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;    Age       Rating<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\ncount 12.000000 12.000000\r\nmean  31.833333 3.743333\r\nstd   9.232682  0.661628\r\nmin   23.000000 2.560000\r\n25%   25.000000 3.230000\r\n50%   29.500000 3.790000\r\n75%   35.500000 4.132500\r\nmax   51.000000 4.800000\r\n\r\n</pre>\r\n<p>\r\n\t<span _fck_bookmark=\"1\" style=\"display: none;\">&nbsp;</span>This function gives the mean, std and IQR values. And, function excludes the character columns and given summary about numeric columns. &#39;include&#39; is the argument which is used to pass necessary information regarding what columns need to be considered for summarizing. Takes the list of values; by default, &#39;number&#39;.</p>\r\n<ul>\r\n\t<li>\r\n\t\tobject &minus; Summarizes String columns</li>\r\n\t<li>\r\n\t\tnumber &minus; Summarizes Numeric columns</li>\r\n\t<li>\r\n\t\tall &minus; Summarizes all columns together (Should not pass it as a list value)</li>\r\n</ul>\r\n<p>\r\n\tNow, use the following statement in the program and check the output&nbsp;</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nimport numpy as np\r\n\r\n#Create a Dictionary of series<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nd = {&#39;Name&#39;:pd.Series([&#39;Tom&#39;,&#39;James&#39;,&#39;Ricky&#39;,&#39;Vin&#39;,&#39;Steve&#39;,&#39;Smith&#39;,&#39;Jack&#39;,\r\n   &#39;Lee&#39;,&#39;David&#39;,&#39;Gasper&#39;,&#39;Betina&#39;,&#39;Andres&#39;]),\r\n   &#39;Age&#39;:pd.Series([25,26,25,23,30,29,23,34,40,30,51,46]),\r\n   &#39;Rating&#39;:pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])}\r\n\r\n#Create a DataFrame\r\ndf = pd.DataFrame(d)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint df.describe(include=[&#39;object&#39;])\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;     Name\r\ncount  12<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nunique 12\r\ntop    Ricky\r\nfreq   1\r\n</pre>\r\n<p>\r\n\tNow, use the following statement and check the output&nbsp;</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\n#Create a Dictionary of series<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nd = {&#39;Name&#39;:pd.Series([&#39;Tom&#39;,&#39;James&#39;,&#39;Ricky&#39;,&#39;Vin&#39;,&#39;Steve&#39;,&#39;Smith&#39;,&#39;Jack&#39;,\r\n   &#39;Lee&#39;,&#39;David&#39;,&#39;Gasper&#39;,&#39;Betina&#39;,&#39;Andres&#39;]),\r\n   &#39;Age&#39;:pd.Series([25,26,25,23,30,29,23,34,40,30,51,46]),\r\n   &#39;Rating&#39;:pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])}\r\n\r\n#Create a DataFrame\r\ndf = pd.DataFrame(d)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint df. describe(include=&#39;all&#39;)\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;     Age       Name  Rating\r\ncount  12.000000 12    12.000000\r\nunique NaN       12    NaN\r\ntop    NaN       Ricky NaN<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nfreq   NaN       1     NaN\r\nmean   31.833333 NaN   3.743333\r\nstd    9.232682  NaN   0.661628\r\nmin    23.000000 NaN   2.560000\r\n25%    25.000000 NaN   3.230000\r\n50%    29.500000 NaN   3.790000\r\n75%    35.500000 NaN   4.132500\r\nmax    51.000000 NaN   4.800000</pre>\r\n<h2>\r\n\tPython Pandas - Reindexing</h2>\r\n<p>\r\n\tReindexing changes the row labels and column labels of a DataFrame. To reindex means to conform the data to match a given set of labels along a particular axis.</p>\r\n<p>\r\n\tMultiple operations can be accomplished through indexing like&nbsp;</p>\r\n<ul>\r\n\t<li>\r\n\t\tReorder the existing data to match a new set of labels.</li>\r\n\t<li>\r\n\t\tInsert missing value (NA) markers in label locations where no data for the label existed.</li>\r\n</ul>\r\n<h4>\r\n\tExample</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\nN=20<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\ndf = pd.DataFrame({<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n   &#39;A&#39;: pd.date_range(start=&#39;2016-01-01&#39;,periods=N,freq=&#39;D&#39;),\r\n   &#39;x&#39;: np.linspace(0,stop=N-1,num=N),\r\n   &#39;y&#39;: np.random.rand(N),\r\n   &#39;C&#39;: np.random.choice([&#39;Low&#39;,&#39;Medium&#39;,&#39;High&#39;],N).tolist(),\r\n   &#39;D&#39;: np.random.normal(100, 10, size=(N)).tolist()\r\n})\r\n\r\n#reindex the DataFrame<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\ndf_reindexed = df.reindex(index=[0,2,5], columns=[&#39;A&#39;, &#39;C&#39;, &#39;B&#39;])\r\n\r\nprint df_reindexed<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;         A   C    B\r\n0 2016-01-0<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>1 Low  NaN\r\n2 2016-01-03 High NaN\r\n5 2016-01-06 Low  NaN\r\n</pre>\r\n<h3>\r\n\t<span _fck_bookmark=\"1\" style=\"display: none;\">&nbsp;</span>Reindex to Align with Other Objects<span _fck_bookmark=\"1\" style=\"display: none;\">&nbsp;</span></h3>\r\n<p>\r\n\t<span _fck_bookmark=\"1\" style=\"display: none;\">&nbsp;</span>You may wish to take an object and reindex its axes to be labeled the same as another object. Consider the following example to understand the same.</p>\r\n<h4>\r\n\tExample</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\ndf1 = pd.DataFrame(np.random.randn<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>(10,3),columns=[&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;])\r\ndf2 = pd.DataFrame(np.random.randn(7,3),columns=[&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;])\r\n\r\ndf1 = df1.reindex_like(df2)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint df1\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;     col1      col2      col3\r\n0 -2.467652 -1.211687 -0.391761\r\n1 -0.287396  0.522350  0.562512\r\n2 -0.255409 -0.483250  1.866258<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n3 -1.150467 -0.646493 -0.222462\r\n4  0.152768 -2.056643  1.877233\r\n5 -1.155997  1.528719 -1.343719\r\n6 -1.015606 -1.245936 -0.295275\r\n</pre>\r\n<p>\r\n\tNote &minus; Here, the df1 DataFrame is altered and reindexed like df2. The column names should be matched or else NAN will be added for the entire column label.</p>\r\n<h3>\r\n\tFilling while ReIndexing</h3>\r\n<p>\r\n\treindex() takes an optional parameter method which is a filling method with values as follows &minus;</p>\r\n<ul>\r\n\t<li>\r\n\t\tpad/ffill &minus; Fill values forward</li>\r\n\t<li>\r\n\t\tbfill/backfill &minus; Fill values backward</li>\r\n\t<li>\r\n\t\tnearest &minus; Fill from the nearest index values</li>\r\n</ul>\r\n<h4>\r\n\tExample</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\ndf1 = pd.DataFrame(np.random.randn(6<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>,3),columns=[&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;])\r\ndf2 = pd.DataFrame(np.random.randn(2,3),columns=[&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;])\r\n\r\n# Padding NAN&#39;s<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint df2.reindex_like(df1)\r\n\r\n# Now Fill the NAN&#39;s with preceding Values\r\nprint (&quot;Data Frame with Forward Fill:&quot;)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint df2.reindex_like(df1,method=&#39;ffill&#39;)\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;     col1      col2     col3<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n0  1.311620 -0.707176 0.599863\r\n1 -0.423455 -0.700265 1.133371\r\n2       NaN       NaN      NaN\r\n3       NaN       NaN      NaN\r\n4       NaN       NaN      NaN\r\n5       NaN       NaN      NaN\r\n\r\nData Frame with Forward Fill:\r\n       col1      col2     col3\r\n0  1.311620 -0.707176 0.599863<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n1 -0.423455 -0.700265 1.133371\r\n2 -0.423455 -0.700265 1.133371\r\n3 -0.423455 -0.700265 1.133371\r\n4 -0.423455 -0.700265 1.133371\r\n5 -0.423455 -0.700265 1.133371\r\n\r\n</pre>\r\n<p>\r\n\tNote &minus; The last four rows are padded.<span _fck_bookmark=\"1\" style=\"display: none;\">&nbsp;</span></p>\r\n<h3>\r\n\tLimits on Filling while Reindexing</h3>\r\n<p>\r\n\tThe limit argument provides additional control over filling while reindexing. Limit specifies the maximum count of consecutive matches. Let us consider the following example to understand the same&nbsp;</p>\r\n<h4>\r\n\tExample</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nimport numpy as np\r\n\r\ndf1 = pd.DataFrame(np.random.randn(6,3),columns=[&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;])\r\ndf2 = pd.DataFrame(np.random.randn(2,3),columns=[&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;])\r\n\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span># Padding NAN&#39;s\r\nprint df2.reindex_like(df1)\r\n\r\n# Now Fill the NAN&#39;s with preceding Values\r\nprint (&quot;Data Frame with Forward Fill limitin<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>g to 1:&quot;)\r\nprint df2.reindex_like(df1,method=&#39;ffill&#39;,limit=1)\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;     col1      col2      col3\r\n0  0.247784  2.128727  0.702576\r\n1 -0.055713 -0.021732 -0.174577\r\n2       NaN       NaN       NaN\r\n3       NaN       NaN       NaN<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n4       NaN       NaN       NaN\r\n5       NaN       NaN       NaN\r\n\r\nData Frame with Forward Fill limiting to 1:\r\n       col1      col2      col3\r\n0  0.247784  2.128727  0.702576\r\n1 -0.055713 -0.021732 -0.174577\r\n2 -0.055713 -0.021732 -0.174577\r\n3       NaN       NaN       NaN<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n4       NaN       NaN       NaN\r\n5       NaN       NaN       NaN\r\n</pre>\r\n<p>\r\n\tNote &minus; Observe, only the 7th row is filled by the preceding 6th row. Then, the rows are left as they are.</p>\r\n<h3>\r\n\tRenaming</h3>\r\n<p>\r\n\tThe rename() method allows you to relabel an axis based on some mapping (a dict or Series) or an arbitrary function.</p>\r\n<p>\r\n\tLet us consider the following example to understand this&nbsp;</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as <span _fck_bookmark=\"1\" style=\"display: none;\"> </span>np\r\n\r\ndf1 = pd.DataFrame(np.ran<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>dom.randn(6,3),columns=[&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;])\r\nprint df1\r\n\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><span _fck_bookmark=\"1\" style=\"display: none;\"> </span>print (&quot;After renaming the rows and columns:&quot;)\r\nprint df1.rename(columns={&#39;col1&#39; : &#39;c1&#39;, &#39;col2&#39; : &#39;c2&#39;},\r\nindex = {0 : &#39;apple&#39;, 1 : &#39;banana&#39;, 2 : &#39;durian&#39;})<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;     col1      col2      col3\r\n0  0.486791  0.105759  1.540122\r\n1 -0.990237  1.007885 -0.217896\r\n2 -0.483855 -1.645027 -1.194113\r\n3 -0.122316  0.566277 -0.366028\r\n4 -0.231524 -0.721172 -0.112007<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n5  0.438810  0.000225  0.435479\r\n\r\nAfter renaming the rows and columns:\r\n              c1        c2      col3\r\napple   0.486791  0.105759  1.540122\r\nbanana -0.990237  1.007885 -0.21<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>7896\r\ndurian -0.483855 -1.645027 -1.194113\r\n3      -0.122316  0.566277 -0.366028\r\n4      -0.231524 -0.721172 -0.112007\r\n5       0.438810  0.000225  0.435479\r\n</pre>\r\n<p>\r\n\tThe rename() method provides an inplace named parameter, which by default is False and copies the underlying data. Pass inplace=True to rename the data in place.</p>\r\n<h2>\r\n\tPython Pandas - Sorting</h2>\r\n<p>\r\n\tThere are two kinds of sorting available in Pandas. They are&nbsp;</p>\r\n<ul>\r\n\t<li>\r\n\t\tBy label</li>\r\n\t<li>\r\n\t\tBy Actual Value</li>\r\n</ul>\r\n<p>\r\n\tLet us consider an example with an output.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\nunsorted_df=pd.DataFrame(np.random.randn(10,2),index=[1,4,6,2,3,5,9,8,0,7],colu\r\nmns=[&#39;col2&#39;,&#39;col1&#39;])\r\nprint unsorted_df<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;     col2      col1\r\n1 -2.063177  0.537527\r\n4  0.142932 -0.684884\r\n6  0.012667 -0.389340\r\n2 -0.548797  1.848743\r\n3 -1.044160  0.837381\r\n5  0.385605  1.300185\r\n9  1.031425 -1.002967\r\n8 -0.407374 -0.435142<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n0  2.237453 -1.067139\r\n7 -1.445831 -1.701035\r\n</pre>\r\n<p>\r\n\tIn unsorted_df, the labels and the values are unsorted. Let us see how these can be sorted.</p>\r\n<h3>\r\n\tBy Label</h3>\r\n<p>\r\n\tUsing the sort_index() method, by passing the axis arguments and the order of sorting, DataFrame can be sorted. By default, sorting is done on row labels in ascending order.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\nunsorted_df = pd.DataFrame(np.random.randn(10,2),index=[1,4,6,2,3,5,9,8,0,7],colu\r\n   mns = [&#39;col2&#39;,&#39;col1&#39;])<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\nsorted_df=unsorted_df.sort_index()<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint sorted_df\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;     col2      col1\r\n0  0.208464  0.627037\r\n1  0.641004  0.331352\r\n2 -0.038067 -0.464730\r\n3 -0.638456 -0.021466\r\n4  0.014646 -0.737438<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n5 -0.290761 -1.669827\r\n6 -0.797303 -0.018737\r\n7  0.525753  1.628921\r\n8 -0.567031  0.775951\r\n9  0.060724 -0.322425\r\n</pre>\r\n<h3>\r\n\tOrder of Sorting<span _fck_bookmark=\"1\" id=\"cke_bm_239S\" style=\"display: none;\">&nbsp;</span></h3>\r\n<p>\r\n\tBy passing the Boolean value to ascending parameter, the order of the sorting can be controlled. Let us consider the following example to understand the same.</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\">import pandas as pd\r\nimport numpy as np\r\n\r\nunsorted_df = pd.DataFrame(np.random.randn(10,2),index=[1,4,6,2,3,5,9,8,0,7],colu\r\n   mns = [&#39;col2&#39;,&#39;col1&#39;])<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\nsorted_df = unsorted_df.sort_index(ascending=False)\r\nprint sorted_df<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;     col2      col1\r\n9  0.825697  0.374463\r\n8 -1.699509  0.510373\r\n7 -0.581378  0.622958\r\n6 -0.202951  0.954300\r\n5 -1.289321 -1.551250\r\n4  1.302561  0.851385\r\n3 -0.157915 -0.388659\r\n2 -1.222295  0.166609<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n1  0.584890 -0.291048\r\n0  0.668444 -0.061294\r\n</pre>\r\n<h3>\r\n\tSort the Columns</h3>\r\n<p>\r\n\tBy passing the axis argument with a value 0 or 1, the sorting can be done on the column labels. By default, axis=0, sort by row. Let us consider the following example to understand the same.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\nunsorted_df = pd.DataFrame(np.random.randn(10,2),index=[1,4,6,2,3,5,9,8,0,7],colu\r\n   mns = [&#39;col2&#39;,&#39;col1&#39;])\r\n\r\nsorted_df=unsorted_df.sort_index(axis=1)\r\n\r\nprint sorted_df<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;     col1      col2\r\n1 -0.291048  0.584890\r\n4  0.851385  1.302561\r\n6  0.954300 -0.202951\r\n2  0.166609 -1.222295\r\n3 -0.388659 -0.157915\r\n5 -1.551250 -1.289321\r\n9  0.374463  0.825697<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n8  0.510373 -1.699509\r\n0 -0.061294  0.668444\r\n7  0.622958 -0.581378\r\n</pre>\r\n<h3>\r\n\tBy Value</h3>\r\n<p>\r\n\tLike index sorting, sort_values() is the method for sorting by values. It accepts a &#39;by&#39; argument which will use the column name of the DataFrame with which the values are to be sorted.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nimport numpy as np\r\n\r\nunsorted_df = pd.DataFrame({&#39;col1&#39;:[2,1,1,1],&#39;col2&#39;:[1,3,2,4]})\r\nsorted_df = unsorted_df.sort_values(by=&#39;col1&#39;)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\nprint sorted_df<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;col1 col2\r\n1    1    3\r\n2    1    2\r\n3    1    4\r\n0    2    1<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<p>\r\n\tObserve, col1 values are sorted and the respective col2 value and row index will alter along with col1. Thus, they look unsorted.</p>\r\n<p>\r\n\t&#39;by&#39; argument takes a list of column values.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nimport numpy as np\r\n\r\nunsorted_df = pd.DataFrame({&#39;col1&#39;:[2,1,1,1],&#39;col2&#39;:[1,3,2,4]})\r\n   sorted_df = unsorted_df.sort_values(by=[&#39;col1&#39;,&#39;col2&#39;])<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\nprint sorted_df<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;col1 col2\r\n2    1    2\r\n1    1    3\r\n3    1    4<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n0    2    1\r\n</pre>\r\n<h3>\r\n\tSorting Algorithm</h3>\r\n<p>\r\n\tsort_values() provides a provision to choose the algorithm from mergesort, heapsort and quicksort. Mergesort is the only stable algorithm.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nimport numpy as np\r\n\r\nunsorted_df = pd.DataFrame({&#39;col1&#39;:[2,1,1,1],&#39;col2&#39;:[1,3,2,4]})\r\nsorted_df = unsorted_df.sort_values(by=&#39;c<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>ol1&#39; ,kind=&#39;mergesort&#39;)\r\n\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>print sorted_df\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;col1 col2\r\n1    1    3\r\n2    1    2<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n3    1    4\r\n0    2    1</pre>\r\n<h2>\r\n\tPython Pandas - Working with Text Data</h2>\r\n<p>\r\n\tIn this chapter, we will discuss the string operations with our basic Series/Index. In the subsequent chapters, we will learn how to apply these string functions on the DataFrame. Pandas provides a set of string functions which make it easy to operate on string data. Most importantly, these functions ignore (or exclude) missing/NaN values. Almost, all of these methods work with Python string functions. So, convert the Series Object to String Object and then perform the operation.</p>\r\n<p>\r\n\tLet us now see how each operation performs.</p>\r\n<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width: 500px\">\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tFunction</th>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tDescription</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tlower()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tConverts strings in the Series/Index to lower case.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tupper()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tConverts strings in the Series/Index to upper case.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tlen()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tComputes String length().</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tstrip()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tHelps strip whitespace(including newline) from each string in the Series/index from both the sides.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tsplit(&#39; &#39;)</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tSplits each string with the given pattern.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tcat(sep=&#39; &#39;)</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tConcatenates the series/index elements with given separator.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tget_dummies()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReturns the DataFrame with One-Hot Encoded values.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tcontains(pattern)</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReturns count of appearance of pattern in each element.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\treplace(a,b)</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReplaces the value a with the value b.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&nbsp;repeat(value)</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tRepeats each element with specified number of times.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&nbsp;count(pattern)</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReturns count of appearance of pattern in each element.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tstartswith(pattern)</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReturns true if the element in the Series/Index starts with the pattern.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tendswith(pattern)</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReturns true if the element in the Series/Index ends with the pattern.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tfind(pattern)</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReturns the first position of the first occurrence of the pattern.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&nbsp;findall(pattern)</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tReturns a list of all occurrence of the pattern.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tswapcase</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tSwaps the case lower/upper.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tislower()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tChecks whether all characters in each string in the Series/Index in lower case or not. Returns Boolean</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t&nbsp;isupper()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tChecks whether all characters in each string in the Series/Index in upper case or not. Returns Boolean.</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tisnumeric()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tChecks whether all characters in each string in the Series/Index are numeric. Returns Boolean.</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n<p>\r\n\tLet us now create a Series and see how all the above functions work.</p>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\ns = pd.Series([&#39;Tom&#39;, &#39;William Rick&#39;, &#39;John&#39;, &#39;Alber@t&#39;, np.nan, <span _fck_bookmark=\"1\" style=\"display: none;\"> </span>&#39;1234&#39;,&#39;SteveSmith&#39;])\r\n\r\nprint s<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0 Tom\r\n1 William Rick\r\n2 John\r\n3 Alber@t\r\n4 NaN\r\n5 1234<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n6 Steve Smith\r\ndtype: object\r\n\r\n</pre>\r\n<h4>\r\n\tlower()<span _fck_bookmark=\"1\" style=\"display: none;\">&nbsp;</span></h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np\r\n\r\ns = pd.Series([&#39;Tom&#39;, &#39;William Rick&#39;<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>, &#39;John&#39;, &#39;Alber@t&#39;, np.nan, &#39;1234&#39;,&#39;SteveSmith&#39;])\r\n\r\nprint s.str.lower()<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0 tom\r\n1 william rick\r\n2 john\r\n3 alber@t\r\n4 NaN\r\n5 1234\r\n6 steve smith<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\ndtype: object\r\n</pre>\r\n<h4>\r\n\tupper()</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nimport numpy as np\r\n\r\ns = pd.Series([&#39;Tom&#39;, &#39;William Rick&#39;, &#39;<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>John&#39;, &#39;Alber@t&#39;, np.nan, &#39;1234&#39;,&#39;SteveSmith&#39;])\r\n\r\nprint s.str.upper()<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0 TOM\r\n1 WILLIAM RICK\r\n2 JOHN\r\n3 ALBER@T\r\n4 NaN\r\n5 1234\r\n6 STEVE SMITH\r\ndtype: object<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tlen()</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\ns = pd.Series([&#39;Tom&#39;, &#39;William R<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>ick&#39;, &#39;John&#39;, &#39;Alber@t&#39;, np.nan, &#39;1234&#39;,&#39;SteveSmith&#39;])\r\nprint s.str.len()\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0 3.0\r\n1 12.0\r\n2 4.0\r\n3 7.0\r\n4 NaN<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n5 4.0\r\n6 10.0\r\ndtype: float64\r\n</pre>\r\n<h4>\r\n\tstrip()</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np\r\ns = pd.Series([&#39;Tom &#39;, &#39; William Rick&#39;, &#39;John&#39;, &#39;Alber@t&#39;])\r\nprint s<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint (&quot;After Stripping:&quot;)\r\nprint s.str.strip()\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0 Tom\r\n1 William Rick\r\n2 John<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n3 Alber@t\r\ndtype: object\r\n\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>After Stripping:\r\n0 Tom\r\n1 William Rick\r\n2 John\r\n3 Alber@t\r\ndtype: object\r\n</pre>\r\n<h4>\r\n\tsplit(pattern)</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np\r\ns = pd.Series([&#39;Tom &#39;, &#39; William Rick&#39;, &#39;John&#39;, &#39;Alber@t&#39;])\r\nprint s<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint (&quot;Split Pattern:&quot;)\r\nprint s.str.split(&#39; &#39;)\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0 Tom\r\n1 William Rick<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n2 John\r\n3 Alber@t\r\ndtype: object\r\n\r\nSplit Pattern:\r\n0 [Tom, , , , , , , , , , ]\r\n1 [, , , , , William, Rick]\r\n2 [John]\r\n3 [Alber@t]\r\ndtype: object<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tcat(sep=pattern)</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>s = pd.Series([&#39;Tom &#39;, &#39; William Rick&#39;, &#39;John&#39;, &#39;Alber@t&#39;])\r\n\r\nprint s.str.cat(sep=&#39;_&#39;)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\nTom _ William Rick_John_Alber@t<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tget_dummies()</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\ns = pd.Series([&#39;Tom &#39;, &#39; Willia<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>m Rick&#39;, &#39;John&#39;, &#39;Alber@t&#39;])\r\n\r\nprint s.str.get_dummies()<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;William Rick Alber@t John Tom\r\n0            0       0    0   1\r\n1            1       0    0   0<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n2            0       0    1   0\r\n3            0       1    0   0\r\n</pre>\r\n<h4>\r\n\tcontains ()</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\ns = pd.Series([&#39;Tom &#39;, &#39; William Rick&#39;, &#39;John&#39;, &#39;Alber@t&#39;])\r\nprint s.str.contains(&#39; &#39;)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0 True\r\n1 True\r\n2 False\r\n3 False\r\ndtype: bool<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\treplace(a,b)</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\ns = pd.Series([&#39;Tom &#39;, &#39; William Rick&#39;, &#39;John&#39;, &#39;Alber@t&#39;])\r\nprint s\r\nprint (&quot;After replacing @ with $:&quot;)\r\nprint s.str.replace(&#39;@&#39;,&#39;$&#39;)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0 Tom\r\n1 William Rick\r\n2 John\r\n3 Alber@t\r\ndtype: object<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\nAfter replacing @ with $:\r\n0 Tom\r\n1 William Rick\r\n2 John<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n3 Alber$t\r\ndtype: object\r\n</pre>\r\n<h4>\r\n\trepeat(value)</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\ns = pd.Series([&#39;Tom &#39;, &#39; William Rick&#39;, &#39;John&#39;, &#39;Alber@t&#39;])<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\nprint s.str.repeat(2)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0 Tom Tom\r\n1 William Rick William Rick\r\n2 JohnJohn\r\n3 Alber@tAlber@t\r\ndtype: object<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tcount(pattern)</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\ns = pd.Series([&#39;Tom &#39;, &#39; William Rick&#39;, &#39;John&#39;, &#39;Alber@t&#39;])\r\n\r\nprint (&quot;The number of &#39;m&#39;s in each string:&quot;)\r\nprint s.str.count(&#39;m&#39;)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>The number of &#39;m&#39;s in each string:\r\n0 1\r\n1 1\r\n2 0\r\n3 0<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tstartswith(pattern)</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\ns = pd.Series([&#39;Tom &#39;, &#39; William Rick&#39;, &#39;John&#39;<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>, &#39;Alber@t&#39;])\r\n\r\nprint (&quot;Strings that start with &#39;T&#39;:&quot;)\r\nprint s.str. startswith (&#39;T&#39;)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0 True\r\n1 False\r\n2 False\r\n3 False\r\ndtype: bool<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tendswith(pattern)</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\ns = pd.Series([&#39;Tom &#39;, &#39; William Rick&#39;, &#39;John&#39;, &#39;Alber@t&#39;])\r\nprint (&quot;Strings that end w<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>ith &#39;t&#39;:&quot;)\r\nprint s.str.endswith(&#39;t&#39;)\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\nStrings that end with &#39;t&#39;:\r\n0 False\r\n1 False\r\n2 False<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n3 True\r\ndtype: bool\r\n</pre>\r\n<h4>\r\n\tfind(pattern)</h4>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\">import pandas as pd\r\n\r\ns = pd.Series([&#39;Tom &#39;, &#39; William Ri<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>ck&#39;, &#39;John&#39;, &#39;Alber@t&#39;])\r\n\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>print s.str.find(&#39;e&#39;)\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0 -1\r\n1 -1\r\n2 -1\r\n3 3\r\ndtype: int64<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<p>\r\n\t&quot;-1&quot; indicates that there no such pattern available in the element.</p>\r\n<h4>\r\n\tfindall(pattern)</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\ns = pd.Series([&#39;Tom &#39;, &#39; William Rick<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>&#39;, &#39;John&#39;, &#39;Alber@t&#39;])\r\n\r\nprint s.str.findall(&#39;e&#39;)<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0 [ ]\r\n1 [ ]\r\n2 [ ]<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n3 [e]\r\ndtype: object\r\n</pre>\r\n<p>\r\n\tNull list([ ]) indicates that there is no such pattern available in the element.</p>\r\n<h4>\r\n\tswapcase()</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\ns = pd.Series([&#39;Tom&#39;, &#39;William Rick&#39;, &#39;John&#39;, &#39;Alber@t&#39;])\r\nprint s.str.swapcase()<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0 tOM<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n1 wILLIAM rICK\r\n2 jOHN\r\n3 aLBER@T\r\ndtype: object\r\n</pre>\r\n<h4>\r\n\tislower()</h4>\r\n<pre>\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span><code class=\"python\">import pandas as pd\r\n\r\ns = pd.Series([&#39;Tom&#39;, &#39;William Rick&#39;, &#39;John&#39;, &#39;Alber@t&#39;])\r\nprint s.str.islower()<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0 False\r\n1 False\r\n2 False<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n3 False\r\ndtype: bool\r\n</pre>\r\n<h4>\r\n\tisupper()</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>s = pd.Series([&#39;Tom&#39;, &#39;William Rick&#39;, &#39;John&#39;, &#39;Alber@t&#39;])\r\n\r\nprint s.str.isupper()<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0 False\r\n1 False\r\n2 False\r\n3 False<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\ndtype: bool\r\n</pre>\r\n<h4>\r\n\tisnumeric()</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\ns = pd.Series([&#39;Tom&#39;, &#39;William Rick&#39;, &#39;<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>John&#39;, &#39;Alber@t&#39;])\r\n\r\nprint s.str.isnumeric()<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0 False<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n1 False\r\n2 False\r\n3 False\r\ndtype: bool</pre>\r\n<h2>\r\n\tPython Pandas - Indexing and Selecting Data</h2>\r\n<p>\r\n\tIn this chapter, we will discuss how to slice and dice the date and generally get the subset of pandas object.</p>\r\n<p>\r\n\tThe Python and NumPy indexing operators &quot;[ ]&quot; and attribute operator &quot;.&quot; provide quick and easy access to Pandas data structures across a wide range of use cases. However, since the type of the data to be accessed isn&rsquo;t known in advance, directly using standard operators has some optimization limits. For production code, we recommend that you take advantage of the optimized pandas data access methods explained in this chapter.</p>\r\n<p>\r\n\tPandas now supports three types of Multi-axes indexing; the three types are mentioned in the following table &minus;</p>\r\n<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width: 500px\">\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tIndexing</th>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tDescription</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t.loc()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tLabel based</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t.iloc()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tInteger based</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\t.ix()</td>\r\n\t\t\t<td style=\"text-align: center;\">\r\n\t\t\t\tBoth Label and Integer based</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n<h4>\r\n\t.loc()</h4>\r\n<p>\r\n\tPandas provide various methods to have purely label based indexing. When slicing, the start bound is also included. Integers are valid labels, but they refer to the label and not the position.</p>\r\n<p>\r\n\t.loc() has multiple access methods like&nbsp;</p>\r\n<ul>\r\n\t<li>\r\n\t\tA single scalar label</li>\r\n\t<li>\r\n\t\tA list of labels</li>\r\n\t<li>\r\n\t\tA slice object</li>\r\n\t<li>\r\n\t\tA Boolean array</li>\r\n</ul>\r\n<p>\r\n\tloc takes two single/list/range operator separated by &#39;,&#39;. The first one indicates the row and the second one indicates columns.</p>\r\n<h4>\r\n\tExample 1</h4>\r\n<pre>\r\n<code class=\"python\">#import the pandas library and aliasing as pd\r\nimport pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\ndf = pd.DataFrame(np.random.randn(8, 4),\r\nindex = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;], colum<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>ns = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])\r\n\r\n#select all rows for a specific column\r\nprint df.loc[:,&#39;A&#39;]<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\na  0.391548\r\nb -0.070649\r\nc -0.317212\r\nd -2.162406<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\ne  2.202797\r\nf  0.613709\r\ng  1.050559\r\nh  1.122680\r\nName: A, dtype: float64\r\n</pre>\r\n<h4>\r\n\tExample 2</h4>\r\n<pre>\r\n<code class=\"python\"># import the pandas library and aliasing as pd\r\nimport pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\ndf = pd.DataFrame(np.random.randn(8, 4),\r\nindex = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;], col<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>umns = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])\r\n\r\n# Select all rows for multiple<span _fck_bookmark=\"1\" style=\"display: none;\"> </span> columns, say list[]\r\nprint df.loc[:,[&#39;A&#39;,&#39;C&#39;] ]\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;        A         C<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\na  0.391548  0.745623\r\nb -0.070649  1.620406\r\nc -0.317212  1.448365\r\nd -2.162406 -0.873557\r\ne  2.202797  0.528067\r\nf  0.613709  0.286414\r\ng  1.050559  0.216526\r\nh  1.122680 -1.621420\r\n</pre>\r\n<h4>\r\n\tExample 3</h4>\r\n<pre>\r\n<code class=\"python\"># import the pandas library and aliasing as pd\r\nimport pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nimport numpy as np\r\n\r\ndf = pd.DataFrame(np.ran<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>dom.randn(8, 4),\r\nindex = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;], columns = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])\r\n\r\n# Select few rows for multiple columns,<span _fck_bookmark=\"1\" style=\"display: none;\"> </span> say list[]\r\nprint df.loc[ [&#39;a&#39;,&#39;b&#39;,&#39;f&#39;,&#39;h&#39;],[&#39;A&#39;,&#39;C&#39;] ]\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;        A         C\r\na  0.391548  0.745623\r\nb -0.070649  1.620406<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nf  0.613709  0.286414\r\nh  1.122680 -1.621420\r\n</pre>\r\n<h4>\r\n\tExample 4</h4>\r\n<pre>\r\n<code class=\"python\"># import the pandas library and aliasing as pd\r\nimport pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\ndf = pd.DataFrame(np.random.randn(8<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>, 4),\r\nindex = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;], columns = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])\r\n\r\n# Select range of rows for all columns\r\nprint df.loc[&#39;a&#39;:&#39;h&#39;]<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;        A         B         C         D\r\na  0.391548 -0.224297  0.745623  0.054301\r\nb -0.070649 -0.880130  1.620406  1.419743\r\nc -0.317212 -1.929698  1.448365  0.616899\r\nd -2.162406  0.614256 -0.873557  1.093958\r\ne  2.202797 -2.315915  0.528067  0.612482\r\nf  0.613709 -0.157674  0.286414 -0.500517\r\ng  1.050559 -2.272099  0.216526  0.928449\r\nh  1.122680  0.324368 -1.621420 -0.741470\r\n</pre>\r\n<h4>\r\n\tExample 5</h4>\r\n<pre>\r\n<code class=\"python\"># import the pandas library and aliasing as pd\r\nimport pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\ndf = pd.DataFrame(np.random.randn(8, 4),<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nindex = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;], columns = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])\r\n\r\n# for getting values with a boolean array\r\nprint df.loc[&#39;a&#39;]&gt;0<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\nA False\r\nB True\r\nC False\r\nD False\r\nName: a, dtype: bool<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\t.iloc()</h4>\r\n<p>\r\n\tPandas provide various methods in order to get purely integer based indexing. Like python and numpy, these are 0-based indexing.</p>\r\n<p>\r\n\tThe various access methods are as follows&nbsp;</p>\r\n<ul>\r\n\t<li>\r\n\t\tAn Integer</li>\r\n\t<li>\r\n\t\tA list of integers</li>\r\n\t<li>\r\n\t\tA range of values</li>\r\n</ul>\r\n<h4>\r\n\tExample 1</h4>\r\n<pre>\r\n<code class=\"python\"># import the pandas library and aliasing as pd\r\nimport pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nimport numpy as np\r\n\r\ndf = pd.DataFrame(np.ra<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>ndom.randn(8, 4), columns = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])\r\n\r\n# select all rows for a specific column\r\nprint df.iloc[:4]<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;        A         B         C         D\r\n0  0.699435  0.256239 -1.270702 -0.645195\r\n1 -0.685354  0.890791 -0.813012  0.631615<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n2 -0.783192 -0.531378  0.025070  0.230806\r\n3  0.539042 -1.284314  0.826977 -0.026251\r\n</pre>\r\n<h4>\r\n\tExample 2</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\ndf = pd.DataFrame(np.random.rand<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>n(8, 4), columns = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] )\r\n\r\n# Integer slicing\r\nprint df.iloc[:4]\r\nprint df.iloc[1:5, 2:4]<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;        A         B         C         D<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n0  0.699435  0.256239 -1.270702 -0.645195\r\n1 -0.685354  0.890791 -0.813012  0.631615\r\n2 -0.783192 -0.531378  0.025070  0.230806\r\n3  0.539042 -1.284314  0.826977 -0.026251\r\n \r\n          C         D\r\n1 -0.813012  0.631615\r\n2  0.025070  0.230806\r\n3  0.826977 -0.026251\r\n4  1.423332  1.130568<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</pre>\r\n<h4>\r\n\tExample 3</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\ndf = pd.DataFrame(np.random.randn(8,<span _fck_bookmark=\"1\" style=\"display: none;\"> </span> 4), columns = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])\r\n\r\n# Slicing through list of values\r\nprint df.iloc[ [1, 3, 5], [1, 3] ]\r\nprint df.iloc[1:3, :]\r\nprint df.iloc[:,1:3]<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;        B         D<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n1  0.890791  0.631615\r\n3 -1.284314 -0.026251\r\n5 -0.512888 -0.518930\r\n\r\n          A         B         C        D\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>1 -0.685354  0.890791 -0.813012 0.631615\r\n2 -0.783192 -0.531378  0.025070 0.230806\r\n\r\n          B         C\r\n0  0.256239 -1.270702\r\n1  0.890791 -0.813012\r\n2 -0.531378  0.025070\r\n3 -1.284314  0.826977\r\n4 -0.460729  1.423332\r\n5 -0.512888  0.581409<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n6 -1.204853  0.098060\r\n7 -0.947857  0.641358\r\n</pre>\r\n<h4>\r\n\t.ix()</h4>\r\n<p>\r\n\tBesides pure label based and integer based, Pandas provides a hybrid method for selections and subsetting the object using the .ix() operator.</p>\r\n<h4>\r\n\tExample 1</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nimport numpy as np\r\n\r\ndf = pd.DataFrame(np.random.randn(8, 4<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>), columns = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])\r\n\r\n# Integer slicing<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint df.ix[:4]\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;        A         B         C         D\r\n0  0.699435  0.256239 -1.270702 -0.645195<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n1 -0.685354  0.890791 -0.813012  0.631615\r\n2 -0.783192 -0.531378  0.025070  0.230806\r\n3  0.539042 -1.284314  0.826977 -0.026251\r\n</pre>\r\n<h4>\r\n\tExample 2</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n\r\ndf = pd.DataFrame(np.random.randn(8, 4), columns = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])\r\n# Index slicing<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\nprint df.ix[:,&#39;A&#39;]\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0 0.699435<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n1 -0.685354\r\n2 -0.783192\r\n3 0.539042\r\n4 -1.044209\r\n5 -1.415411\r\n6 1.062095\r\n7 0.994204\r\nName: A, dtype: float64\r\n</pre>\r\n<h3>\r\n\tUse of Notations</h3>\r\n<p>\r\n\tGetting values from the Pandas object with Multi-axes indexing uses the following notation&nbsp;</p>\r\n<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width: 500px\">\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tObject</th>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tIndexers</th>\r\n\t\t\t<th scope=\"col\">\r\n\t\t\t\tReturn Type</th>\r\n\t\t</tr>\r\n\t</thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>\r\n\t\t\t\tSeries</td>\r\n\t\t\t<td>\r\n\t\t\t\ts.loc[indexer]</td>\r\n\t\t\t<td>\r\n\t\t\t\tScalar value</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>\r\n\t\t\t\tDataFrame</td>\r\n\t\t\t<td>\r\n\t\t\t\tdf.loc[row_index,col_index]</td>\r\n\t\t\t<td>\r\n\t\t\t\tSeries object</td>\r\n\t\t</tr>\r\n\t\t<tr>\r\n\t\t\t<td>\r\n\t\t\t\tPanel</td>\r\n\t\t\t<td>\r\n\t\t\t\tp.loc[item_index,major_index, minor_index]</td>\r\n\t\t\t<td>\r\n\t\t\t\tp.loc[item_index,major_index, minor_index]</td>\r\n\t\t</tr>\r\n\t</tbody>\r\n</table>\r\n<p>\r\n\tNote &minus; .iloc() &amp; .ix() applies the same indexing options and Return value.</p>\r\n<p>\r\n\tLet us now see how each operation can be performed on the DataFrame object. We will use the basic indexing operator &#39;[ ]&#39; &minus;</p>\r\n<h4>\r\n\tExample 1</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np\r\ndf = pd.DataFrame(np.random.randn(8, 4), columns = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])\r\nprint df[&#39;A&#39;]<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0 -0.478893\r\n1 0.391931\r\n2 0.336825\r\n3 -1.055102\r\n4 -0.165218\r\n5 -0.328641<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n6 0.567721\r\n7 -0.759399\r\nName: A, dtype: float64\r\n</pre>\r\n<p>\r\n\tNote &minus; We can pass a list of values to [ ] to select those columns.</p>\r\n<h4>\r\n\tExample 2</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\ndf = pd.DataFrame(np.random.randn(8, 4), columns = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])\r\n\r\nprint df[ [&#39;A&#39;,&#39;B&#39;] ]<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n#&gt;        A         B\r\n0 -0.478893 -0.606311\r\n1  0.391931 -0.949025\r\n2  0.336825  0.093717\r\n3 -1.055102 -0.012944\r\n4 -0.165218  1.550310<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n5 -0.328641 -0.226363\r\n6  0.567721 -0.312585\r\n7 -0.759399 -0.372696\r\n</pre>\r\n<h4>\r\n\tExample 3</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy as np\r\ndf = pd.DataFrame(np.random.randn(8, 4), columns = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])\r\nprint df[2:2]<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\nColumns: [A, B, C, D]\r\nIndex: [ <span _fck_bookmark=\"1\" style=\"display: none;\"> </span>]\r\n</pre>\r\n<h3>\r\n\tAttribute Access</h3>\r\n<p>\r\n\tColumns can be selected using the attribute operator &#39;.&#39;.</p>\r\n<h4>\r\n\tExample</h4>\r\n<pre>\r\n<code class=\"python\">import pandas as pd\r\nimport numpy <span _fck_bookmark=\"1\" style=\"display: none;\"> </span>as np\r\ndf = pd.DataFrame(np.random.randn(8, 4), columns = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])\r\n\r\n<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>print df.A\r\n</code></pre>\r\n<p>\r\n\tIts output is as follows&nbsp;</p>\r\n<pre>\r\n0 -0.478893\r\n1 0.391931\r\n2 0.336825\r\n3 -1.055102\r\n4 -0.165218\r\n5 -0.328641\r\n6 0.567721<span _fck_bookmark=\"1\" style=\"display: none;\"> </span>\r\n7 -0.759399\r\nName: A, dtype: float64</pre>"
          }
        }
      ]
    }
  }
]