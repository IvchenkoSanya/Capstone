[
  {
    "query": "\u0421# programming language",
    "llm_version": "gpt_4",
    "language": "English",
    "course_content": {
      "course_name": "Get started C#",
      "lessons": [
        [
          {
            "title": "\u0421# programming language",
            "topics": []
          },
          {
            "title": "Introduction to C#",
            "topics": []
          },
          {
            "title": "C# Guide",
            "topics": []
          },
          {
            "title": "Console Application",
            "topics": []
          },
          {
            "title": "Rest Client",
            "topics": []
          },
          {
            "title": "Using Attributes in C#",
            "topics": []
          },
          {
            "title": "String Interpolation",
            "topics": []
          },
          {
            "title": "Working With Linq",
            "topics": []
          },
          {
            "title": "Microservices hosted in Docker",
            "topics": []
          },
          {
            "title": "Type System",
            "topics": []
          },
          {
            "title": "Casting and Type Conversions",
            "topics": []
          },
          {
            "title": "Boxing and Unboxing",
            "topics": []
          },
          {
            "title": "Using type dynamic",
            "topics": []
          },
          {
            "title": "Walkthrough: Creating and Using Dynamic Objects",
            "topics": []
          },
          {
            "title": "How to: Convert a byte Array to an int",
            "topics": []
          },
          {
            "title": "How to: Convert a String to a Number",
            "topics": []
          },
          {
            "title": "How to: Convert Between Hexadecimal Strings and Numeric Types",
            "topics": []
          },
          {
            "title": "Parse Strings Using String.Split",
            "topics": []
          },
          {
            "title": "Concatenate Multiple Strings",
            "topics": []
          },
          {
            "title": "Search strings",
            "topics": []
          },
          {
            "title": "Modify string contents",
            "topics": []
          },
          {
            "title": "How to compare strings",
            "topics": []
          },
          {
            "title": "Safely cast by using pattern matching is and as operators",
            "topics": []
          },
          {
            "title": "Select the C# language version",
            "topics": []
          },
          {
            "title": "C# Keywords",
            "topics": []
          },
          {
            "title": "Class",
            "topics": []
          },
          {
            "title": "Delegate",
            "topics": []
          },
          {
            "title": "Dynamic",
            "topics": []
          },
          {
            "title": "Interface",
            "topics": []
          },
          {
            "title": "Object",
            "topics": []
          },
          {
            "title": "String",
            "topics": []
          },
          {
            "title": "Void",
            "topics": []
          },
          {
            "title": "Var",
            "topics": []
          },
          {
            "title": "Built-in types table",
            "topics": []
          },
          {
            "title": "Integral types table",
            "topics": []
          },
          {
            "title": "Floating-point types table",
            "topics": []
          },
          {
            "title": "Value types table",
            "topics": []
          },
          {
            "title": "Default values table",
            "topics": []
          },
          {
            "title": "Implicit numeric conversions table",
            "topics": []
          },
          {
            "title": "Explicit numeric conversions table",
            "topics": []
          },
          {
            "title": "Formatting numeric results table",
            "topics": []
          },
          {
            "title": "Accessibility Levels",
            "topics": []
          },
          {
            "title": "Accessibility Domain",
            "topics": []
          },
          {
            "title": "Restrictions on using accessibility levels",
            "topics": []
          },
          {
            "title": "internal",
            "topics": []
          },
          {
            "title": "private",
            "topics": []
          },
          {
            "title": "protected",
            "topics": []
          },
          {
            "title": "public",
            "topics": []
          },
          {
            "title": "protected internal",
            "topics": []
          },
          {
            "title": "private protected",
            "topics": []
          },
          {
            "title": "abstract",
            "topics": []
          },
          {
            "title": "async",
            "topics": []
          },
          {
            "title": "const",
            "topics": []
          },
          {
            "title": "event",
            "topics": []
          },
          {
            "title": "extern",
            "topics": []
          },
          {
            "title": "in (Generic Modifier)",
            "topics": []
          },
          {
            "title": "out (Generic modifier)",
            "topics": []
          },
          {
            "title": "override",
            "topics": []
          },
          {
            "title": "readonly",
            "topics": []
          },
          {
            "title": "sealed",
            "topics": []
          },
          {
            "title": "static",
            "topics": []
          },
          {
            "title": "unsafe",
            "topics": []
          },
          {
            "title": "virtual",
            "topics": []
          },
          {
            "title": "volatile",
            "topics": []
          },
          {
            "title": "if-else",
            "topics": []
          },
          {
            "title": "switch",
            "topics": []
          },
          {
            "title": "do",
            "topics": []
          },
          {
            "title": "for",
            "topics": []
          },
          {
            "title": "foreach, in",
            "topics": []
          },
          {
            "title": "while",
            "topics": []
          },
          {
            "title": "break",
            "topics": []
          },
          {
            "title": "continue",
            "topics": []
          },
          {
            "title": "goto",
            "topics": []
          },
          {
            "title": "return",
            "topics": []
          },
          {
            "title": "throw",
            "topics": []
          },
          {
            "title": "try-catch",
            "topics": []
          },
          {
            "title": "try-finally",
            "topics": []
          },
          {
            "title": "try-catch-finally",
            "topics": []
          },
          {
            "title": "checked",
            "topics": []
          },
          {
            "title": "unchecked",
            "topics": []
          },
          {
            "title": "fixed Statement",
            "topics": []
          },
          {
            "title": "lock statement",
            "topics": []
          },
          {
            "title": "params",
            "topics": []
          },
          {
            "title": "in (Parameter Modifier)",
            "topics": []
          },
          {
            "title": "ref",
            "topics": []
          },
          {
            "title": "out (Parameter Modifier)",
            "topics": []
          }
        ]
      ],
      "lessons_content": [
        [
          {
            "\u0421# programming language": "<p>\r\n\tMicrosoft<br />\r\n\t[[! | https://docs.microsoft.com/en-us/dotnet/csharp/]]</p>"
          },
          {
            "Introduction to C#": "<div>\r\n\tWelcome to the introduction to C# tutorials. These start with interactive lessons that you can run in your browser.</div>\r\n<p>\r\n\tThe first lessons explain C# concepts using small snippets of code. You&#39;ll learn the basics of C# syntax and how to work with data types like strings, numbers, and booleans. It&#39;s all interactive, and you&#39;ll be writing and running code within minutes. These first lessons assume no prior knowledge of programming or the C# language.</p>\r\n<p>\r\n\tAll the introductory tutorials following the Hello World lesson are available using the online browser experience or&nbsp;in your own local development environment. At the end of each tutorial, you decide if you want to continue with the next lesson online or on your own machine. There are links to help you set up your environment and continue with the next tutorial on your machine.</p>\r\n<h2>\r\n\tHello world</h2>\r\n<p>\r\n\tIn the&nbsp;Hello world&nbsp;tutorial, you&#39;ll create the most basic C# program. You&#39;ll explore the&nbsp;<code>string</code>&nbsp;type and how to work with text.</p>\r\n<h2>\r\n\tNumbers in C#</h2>\r\n<p>\r\n\tIn the&nbsp;Numbers in C#&nbsp;tutorial, you&#39;ll learn how computers store numbers and how to perform calculations with different numeric types. You&#39;ll learn the basics of rounding, and how to perform mathematical calculations using C#. This tutorial is also available&nbsp;to run locally on your machine.</p>\r\n<p>\r\n\tThis tutorial assumes that you have finished the&nbsp;Hello world&nbsp;lesson.</p>\r\n<h2>\r\n\tBranches and loops</h2>\r\n<p>\r\n\tThe&nbsp;Branches and loops&nbsp;tutorial teaches the basics of selecting different paths of code execution based on the values stored in variables. You&#39;ll learn the basics of control flow, which is the basis of how programs make decisions and choose different actions. This tutorial is also available&nbsp;to run locally on your machine.</p>\r\n<p>\r\n\tThis tutorial assumes that you have finished the&nbsp;Hello world&nbsp;and&nbsp;Numbers in C#&nbsp;lessons.</p>\r\n<h2>\r\n\tString interpolation</h2>\r\n<p>\r\n\tThe&nbsp;String interpolation&nbsp;tutorial shows you how to insert values into a string. You&#39;ll learn how to create an interpolated string with embedded C# expressions and how to control the formatting of the output string. This tutorial is also available&nbsp;to run locally on your machine.</p>\r\n<p>\r\n\tThis tutorial assumes that you have finished the&nbsp;Hello world,&nbsp;Numbers in C#, and&nbsp;Branches and loopslessons.</p>\r\n<h2>\r\n\tList collection</h2>\r\n<p>\r\n\tThe&nbsp;List collection&nbsp;lesson gives you a tour of the List collection type that stores sequences of data. You&#39;ll learn how to add and remove items, search for items, and sort the lists. You&#39;ll explore different kinds of lists. This tutorial is also available&nbsp;to run locally on your machine.</p>\r\n<p>\r\n\tThis tutorial assumes that you have finished the lessons listed above.</p>\r\n<h2>\r\n\tIntroduction to classes</h2>\r\n<p>\r\n\tThis final tutorial is only available to run on your machine, using your own local development environment and .NET Core. You&#39;ll build a console application and see the basic object-oriented features that are part of the C# language.</p>\r\n<p>\r\n\tThis tutorial assumes you&#39;ve finished the online introductory tutorials, and you&#39;ve installed&nbsp;<a href=\"https://www.microsoft.com/net/download\" target=\"_blank\">.NET Core SDK</a>&nbsp;and&nbsp;<a href=\"https://code.visualstudio.com/\" target=\"_blank\">Visual Studio Code</a>.</p>"
          },
          {
            "C# Guide": "<p>\r\n\tThe C# guide provides many resources about the C# language. This site has many different audiences. Depending on your experience with programming, or with the C# language and .NET, you may wish to explore different sections of this guide.</p>\r\n<ul>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tFor brand-new developers:</p>\r\n\t\t<ul>\r\n\t\t\t<li>\r\n\t\t\t\tStart with the&nbsp;Introduction to C# tutorials. These tutorials let you explore the C# language interactively in your browser. From there, you can move on to other&nbsp;tutorials. These tutorials show you how to create C# programs from scratch. The tutorials provide a step-by-step process to create programs. They show the language concepts and how to build C# programs on your own. If you prefer reading overview information first, try the&nbsp;tour of the C# language. It explains the concepts of the C# language. After reading this, you&#39;ll have a basic understanding of the language, and be ready to try the tutorials, or build something on your own.</li>\r\n\t\t</ul>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tFor developers new to C#:</p>\r\n\t\t<ul>\r\n\t\t\t<li>\r\n\t\t\t\tIf you&#39;ve done development before, but are new to C#, read the&nbsp;tour of the C# language. It covers the basic syntax and structure for the language, and you can use the language tour to contrast C# with other languages you&#39;ve used. You can also browse the&nbsp;tutorials&nbsp;to try basic C# programs.</li>\r\n\t\t</ul>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tExperienced C# developers:</p>\r\n\t\t<ul>\r\n\t\t\t<li>\r\n\t\t\t\tIf you&#39;ve used C# before, you should start by reading what&#39;s in the latest version of the language. Check out&nbsp;What&#39;s new in C#&nbsp;for the new features in the current version.</li>\r\n\t\t</ul>\r\n\t</li>\r\n</ul>\r\n<h2>\r\n\tHow the C# guide is organized</h2>\r\n<p>\r\n\tThere are several sections in the C# Guide. You can read them in order, or jump directly to what interests you the most. Some of the sections are heavily focused on the language. Others provide end-to-end scenarios that demonstrate a few of the types of programs you can create using C# and the .NET Framework.</p>\r\n<ul>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tGet Started</p>\r\n\t\t<ul>\r\n\t\t\t<li>\r\n\t\t\t\tThis section covers what you need to install for a C# development environment on your preferred platform. The different topics under this section explain how to create your first C# program in different supported environments.</li>\r\n\t\t</ul>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tIntroduction to C# tutorials:</p>\r\n\t\t<ul>\r\n\t\t\t<li>\r\n\t\t\t\tIntroduction to C# tutorials presents interactive tutorials for brand-new developers to explore and learn the C# language in the browser using a Read-Eval-Print Loop (REPL) interface. After you finish the interactive lessons, you can improve your coding skills by practicing the same lessons on your machine.</li>\r\n\t\t</ul>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tTutorials</p>\r\n\t\t<ul>\r\n\t\t\t<li>\r\n\t\t\t\tThis section provides a variety of end-to-end scenarios, including descriptions and code. It shows why certain idioms are preferred, what C# features work best in different situations, and reference implementations for common tasks. If you learn best by seeing code, start in this section. You can also download all the code and experiment in your own environment.</li>\r\n\t\t</ul>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tTour of C#</p>\r\n\t\t<ul>\r\n\t\t\t<li>\r\n\t\t\t\tThis section provides an overview of the language. It covers the elements that make up C# programs and the capabilities of the language. It shows small samples of all the syntax elements of C# and discussions of the major C# language topics.</li>\r\n\t\t</ul>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tWhat&#39;s new in C#</p>\r\n\t\t<ul>\r\n\t\t\t<li>\r\n\t\t\t\tProvides overviews of new features added in the latest language releases and of the history of the C# language.</li>\r\n\t\t</ul>\r\n\t</li>\r\n</ul>\r\n<ul>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tC# Programming Guide</p>\r\n\t\t<ul>\r\n\t\t\t<li>\r\n\t\t\t\tProvides information and practical examples about how to use C# language constructs.</li>\r\n\t\t</ul>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tWalkthroughs</p>\r\n\t\t<ul>\r\n\t\t\t<li>\r\n\t\t\t\tProvides links to programming walkthroughs that use C# and a brief description of each walkthrough.</li>\r\n\t\t</ul>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tLanguage Reference</p>\r\n\t\t<ul>\r\n\t\t\t<li>\r\n\t\t\t\tThis section contains the reference material on the C# language. This material helps you understand the syntax and semantics of C#. It also includes reference material on types, operators, attributes, preprocessor directives, compiler switches, compiler errors, and compiler warnings.</li>\r\n\t\t</ul>\r\n\t</li>\r\n</ul>"
          },
          {
            "Console Application": "<p>\r\n\tThis tutorial teaches you a number of features in .NET Core and the C# language. You&rsquo;ll learn:</p>\r\n<ul>\r\n\t<li>\r\n\t\tThe basics of the .NET Core Command Line Interface (CLI)</li>\r\n\t<li>\r\n\t\tThe structure of a C# Console Application</li>\r\n\t<li>\r\n\t\tConsole I/O</li>\r\n\t<li>\r\n\t\tThe basics of File I/O APIs in .NET</li>\r\n\t<li>\r\n\t\tThe basics of the Task-based Asynchronous Programming in .NET</li>\r\n</ul>\r\n<p>\r\n\tYou&rsquo;ll build an application that reads a text file, and echoes the contents of that text file to the console. The output to the console is paced to match reading it aloud. You can speed up or slow down the pace by pressing the &lsquo;&lt;&rsquo; (less than) or &lsquo;&gt;&rsquo; (greater than) keys.</p>\r\n<p>\r\n\tThere are a lot of features in this tutorial. Let&rsquo;s build them one by one.</p>\r\n<h2>\r\n\t&nbsp;</h2>\r\n<h2>\r\n\tPrerequisites</h2>\r\n<p>\r\n\tYou&rsquo;ll need to setup your machine to run .NET Core. You can find the installation instructions on the&nbsp;<a href=\"https://www.microsoft.com/net/core\" target=\"_blank\">.NET Core</a>&nbsp;page. You can run this application on Windows, Linux, macOS or in a Docker container. You&rsquo;ll need to install your favorite code editor.</p>\r\n<h2>\r\n\tCreate the Application</h2>\r\n<p>\r\n\tThe first step is to create a new application. Open a command prompt and create a new directory for your application. Make that the current directory. Type the command&nbsp;<code>dotnet new console</code>&nbsp;at the command prompt. This creates the starter files for a basic &quot;Hello World&quot; application.</p>\r\n<p>\r\n\tBefore you start making modifications, let&rsquo;s go through the steps to run the simple Hello World application. After creating the application, type&nbsp;<code>dotnet restore</code>&nbsp;at the command prompt. This command runs the NuGet package restore process. NuGet is a .NET package manager. This command downloads any of the missing dependencies for your project. As this is a new project, none of the dependencies are in place, so the first run will download the .NET Core framework. After this initial step, you will only need to run&nbsp;<code>dotnet restore</code>&nbsp;when you add new dependent packages, or update the versions of any of your dependencies.</p>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;</p>\r\n\t<p>\r\n\t\tStarting with .NET Core 2.0 SDK, you don&#39;t have to run&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-restore\" target=\"_blank\"><code>dotnet restore</code></a>&nbsp;because it&#39;s run implicitly by all commands that require a restore to occur, such as&nbsp;<code>dotnet new</code>,&nbsp;<code>dotnet build</code>and&nbsp;<code>dotnet run</code>. It&#39;s still a valid command in certain scenarios where doing an explicit restore makes sense, such as&nbsp;<a href=\"https://docs.microsoft.com/azure/devops/build-release/apps/aspnet/build-aspnet-core\" target=\"_blank\">continuous integration builds in Azure DevOps Services</a>&nbsp;or in build systems that need to explicitly control the time at which the restore occurs.</p>\r\n</div>\r\n<p>\r\n\tAfter restoring packages, you run&nbsp;<code>dotnet build</code>. This executes the build engine and creates your application executable. Finally, you execute&nbsp;<code>dotnet run</code>&nbsp;to run your application.</p>\r\n<p>\r\n\tThe simple Hello World application code is all in Program.cs. Open that file with your favorite text editor. We&rsquo;re about to make our first changes. At the top of the file, see a using statement:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System;\r\n</code></pre>\r\n<p>\r\n\tThis statement tells the compiler that any types from the&nbsp;<code>System</code>&nbsp;namespace are in scope. Like other Object Oriented languages you may have used, C# uses namespaces to organize types. This Hello World program is no different. You can see that the program is enclosed in the namespace with the name based on the name of the current directory. For this tutorial, let&#39;s change the name of the namespace to&nbsp;<code>TeleprompterConsole</code>:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>namespace</span> <span>TeleprompterConsole</span>\r\n</code></pre>\r\n<h2>\r\n\tReading and Echoing the File</h2>\r\n<p>\r\n\tThe first feature to add is the ability to read a text file and display all that text to the console. First, let&rsquo;s add a text file. Copy the&nbsp;<a href=\"https://github.com/dotnet/samples/raw/master/csharp/getting-started/console-teleprompter/sampleQuotes.txt\" target=\"_blank\">sampleQuotes.txt</a>&nbsp;file from the GitHub repository for this&nbsp;<a href=\"https://github.com/dotnet/samples/tree/master/csharp/getting-started/console-teleprompter\" target=\"_blank\">sample</a>&nbsp;into your project directory. This will serve as the script for your application. If you would like information on how to download the sample app for this topic, see the instructions in the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/samples-and-tutorials/index#viewing-and-downloading-samples\" target=\"_blank\">Samples and Tutorials</a>topic.</p>\r\n<p>\r\n\tNext, add the following method in your&nbsp;<code>Program</code>&nbsp;class (right below the&nbsp;<code>Main</code>&nbsp;method):</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>static</span> IEnumerable&lt;<span>string</span>&gt; <span>ReadFrom</span>(<span><span>string</span> file</span>)\r\n</span>{\r\n    <span>string</span> line;\r\n    <span>using</span> (<span>var</span> reader = File.OpenText(file))\r\n    {\r\n        <span>while</span> ((line = reader.ReadLine()) != <span>null</span>)\r\n        {\r\n            <span>yield</span> <span>return</span> line;\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tThis method uses types from two new namespaces. For this to compile you&rsquo;ll need to add the following two lines to the top of the file:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System.Collections.Generic;\r\n<span>using</span> System.IO;\r\n</code></pre>\r\n<p>\r\n\tThe&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1\" target=\"_blank\">IEnumerable&lt;T&gt;</a>&nbsp;interface is defined in the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic\" target=\"_blank\">System.Collections.Generic</a>&nbsp;namespace. The&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.io.file\" target=\"_blank\">File</a>&nbsp;class is defined in the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.io\" target=\"_blank\">System.IO</a>&nbsp;namespace.</p>\r\n<p>\r\n\tThis method is a special type of C# method called an&nbsp;<em>Iterator method</em>. Enumerator methods return sequences that are evaluated lazily. That means each item in the sequence is generated as it is requested by the code consuming the sequence. Enumerator methods are methods that contain one or more&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/yield\" target=\"_blank\"><code>yield return</code></a>&nbsp;statements. The object returned by the&nbsp;<code>ReadFrom</code>&nbsp;method contains the code to generate each item in the sequence. In this example, that involves reading the next line of text from the source file, and returning that string. Each time the calling code requests the next item from the sequence, the code reads the next line of text from the file and returns it. When the file is completely read, the sequence indicates that there are no more items.</p>\r\n<p>\r\n\tThere are two other C# syntax elements that may be new to you. The&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-statement\" target=\"_blank\"><code>using</code></a>&nbsp;statement in this method manages resource cleanup. The variable that is initialized in the&nbsp;<code>using</code>&nbsp;statement (<code>reader</code>, in this example) must implement the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.idisposable\" target=\"_blank\">IDisposable</a>&nbsp;interface. That interface defines a single method,&nbsp;<code>Dispose</code>, that should be called when the resource should be released. The compiler generates that call when execution reaches the closing brace of the&nbsp;<code>using</code>&nbsp;statement. The compiler-generated code ensures that the resource is released even if an exception is thrown from the code in the block defined by the using statement.</p>\r\n<p>\r\n\tThe&nbsp;<code>reader</code>&nbsp;variable is defined using the&nbsp;<code>var</code>&nbsp;keyword.&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/var\" target=\"_blank\"><code>var</code></a>&nbsp;defines an&nbsp;<em>implicitly typed local variable</em>. That means the type of the variable is determined by the compile-time type of the object assigned to the variable. Here, that is the return value from the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.io.file.opentext#System_IO_File_OpenText_System_String_\" target=\"_blank\">OpenText(String)</a>&nbsp;method, which is a&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.io.streamreader\" target=\"_blank\">StreamReader</a>&nbsp;object.</p>\r\n<p>\r\n\tNow, let&rsquo;s fill in the code to read the file in the&nbsp;<code>Main</code>&nbsp;method:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>var</span> lines = ReadFrom(<span>&quot;sampleQuotes.txt&quot;</span>);\r\n<span>foreach</span> (<span>var</span> line <span>in</span> lines)\r\n{\r\n    Console.WriteLine(line);\r\n}\r\n</code></pre>\r\n<p>\r\n\tRun the program (using&nbsp;<code>dotnet run</code>) and you can see every line printed out to the console.</p>\r\n<h2>\r\n\tAdding Delays and Formatting output</h2>\r\n<p>\r\n\tWhat you have is being displayed far too fast to read aloud. Now you need to add the delays in the output. As you start, you&rsquo;ll be building some of the core code that enables asynchronous processing. However, these first steps will follow a few anti-patterns. The anti-patterns are pointed out in comments as you add the code, and the code will be updated in later steps.</p>\r\n<p>\r\n\tThere are two steps to this section. First, you&rsquo;ll update the iterator method to return single words instead of entire lines. That&rsquo;s done with these modifications. Replace the&nbsp;<code>yield return line;</code>statement with the following code:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>var</span> words = line.Split(<span>&#39; &#39;</span>);\r\n<span>foreach</span> (<span>var</span> word <span>in</span> words)\r\n{\r\n    <span>yield</span> <span>return</span> word + <span>&quot; &quot;</span>;\r\n}\r\n<span>yield</span> <span>return</span> Environment.NewLine;\r\n</code></pre>\r\n<p>\r\n\tNext, you need to modify how you consume the lines of the file, and add a delay after writing each word. Replace the&nbsp;<code>Console.WriteLine(line)</code>&nbsp;statement in the&nbsp;<code>Main</code>&nbsp;method with the following block:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>Console.Write(line);\r\n<span>if</span> (!<span>string</span>.IsNullOrWhiteSpace(line))\r\n{\r\n    <span>var</span> pause = Task.Delay(<span>200</span>);\r\n    <span>// Synchronously waiting on a task is an</span>\r\n    <span>// anti-pattern. This will get fixed in later</span>\r\n    <span>// steps.</span>\r\n    pause.Wait();\r\n}\r\n</code></pre>\r\n<p>\r\n\tThe&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task\" target=\"_blank\">Task</a>&nbsp;class is in the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks\" target=\"_blank\">System.Threading.Tasks</a>&nbsp;namespace, so you need to add that&nbsp;<code>using</code>statement at the top of file:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System.Threading.Tasks;\r\n</code></pre>\r\n<p>\r\n\tRun the sample, and check the output. Now, each single word is printed, followed by a 200 ms delay. However, the displayed output shows some issues because the source text file has several lines that have more than 80 characters without a line break. That can be hard to read while it&#39;s scrolling by. That&rsquo;s easy to fix. You&rsquo;ll just keep track of the length of each line, and generate a new line whenever the line length reaches a certain threshold. Declare a local variable after the declaration of&nbsp;<code>words</code>&nbsp;in the&nbsp;<code>ReadFrom</code>&nbsp;method that holds the line length:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>var</span> lineLength = <span>0</span>;\r\n</code></pre>\r\n<p>\r\n\tThen, add the following code after the&nbsp;<code>yield return word + &quot; &quot;;</code>&nbsp;statement (before the closing brace):</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>lineLength += word.Length + <span>1</span>;\r\n<span>if</span> (lineLength &gt; <span>70</span>)\r\n{\r\n    <span>yield</span> <span>return</span> Environment.NewLine;\r\n    lineLength = <span>0</span>;\r\n}\r\n</code></pre>\r\n<p>\r\n\tRun the sample, and you&rsquo;ll be able to read aloud at its pre-configured pace.</p>\r\n<h2>\r\n\tAsync Taskl</h2>\r\n<p>\r\n\tIn this final step, you&rsquo;ll add the code to write the output asynchronously in one task, while also running another task to read input from the user if they want to speed up or slow down the text display, or stop the text display altogether. This has a few steps in it and by the end, you&rsquo;ll have all the updates that you need. The first step is to create an asynchronous&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task\" target=\"_blank\">Task</a>&nbsp;returning method that represents the code you&rsquo;ve created so far to read and display the file.</p>\r\n<p>\r\n\tAdd this method to your&nbsp;<code>Program</code>&nbsp;class (it&rsquo;s taken from the body of your&nbsp;<code>Main</code>&nbsp;method):</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>private</span> <span>static</span> <span>async</span> Task <span>ShowTeleprompter</span>()\r\n</span>{\r\n    <span>var</span> words = ReadFrom(<span>&quot;sampleQuotes.txt&quot;</span>);\r\n    <span>foreach</span> (<span>var</span> word <span>in</span> words)\r\n    {\r\n        Console.Write(word);\r\n        <span>if</span> (!<span>string</span>.IsNullOrWhiteSpace(word))\r\n        {\r\n            <span>await</span> Task.Delay(<span>200</span>);\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tYou&rsquo;ll notice two changes. First, in the body of the method, instead of calling&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.wait#System_Threading_Tasks_Task_Wait\" target=\"_blank\">Wait()</a>&nbsp;to synchronously wait for a task to finish, this version uses the&nbsp;<code>await</code>&nbsp;keyword. In order to do that, you need to add the&nbsp;<code>async</code>&nbsp;modifier to the method signature. This method returns a&nbsp;<code>Task</code>. Notice that there are no return statements that return a&nbsp;<code>Task</code>&nbsp;object. Instead, that&nbsp;<code>Task</code>&nbsp;object is created by code the compiler generates when you use the&nbsp;<code>await</code>&nbsp;operator. You can imagine that this method returns when it reaches an&nbsp;<code>await</code>. The returned&nbsp;<code>Task</code>&nbsp;indicates that the work has not completed. The method resumes when the awaited task completes. When it has executed to completion, the returned&nbsp;<code>Task</code>&nbsp;indicates that it is complete. Calling code can monitor that returned&nbsp;<code>Task</code>&nbsp;to determine when it has completed.</p>\r\n<p>\r\n\tYou can call this new method in your&nbsp;<code>Main</code>&nbsp;method:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>ShowTeleprompter().Wait();\r\n</code></pre>\r\n<p>\r\n\tHere, in&nbsp;<code>Main</code>, the code does synchronously wait. You should use the&nbsp;<code>await</code>&nbsp;operator instead of synchronously waiting whenever possible. But, in a console application&rsquo;s&nbsp;<code>Main</code>&nbsp;method, you cannot use the&nbsp;<code>await</code>&nbsp;operator. That would result in the application exiting before all tasks have completed.</p>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;</p>\r\n</div>\r\n<p>\r\n\tNext, you need to write the second asynchronous method to read from the Console and watch for the &lsquo;&lt;&rsquo; (less than), &lsquo;&gt;&rsquo; (greater than) and &lsquo;X&rsquo; or &lsquo;x&rsquo; keys. Here&rsquo;s the method you add for that task:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>private</span> <span>static</span> <span>async</span> Task <span>GetInput</span>()\r\n</span>{\r\n    <span>var</span> delay = <span>200</span>;\r\n    Action work = () =&gt;\r\n    {\r\n        <span>do</span> {\r\n            <span>var</span> key = Console.ReadKey(<span>true</span>);\r\n            <span>if</span> (key.KeyChar == <span>&#39;&gt;&#39;</span>)\r\n            {\r\n                delay -= <span>10</span>;\r\n            }\r\n            <span>else</span> <span>if</span> (key.KeyChar == <span>&#39;&lt;&#39;</span>)\r\n            {\r\n                delay += <span>10</span>;\r\n            }\r\n            <span>else</span> <span>if</span> (key.KeyChar == <span>&#39;X&#39;</span> || key.KeyChar == <span>&#39;x&#39;</span>)\r\n            {\r\n                <span>break</span>;\r\n            }\r\n        } <span>while</span> (<span>true</span>);\r\n    };\r\n    <span>await</span> Task.Run(work);\r\n}\r\n</code></pre>\r\n<p>\r\n\tThis creates a lambda expression to represent an&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.action\" target=\"_blank\">Action</a>&nbsp;delegate that reads a key from the Console and modifies a local variable representing the delay when the user presses the &lsquo;&lt;&rsquo; (less than) or &lsquo;&gt;&rsquo; (greater than) keys. The delegate method finishes when user presses the &lsquo;X&rsquo; or &lsquo;x&rsquo; keys, which allow the user to stop the text display at any time. This method uses&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.console.readkey#System_Console_ReadKey\" target=\"_blank\">ReadKey()</a>&nbsp;to block and wait for the user to press a key.</p>\r\n<p>\r\n\tTo finish this feature, you need to create a new&nbsp;<code>async Task</code>&nbsp;returning method that starts both of these tasks (<code>GetInput</code>&nbsp;and&nbsp;<code>ShowTeleprompter</code>), and also manages the shared data between these two tasks.</p>\r\n<p>\r\n\tIt&rsquo;s time to create a class that can handle the shared data between these two tasks. This class contains two public properties: the delay, and a flag&nbsp;<code>Done</code>&nbsp;to indicate that the file has been completely read:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>namespace</span> <span>TeleprompterConsole</span>\r\n{\r\n    <span>internal</span> <span>class</span> <span>TelePrompterConfig</span>\r\n    {\r\n        <span>private</span> <span>object</span> lockHandle = <span>new</span> <span>object</span>();\r\n        <span>public</span> <span>int</span> DelayInMilliseconds { <span>get</span>; <span>private</span> <span>set</span>; } = <span>200</span>;\r\n\r\n        <span><span>public</span> <span>void</span> <span>UpdateDelay</span>(<span><span>int</span> increment</span>) <span>// negative to speed up</span>\r\n        </span>{\r\n            <span>var</span> newDelay = Min(DelayInMilliseconds + increment, <span>1000</span>);\r\n            newDelay = Max(newDelay, <span>20</span>);\r\n            <span>lock</span> (lockHandle)\r\n            {\r\n                DelayInMilliseconds = newDelay;\r\n            }\r\n        }\r\n\r\n        <span>public</span> <span>bool</span> Done { <span>get</span>; <span>private</span> <span>set</span>; }\r\n\r\n        <span><span>public</span> <span>void</span> <span>SetDone</span>()\r\n        </span>{\r\n            Done = <span>true</span>;\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tPut that class in a new file, and enclose that class in the&nbsp;<code>TeleprompterConsole</code>&nbsp;namespace as shown above. You&rsquo;ll also need to add a&nbsp;<code>using static</code>&nbsp;statement so that you can reference the&nbsp;<code>Min</code>&nbsp;and&nbsp;<code>Max</code>&nbsp;methods without the enclosing class or namespace names. A&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-static\" target=\"_blank\"><code>using static</code></a>&nbsp;statement imports the methods from one class. This is in contrast with the&nbsp;<code>using</code>&nbsp;statements used up to this point that have imported all classes from a namespace.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> <span>static</span> System.Math;\r\n</code></pre>\r\n<p>\r\n\tThe other language feature that&rsquo;s new is the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/lock-statement\" target=\"_blank\"><code>lock</code></a>&nbsp;statement. This statement ensures that only a single thread can be in that code at any given time. If one thread is in the locked section, other threads must wait for the first thread to exit that section. The&nbsp;<code>lock</code>&nbsp;statement uses an object that guards the lock section. This class follows a standard idiom to lock a private object in the class.</p>\r\n<p>\r\n\tNext, you need to update the&nbsp;<code>ShowTeleprompter</code>&nbsp;and&nbsp;<code>GetInput</code>&nbsp;methods to use the new&nbsp;<code>config</code>object. Write one final&nbsp;<code>Task</code>&nbsp;returning&nbsp;<code>async</code>&nbsp;method to start both tasks and exit when the first task finishes:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>private</span> <span>static</span> <span>async</span> Task <span>RunTeleprompter</span>()\r\n</span>{\r\n    <span>var</span> config = <span>new</span> TelePrompterConfig();\r\n    <span>var</span> displayTask = ShowTeleprompter(config);\r\n\r\n    <span>var</span> speedTask = GetInput(config);\r\n    <span>await</span> Task.WhenAny(displayTask, speedTask);\r\n}\r\n</code></pre>\r\n<p>\r\n\tThe one new method here is the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.whenany#System_Threading_Tasks_Task_WhenAny_System_Threading_Tasks_Task___\" target=\"_blank\">WhenAny(Task[])</a>&nbsp;call. That creates a&nbsp;<code>Task</code>&nbsp;that finishes as soon as any of the tasks in its argument list completes.</p>\r\n<p>\r\n\tNext, you need to update both the&nbsp;<code>ShowTeleprompter</code>&nbsp;and&nbsp;<code>GetInput</code>&nbsp;methods to use the&nbsp;<code>config</code>object for the delay:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>private</span> <span>static</span> <span>async</span> Task <span>ShowTeleprompter</span>(<span>TelePrompterConfig config</span>)\r\n</span>{\r\n    <span>var</span> words = ReadFrom(<span>&quot;sampleQuotes.txt&quot;</span>);\r\n    <span>foreach</span> (<span>var</span> word <span>in</span> words)\r\n    {\r\n        Console.Write(word);\r\n        <span>if</span> (!<span>string</span>.IsNullOrWhiteSpace(word))\r\n        {\r\n            <span>await</span> Task.Delay(config.DelayInMilliseconds);\r\n        }\r\n    }\r\n    config.SetDone();\r\n}\r\n\r\n<span><span>private</span> <span>static</span> <span>async</span> Task <span>GetInput</span>(<span>TelePrompterConfig config</span>)\r\n</span>{\r\n    Action work = () =&gt;\r\n    {\r\n        <span>do</span> {\r\n            <span>var</span> key = Console.ReadKey(<span>true</span>);\r\n            <span>if</span> (key.KeyChar == <span>&#39;&gt;&#39;</span>)\r\n                config.UpdateDelay(<span>-10</span>);\r\n            <span>else</span> <span>if</span> (key.KeyChar == <span>&#39;&lt;&#39;</span>)\r\n                config.UpdateDelay(<span>10</span>);\r\n        } <span>while</span> (!config.Done);\r\n    };\r\n    <span>await</span> Task.Run(work);\r\n}\r\n</code></pre>\r\n<p>\r\n\tThis new version of&nbsp;<code>ShowTeleprompter</code>&nbsp;calls a new method in the&nbsp;<code>TeleprompterConfig</code>&nbsp;class. Now, you need to update&nbsp;<code>Main</code>&nbsp;to call&nbsp;<code>RunTeleprompter</code>&nbsp;instead of&nbsp;<code>ShowTeleprompter</code>:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>RunTeleprompter().Wait();\r\n</code></pre>\r\n<h2>\r\n\tConclusion</h2>\r\n<p>\r\n\tThis tutorial showed you a number of the features around the C# language and the .NET Core libraries related to working in Console applications. You can build on this knowledge to explore more about the language, and the classes introduced here. You&rsquo;ve seen the basics of File and Console I/O, blocking and non-blocking use of the Task-based asynchronous programming, a tour of the C# language and how C# programs are organized and the .NET Core Command Line Interface and tools.</p>\r\n<p>\r\n\tFor more information about File I/O, see the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/io/index\" target=\"_blank\">File and Stream I/O</a>&nbsp;topic. For more information about asynchronous programming model used in this tutorial, see the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming\" target=\"_blank\">Task-based Asynchronous Programming</a>&nbsp;topic and the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/async\" target=\"_blank\">Asynchronous programming</a>&nbsp;topic.</p>"
          },
          {
            "Rest Client": "<p>\r\n\tThis tutorial teaches you a number of features in .NET Core and the C# language. You&rsquo;ll learn:</p>\r\n<ul>\r\n\t<li>\r\n\t\tThe basics of the .NET Core Command Line Interface (CLI).</li>\r\n\t<li>\r\n\t\tAn overview of C# Language features.</li>\r\n\t<li>\r\n\t\tManaging dependencies with NuGet</li>\r\n\t<li>\r\n\t\tHTTP Communications</li>\r\n\t<li>\r\n\t\tProcessing JSON information</li>\r\n\t<li>\r\n\t\tManaging configuration with Attributes.</li>\r\n</ul>\r\n<p>\r\n\tYou&rsquo;ll build an application that issues HTTP Requests to a REST service on GitHub. You&#39;ll read information in JSON format, and convert that JSON packet into C# objects. Finally, you&#39;ll see how to work with C# objects.</p>\r\n<p>\r\n\tThere are a lot of features in this tutorial. Let&rsquo;s build them one by one.</p>\r\n<p>\r\n\tIf you prefer to follow along with the&nbsp;<a href=\"https://github.com/dotnet/samples/tree/master/csharp/getting-started/console-webapiclient\" target=\"_blank\">final sample</a>&nbsp;for this topic, you can download it. For download instructions, see&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/samples-and-tutorials/index#viewing-and-downloading-samples\" target=\"_blank\">Samples and Tutorials</a>.</p>\r\n<h2>\r\n\tPrerequisites</h2>\r\n<h2>\r\n\t&nbsp;</h2>\r\n<p>\r\n\tYou&rsquo;ll need to set up your machine to run .NET core. You can find the installation instructions on the&nbsp;<a href=\"https://www.microsoft.com/net/core\" target=\"_blank\">.NET Core</a>&nbsp;page. You can run this application on Windows, Linux, macOS or in a Docker container. You&rsquo;ll need to install your favorite code editor. The descriptions below use&nbsp;<a href=\"https://code.visualstudio.com/\" target=\"_blank\">Visual Studio Code</a>, which is an open source, cross platform editor. However, you can use whatever tools you are comfortable with.</p>\r\n<h2>\r\n\tCreate the Application</h2>\r\n<h2>\r\n\t&nbsp;</h2>\r\n<p>\r\n\tThe first step is to create a new application. Open a command prompt and create a new directory for your application. Make that the current directory. Type the command&nbsp;<code>dotnet new console</code>&nbsp;at the command prompt. This creates the starter files for a basic &quot;Hello World&quot; application.</p>\r\n<p>\r\n\tBefore you start making modifications, let&rsquo;s go through the steps to run the simple Hello World application. After creating the application, type&nbsp;<code>dotnet restore</code>&nbsp;(<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/console-webapiclient#dotnet-restore-note\" target=\"_blank\">see note</a>) at the command prompt. This command runs the NuGet package restore process. NuGet is a .NET package manager. This command downloads any of the missing dependencies for your project. As this is a new project, none of the dependencies are in place, so the first run will download the .NET Core framework. After this initial step, you will only need to run&nbsp;<code>dotnet restore</code>&nbsp;(<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/console-webapiclient#dotnet-restore-note\" target=\"_blank\">see note</a>) when you add new dependent packages, or update the versions of any of your dependencies.</p>\r\n<p>\r\n\tAfter restoring packages, you run&nbsp;<code>dotnet build</code>. This executes the build engine and creates your application. Finally, you execute&nbsp;<code>dotnet run</code>&nbsp;to run your application.</p>\r\n<h2>\r\n\tAdding New Dependencies</h2>\r\n<h2>\r\n\t&nbsp;</h2>\r\n<p>\r\n\tOne of the key design goals for .NET Core is to minimize the size of the .NET installation. If an application needs additional libraries for some of its features, you add those dependencies into your C# project (*.csproj) file. For our example, you&#39;ll need to add the&nbsp;<code>System.Runtime.Serialization.Json</code>package so your application can process JSON responses.</p>\r\n<p>\r\n\tOpen your&nbsp;<code>csproj</code>&nbsp;project file. The first line of the file should appear as:</p>\r\n<div>\r\n\t<h2>\r\n\t\t<span>XML</span></h2>\r\n</div>\r\n<pre>\r\n<code><span>&lt;<span>Project</span> <span>Sdk</span>=<span>&quot;Microsoft.NET.Sdk&quot;</span>&gt;</span>\r\n</code></pre>\r\n<p>\r\n\tAdd the following immediately after this line:</p>\r\n<div>\r\n\t<span>XML</span></div>\r\n<pre>\r\n<code>   <span>&lt;<span>ItemGroup</span>&gt;</span>\r\n      <span>&lt;<span>PackageReference</span> <span>Include</span>=<span>&quot;System.Runtime.Serialization.Json&quot;</span> <span>Version</span>=<span>&quot;4.3.0&quot;</span> /&gt;</span>\r\n   <span>&lt;/<span>ItemGroup</span>&gt;</span> \r\n</code></pre>\r\n<p>\r\n\tMost code editors will provide completion for different versions of these libraries. You&#39;ll usually want to use the latest version of any package that you add. However, it is important to make sure that the versions of all packages match, and that they also match the version of the .NET Core Application framework.</p>\r\n<p>\r\n\tAfter you&#39;ve made these changes, you should run&nbsp;<code>dotnet restore</code>&nbsp;(<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/console-webapiclient#dotnet-restore-note\" target=\"_blank\">see note</a>) again so that the package is installed on your system.</p>\r\n<h2>\r\n\tMaking Web Requests</h2>\r\n<h2>\r\n\t&nbsp;</h2>\r\n<p>\r\n\tNow you&#39;re ready to start retrieving data from the web. In this application, you&#39;ll read information from the&nbsp;<a href=\"https://developer.github.com/v3/\" target=\"_blank\">GitHub API</a>. Let&#39;s read information about the projects under the&nbsp;<a href=\"https://www.dotnetfoundation.org/\" target=\"_blank\">.NET Foundation</a>&nbsp;umbrella. You&#39;ll start by making the request to the GitHub API to retrieve information on the projects. The endpoint you&#39;ll use is:&nbsp;<a href=\"https://api.github.com/orgs/dotnet/repos\" target=\"_blank\">https://api.github.com/orgs/dotnet/repos</a>. You want to retrieve all the information about these projects, so you&#39;ll use an HTTP GET request. Your browser also uses HTTP GET requests, so you can paste that URL into your browser to see what information you&#39;ll be receiving and processing.</p>\r\n<p>\r\n\tYou use the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient\" target=\"_blank\">HttpClient</a>&nbsp;class to make web requests. Like all modern .NET APIs,&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient\" target=\"_blank\">HttpClient</a>&nbsp;supports only async methods for its long-running APIs. Start by making an async method. You&#39;ll fill in the implementation as you build the functionality of the application. Start by opening the&nbsp;<code>program.cs</code>file in your project directory and adding the following method to the&nbsp;<code>Program</code>&nbsp;class:</p>\r\n<div>\r\n\t<h2>\r\n\t\t<span>C#</span></h2>\r\n</div>\r\n<pre>\r\n<code><span><span>private</span> <span>static</span> <span>async</span> Task <span>ProcessRepositories</span>()\r\n</span>{\r\n    \r\n}\r\n</code></pre>\r\n<p>\r\n\tYou&#39;ll need to add a&nbsp;<code>using</code>&nbsp;statement at the top of your&nbsp;<code>Main</code>&nbsp;method so that the C# compiler recognizes the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task\" target=\"_blank\">Task</a>&nbsp;type:</p>\r\n<div>\r\n\t<span>C#</span></div>\r\n<pre>\r\n<code><span>using</span> System.Threading.Tasks;\r\n</code></pre>\r\n<p>\r\n\tIf you build your project at this point, you&#39;ll get a warning generated for this method, because it does not contain any&nbsp;<code>await</code>&nbsp;operators and will run synchronously. Ignore that for now; you&#39;ll add&nbsp;<code>await</code>&nbsp;operators as you fill in the method.</p>\r\n<p>\r\n\tNext, rename the namespace defined in the&nbsp;<code>namespace</code>&nbsp;statement from its default of&nbsp;<code>ConsoleApp</code>&nbsp;to&nbsp;<code>WebAPIClient</code>. We&#39;ll later define a&nbsp;<code>repo</code>&nbsp;class in this namespace.</p>\r\n<p>\r\n\tNext, update the&nbsp;<code>Main</code>&nbsp;method to call this method. The&nbsp;<code>ProcessRepositories</code>&nbsp;method returns a Task, and you shouldn&#39;t exit the program before that task finishes. Therefore, you must use the&nbsp;<code>Wait</code>&nbsp;method to block and wait for the task to finish:</p>\r\n<div>\r\n\t<span>C#</span></div>\r\n<pre>\r\n<code><span><span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)\r\n</span>{\r\n    ProcessRepositories().Wait();\r\n}\r\n</code></pre>\r\n<p>\r\n\tNow, you have a program that does nothing, but does it asynchronously. Let&#39;s improve it.</p>\r\n<p>\r\n\tFirst you need an object that is capable to retrieve data from the web; you can use a&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient\" target=\"_blank\">HttpClient</a>&nbsp;to do that. This object handles the request and the responses. Instantiate a single instance of that type in the&nbsp;<code>Program</code>&nbsp;class inside the Program.cs file.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>namespace</span> <span>WebAPIClient</span>\r\n{\r\n    <span>class</span> <span>Program</span>\r\n    {\r\n        <span>private</span> <span>static</span> <span>readonly</span> HttpClient client = <span>new</span> HttpClient();\r\n\r\n        <span><span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)\r\n        </span>{\r\n            <span>//...</span>\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tLet&#39;s go back to the&nbsp;<code>ProcessRepositories</code>&nbsp;method and fill in a first version of it:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>private</span> <span>static</span> <span>async</span> Task <span>ProcessRepositories</span>()\r\n</span>{\r\n    client.DefaultRequestHeaders.Accept.Clear();\r\n    client.DefaultRequestHeaders.Accept.Add(\r\n        <span>new</span> MediaTypeWithQualityHeaderValue(<span>&quot;application/vnd.github.v3+json&quot;</span>));\r\n    client.DefaultRequestHeaders.Add(<span>&quot;User-Agent&quot;</span>, <span>&quot;.NET Foundation Repository Reporter&quot;</span>);\r\n\r\n    <span>var</span> stringTask = client.GetStringAsync(<span>&quot;https://api.github.com/orgs/dotnet/repos&quot;</span>);\r\n\r\n    <span>var</span> msg = <span>await</span> stringTask;\r\n    Console.Write(msg);\r\n}\r\n</code></pre>\r\n<p>\r\n\tYou&#39;ll need to also add two new using statements at the top of the file for this to compile:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System.Net.Http;\r\n<span>using</span> System.Net.Http.Headers;\r\n</code></pre>\r\n<p>\r\n\tThis first version makes a web request to read the list of all repositories under the dotnet foundation organization. (The gitHub ID for the .NET Foundation is &#39;dotnet&#39;). The first few lines set up the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient\" target=\"_blank\">HttpClient</a>&nbsp;for this request. First, it is configured to accept the GitHub JSON responses. This format is simply JSON. The next line adds a User Agent header to all requests from this object. These two headers are checked by the GitHub server code, and are necessary to retrieve information from GitHub.</p>\r\n<p>\r\n\tAfter you&#39;ve configured the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient\" target=\"_blank\">HttpClient</a>, you make a web request and retrieve the response. In this first version, you use the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient.getstringasync#System_Net_Http_HttpClient_GetStringAsync_System_String_\" target=\"_blank\">HttpClient.GetStringAsync(String)</a>&nbsp;convenience method. This convenience method starts a task that makes the web request, and then when the request returns, it reads the response stream and extracts the content from the stream. The body of the response is returned as a&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string\" target=\"_blank\">String</a>. The string is available when the task completes.</p>\r\n<p>\r\n\tThe final two lines of this method await that task, and then print the response to the console. Build the app, and run it. The build warning is gone now, because the&nbsp;<code>ProcessRepositories</code>&nbsp;now does contain an&nbsp;<code>await</code>&nbsp;operator. You&#39;ll see a long display of JSON formatted text.</p>\r\n<h2>\r\n\tProcessing the JSON Result</h2>\r\n<h2>\r\n\t&nbsp;</h2>\r\n<p>\r\n\tAt this point, you&#39;ve written the code to retrieve a response from a web server, and display the text that is contained in that response. Next, let&#39;s convert that JSON response into C# objects.</p>\r\n<p>\r\n\tThe JSON Serializer converts JSON data into C# Objects. Your first task is to define a C# class type to contain the information you use from this response. Let&#39;s build this slowly, so start with a simple C# type that contains the name of the repository:</p>\r\n<div>\r\n\t<h2>\r\n\t\t&nbsp;</h2>\r\n</div>\r\n<pre>\r\n<code><span>using</span> System;\r\n\r\n<span>namespace</span> <span>WebAPIClient</span>\r\n{\r\n    <span>public</span> <span>class</span> <span>repo</span>\r\n    {\r\n        <span>public</span> <span>string</span> name;\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tPut the above code in a new file called &#39;repo.cs&#39;. This version of the class represents the simplest path to process JSON data. The class name and the member name match the names used in the JSON packet, instead of following C# conventions. You&#39;ll fix that by providing some configuration attributes later. This class demonstrates another important feature of JSON serialization and deserialization: Not all the fields in the JSON packet are part of this class. The JSON serializer will ignore information that is not included in the class type being used. This feature makes it easier to create types that work with only a subset of the fields in the JSON packet.</p>\r\n<p>\r\n\tNow that you&#39;ve created the type, let&#39;s deserialize it. You&#39;ll need to create a<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.json.datacontractjsonserializer\" target=\"_blank\">DataContractJsonSerializer</a>&nbsp;object. This object must know the CLR type expected for the JSON packet it retrieves. The packet from GitHub contains a sequence of repositories, so a&nbsp;<code>List&lt;repo&gt;</code>&nbsp;is the correct type. Add the following line to your&nbsp;<code>ProcessRepositories</code>&nbsp;method:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>var</span> serializer = <span>new</span> DataContractJsonSerializer(<span>typeof</span>(List&lt;repo&gt;));\r\n</code></pre>\r\n<p>\r\n\tYou&#39;re using two new namespaces, so you&#39;ll need to add those as well:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System.Collections.Generic;\r\n<span>using</span> System.Runtime.Serialization.Json;\r\n</code></pre>\r\n<p>\r\n\tNext, you&#39;ll use the serializer to convert JSON into C# objects. Replace the call to<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient.getstringasync#System_Net_Http_HttpClient_GetStringAsync_System_String_\" target=\"_blank\">GetStringAsync(String)</a>&nbsp;in your&nbsp;<code>ProcessRepositories</code>&nbsp;method with the following two lines:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>var</span> streamTask = client.GetStreamAsync(<span>&quot;https://api.github.com/orgs/dotnet/repos&quot;</span>);\r\n<span>var</span> repositories = serializer.ReadObject(<span>await</span> streamTask) <span>as</span> List&lt;repo&gt;;\r\n</code></pre>\r\n<p>\r\n\tNotice that you&#39;re now using&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient.getstreamasync#System_Net_Http_HttpClient_GetStreamAsync_System_String_\" target=\"_blank\">GetStreamAsync(String)</a>&nbsp;instead of&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient.getstringasync#System_Net_Http_HttpClient_GetStringAsync_System_String_\" target=\"_blank\">GetStringAsync(String)</a>. The serializer uses a stream instead of a string as its source. Let&#39;s explain a couple features of the C# language that are being used in the second line above. The argument to&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.json.datacontractjsonserializer.readobject#System_Runtime_Serialization_Json_DataContractJsonSerializer_ReadObject_System_IO_Stream_\" target=\"_blank\">ReadObject(Stream)</a>&nbsp;is an&nbsp;<code>await</code>&nbsp;expression. Await expressions can appear almost anywhere in your code, even though up to now, you&#39;ve only seen them as part of an assignment statement.</p>\r\n<p>\r\n\tSecondly, the&nbsp;<code>as</code>&nbsp;operator converts from the compile time type of&nbsp;<code>object</code>&nbsp;to&nbsp;<code>List&lt;repo&gt;</code>. The declaration of&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.json.datacontractjsonserializer.readobject#System_Runtime_Serialization_Json_DataContractJsonSerializer_ReadObject_System_IO_Stream_\" target=\"_blank\">ReadObject(Stream)</a>&nbsp;declares that it returns an object of type&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.object\" target=\"_blank\">System.Object</a>.&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.json.datacontractjsonserializer.readobject#System_Runtime_Serialization_Json_DataContractJsonSerializer_ReadObject_System_IO_Stream_\" target=\"_blank\">ReadObject(Stream)</a>&nbsp;will return the type you specified when you constructed it (<code>List&lt;repo&gt;</code>&nbsp;in this tutorial). If the conversion does not succeed, the&nbsp;<code>as</code>&nbsp;operator evaluates to&nbsp;<code>null</code>, instead of throwing an exception.</p>\r\n<p>\r\n\tYou&#39;re almost done with this section. Now that you&#39;ve converted the JSON to C# objects, let&#39;s display the name of each repository. Replace the lines that read:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>var</span> msg = <span>await</span> stringTask;   <span>//**Deleted this</span>\r\nConsole.Write(msg);\r\n</code></pre>\r\n<p>\r\n\twith the following:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>foreach</span> (<span>var</span> repo <span>in</span> repositories)\r\n    Console.WriteLine(repo.name);\r\n</code></pre>\r\n<p>\r\n\tCompile and run the application. It will print out the names of the repositories that are part of the .NET Foundation.</p>\r\n<h2>\r\n\tControlling Serialization</h2>\r\n<h2>\r\n\t&nbsp;</h2>\r\n<p>\r\n\tBefore you add more features, let&#39;s address the&nbsp;<code>repo</code>&nbsp;type and make it follow more standard C# conventions. You&#39;ll do this by annotating the&nbsp;<code>repo</code>&nbsp;type with&nbsp;<em>attributes</em>&nbsp;that control how the JSON Serializer works. In your case, you&#39;ll use these attributes to define a mapping between the JSON key names and the C# class and member names. The two attributes used are the&nbsp;<code>DataContract</code>attribute and the&nbsp;<code>DataMember</code>&nbsp;attribute. By convention, all Attribute classes end in the suffix&nbsp;<code>Attribute</code>. However, you do not need to use that suffix when you apply an attribute.</p>\r\n<p>\r\n\tThe&nbsp;<code>DataContract</code>&nbsp;and&nbsp;<code>DataMember</code>&nbsp;attributes are in a different library, so you&#39;ll need to add that library to your C# project file as a dependency. Add the following line to the&nbsp;<code>&lt;ItemGroup&gt;</code>&nbsp;section of your project file:</p>\r\n<div>\r\n\t<h2>\r\n\t\t<span>XML</span></h2>\r\n</div>\r\n<pre>\r\n<code><span>&lt;<span>PackageReference</span> <span>Include</span>=<span>&quot;System.Runtime.Serialization.Primitives&quot;</span> <span>Version</span>=<span>&quot;4.3.0&quot;</span> /&gt;</span>\r\n</code></pre>\r\n<p>\r\n\tAfter you save the file, run&nbsp;<code>dotnet restore</code>&nbsp;(<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/console-webapiclient#dotnet-restore-note\" target=\"_blank\">see note</a>) to retrieve this package.</p>\r\n<p>\r\n\tNext, open the&nbsp;<code>repo.cs</code>&nbsp;file. Let&#39;s change the name to use Pascal Case, and fully spell out the name&nbsp;<code>Repository</code>. We still want to map JSON &#39;repo&#39; nodes to this type, so you&#39;ll need to add the&nbsp;<code>DataContract</code>&nbsp;attribute to the class declaration. You&#39;ll set the&nbsp;<code>Name</code>&nbsp;property of the attribute to the name of the JSON nodes that map to this type:</p>\r\n<div>\r\n\t<span>C#</span></div>\r\n<pre>\r\n<code>[<span>DataContract(Name=<span>&quot;repo&quot;</span>)</span>]\r\n<span>public</span> <span>class</span> <span>Repository</span>\r\n</code></pre>\r\n<p>\r\n\tThe&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.datacontractattribute\" target=\"_blank\">DataContractAttribute</a>&nbsp;is a member of the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization\" target=\"_blank\">System.Runtime.Serialization</a>&nbsp;namespace, so you&#39;ll need to add the appropriate&nbsp;<code>using</code>&nbsp;statement at the top of the file:</p>\r\n<div>\r\n\t<span>C#</span></div>\r\n<pre>\r\n<code><span>using</span> System.Runtime.Serialization;\r\n</code></pre>\r\n<p>\r\n\tYou changed the name of the&nbsp;<code>repo</code>&nbsp;class to&nbsp;<code>Repository</code>, so you&#39;ll need to make the same name change in Program.cs (some editors may support a rename refactoring that will make this change automatically:)</p>\r\n<div>\r\n\t<span>C#</span></div>\r\n<pre>\r\n<code><span>var</span> serializer = <span>new</span> DataContractJsonSerializer(<span>typeof</span>(List&lt;Repository&gt;));\r\n\r\n<span>// ...</span>\r\n\r\n<span>var</span> repositories = serializer.ReadObject(<span>await</span> streamTask) <span>as</span> List&lt;Repository&gt;;\r\n</code></pre>\r\n<p>\r\n\tNext, let&#39;s make the same change with the&nbsp;<code>name</code>&nbsp;field by using the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.datamemberattribute\" target=\"_blank\">DataMemberAttribute</a>&nbsp;class. Make the following changes to the declaration of the&nbsp;<code>name</code>&nbsp;field in repo.cs:</p>\r\n<div>\r\n\t<span>C#</span></div>\r\n<pre>\r\n<code>[<span>DataMember(Name=<span>&quot;name&quot;</span>)</span>]\r\n<span>public</span> <span>string</span> Name;\r\n</code></pre>\r\n<p>\r\n\tThis change means you need to change the code that writes the name of each repository in program.cs:</p>\r\n<div>\r\n\t<span>C#</span></div>\r\n<pre>\r\n<code>Console.WriteLine(repo.Name);\r\n</code></pre>\r\n<p>\r\n\tDo a&nbsp;<code>dotnet build</code>&nbsp;followed by a&nbsp;<code>dotnet run</code>&nbsp;to make sure you&#39;ve got the mappings correct. You should see the same output as before. Before we process more properties from the web server, let&#39;s make one more change to the&nbsp;<code>Repository</code>&nbsp;class. The&nbsp;<code>Name</code>&nbsp;member is a publicly accessible field. That&#39;s not a good object-oriented practice, so let&#39;s change it to a property. For our purposes, we don&#39;t need any specific code to run when getting or setting the property, but changing to a property makes it easier to add those changes later without breaking any code that uses the&nbsp;<code>Repository</code>&nbsp;class.</p>\r\n<p>\r\n\tRemove the field definition, and replace it with an&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/auto-implemented-properties\" target=\"_blank\">auto-implemented property</a>:</p>\r\n<pre>\r\n<code><span>public</span> <span>string</span> Name { <span>get</span>; <span>set</span>; }\r\n</code></pre>\r\n<p>\r\n\tThe compiler generates the body of the&nbsp;<code>get</code>&nbsp;and&nbsp;<code>set</code>&nbsp;accessors, as well as a private field to store the name. It would be similar to the following code that you could type by hand:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>string</span> Name \r\n{ \r\n    <span>get</span> { <span>return</span> <span>this</span>._name; }\r\n    <span>set</span> { <span>this</span>._name = <span>value</span>; }\r\n}\r\n<span>private</span> <span>string</span> _name;\r\n</code></pre>\r\n<p>\r\n\tLet&#39;s make one more change before adding new features. The&nbsp;<code>ProcessRepositories</code>&nbsp;method can do the async work and return a collection of the repositories. Let&#39;s return the&nbsp;<code>List&lt;Repository&gt;</code>&nbsp;from that method, and move the code that writes the information into the&nbsp;<code>Main</code>&nbsp;method.</p>\r\n<p>\r\n\tChange the signature of&nbsp;<code>ProcessRepositories</code>&nbsp;to return a task whose result is a list of&nbsp;<code>Repository</code>objects:</p>\r\n<pre>\r\n<code><span>private</span> <span>static</span> <span>async</span> Task&lt;List&lt;Repository&gt;&gt; ProcessRepositories()\r\n</code></pre>\r\n<p>\r\n\tThen, just return the repositories after processing the JSON response:</p>\r\n<pre>\r\n<code><span>var</span> repositories = serializer.ReadObject(<span>await</span> streamTask) <span>as</span> List&lt;Repository&gt;;\r\n<span>return</span> repositories;\r\n</code></pre>\r\n<p>\r\n\tThe compiler generates the&nbsp;<code>Task&lt;T&gt;</code>&nbsp;object for the return because you&#39;ve marked this method as&nbsp;<code>async</code>. Then, let&#39;s modify the&nbsp;<code>Main</code>&nbsp;method so that it captures those results and writes each repository name to the console. Your&nbsp;<code>Main</code>&nbsp;method now looks like this:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)\r\n</span>{\r\n    <span>var</span> repositories = ProcessRepositories().Result;\r\n\r\n    <span>foreach</span> (<span>var</span> repo <span>in</span> repositories)\r\n        Console.WriteLine(repo.Name);\r\n}\r\n</code></pre>\r\n<p>\r\n\tAccessing the&nbsp;<code>Result</code>&nbsp;property of a Task blocks until the task has completed. Normally, you would prefer to&nbsp;<code>await</code>&nbsp;the completion of the task, as in the&nbsp;<code>ProcessRepositories</code>&nbsp;method, but that isn&#39;t allowed in the&nbsp;<code>Main</code>&nbsp;method.</p>\r\n<h2>\r\n\tReading More Information</h2>\r\n<h2>\r\n\t&nbsp;</h2>\r\n<p>\r\n\tLet&#39;s finish this by processing a few more of the properties in the JSON packet that gets sent from the GitHub API. You won&#39;t want to grab everything, but adding a few properties will demonstrate a few more features of the C# language.</p>\r\n<p>\r\n\tLet&#39;s start by adding a few more simple types to the&nbsp;<code>Repository</code>&nbsp;class definition. Add these properties to that class:</p>\r\n<pre>\r\n<code>[<span>DataMember(Name=<span>&quot;description&quot;</span>)</span>]\r\n<span>public</span> <span>string</span> Description { <span>get</span>; <span>set</span>; }\r\n\r\n[<span>DataMember(Name=<span>&quot;html_url&quot;</span>)</span>]\r\n<span>public</span> Uri GitHubHomeUrl { <span>get</span>; <span>set</span>; }\r\n\r\n[<span>DataMember(Name=<span>&quot;homepage&quot;</span>)</span>]\r\n<span>public</span> Uri Homepage { <span>get</span>; <span>set</span>; }\r\n\r\n[<span>DataMember(Name=<span>&quot;watchers&quot;</span>)</span>]\r\n<span>public</span> <span>int</span> Watchers { <span>get</span>; <span>set</span>; }\r\n</code></pre>\r\n<p>\r\n\tThese properties have built-in conversions from the string type (which is what the JSON packets contain) to the target type. The&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.uri\" target=\"_blank\">Uri</a>&nbsp;type may be new to you. It represents a URI, or in this case, a URL. In the case of the&nbsp;<code>Uri</code>&nbsp;and&nbsp;<code>int</code>&nbsp;types, if the JSON packet contains data that does not convert to the target type, the serialization action will throw an exception.</p>\r\n<p>\r\n\tOnce you&#39;ve added these, update the&nbsp;<code>Main</code>&nbsp;method to display those elements:</p>\r\n<pre>\r\n<code><span>foreach</span> (<span>var</span> repo <span>in</span> repositories)\r\n{\r\n    Console.WriteLine(repo.Name);\r\n    Console.WriteLine(repo.Description);\r\n    Console.WriteLine(repo.GitHubHomeUrl);\r\n    Console.WriteLine(repo.Homepage);\r\n    Console.WriteLine(repo.Watchers);\r\n    Console.WriteLine();\r\n}\r\n</code></pre>\r\n<p>\r\n\tAs a final step, let&#39;s add the information for the last push operation. This information is formatted in this fashion in the JSON response:</p>\r\n<div>\r\n\t<span>JSON</span></div>\r\n<pre>\r\n<code><span>2016</span><span>-02</span><span>-08</span>T<span>2</span><span>1</span>:<span>27</span>:<span>00</span>Z\r\n</code></pre>\r\n<p>\r\n\tThat format does not follow any of the standard .NET&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.datetime\" target=\"_blank\">DateTime</a>&nbsp;formats. Because of that, you&#39;ll need to write a custom conversion method. You also probably don&#39;t want the raw string exposed to users of the&nbsp;<code>Repository</code>&nbsp;class. Attributes can help control that as well. First, define a&nbsp;<code>private</code>&nbsp;property that will hold the string representation of the date time in your&nbsp;<code>Repository</code>&nbsp;class:</p>\r\n<div>\r\n\t<span>C#</span></div>\r\n<pre>\r\n<code>[<span>DataMember(Name=<span>&quot;pushed_at&quot;</span>)</span>]\r\n<span>private</span> <span>string</span> JsonDate { <span>get</span>; <span>set</span>; }\r\n</code></pre>\r\n<p>\r\n\tThe&nbsp;<code>DataMember</code>&nbsp;attribute informs the serializer that this should be processed, even though it is not a public member. Next, you need to write a public read-only property that converts the string to a valid&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.datetime\" target=\"_blank\">DateTime</a>&nbsp;object, and returns that&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.datetime\" target=\"_blank\">DateTime</a>:</p>\r\n<pre>\r\n<code>[<span>IgnoreDataMember</span>]\r\n<span>public</span> DateTime LastPush\r\n{\r\n    <span>get</span>\r\n    {\r\n        <span>return</span> DateTime.ParseExact(JsonDate, <span>&quot;yyyy-MM-ddTHH:mm:ssZ&quot;</span>, CultureInfo.InvariantCulture);\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tLet&#39;s go over the new constructs above. The&nbsp;<code>IgnoreDataMember</code>&nbsp;attribute instructs the serializer that this type should not be read to or written from any JSON object. This property contains only a&nbsp;<code>get</code>accessor. There is no&nbsp;<code>set</code>&nbsp;accessor. That&#39;s how you define a&nbsp;<em>read-only</em>&nbsp;property in C#. (Yes, you can create&nbsp;<em>write-only</em>&nbsp;properties in C#, but their value is limited.) The&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.datetime.parseexact#System_DateTime_ParseExact_System_String_System_String_System_IFormatProvider_\" target=\"_blank\">ParseExact(String, String, IFormatProvider)</a>&nbsp;method parses a string and creates a&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.datetime\" target=\"_blank\">DateTime</a>&nbsp;object using a provided date format, and adds additional metadata to the&nbsp;<code>DateTime</code>&nbsp;using a&nbsp;<code>CultureInfo</code>&nbsp;object. If the parse operation fails, the property accessor throws an exception.</p>\r\n<p>\r\n\tTo use&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.globalization.cultureinfo.invariantculture#System_Globalization_CultureInfo_InvariantCulture\" target=\"_blank\">InvariantCulture</a>, you will need to add the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.globalization\" target=\"_blank\">System.Globalization</a>&nbsp;namespace to the&nbsp;<code>using</code>statements in&nbsp;<code>repo.cs</code>:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System.Globalization;\r\n</code></pre>\r\n<p>\r\n\tFinally, add one more output statement in the console, and you&#39;re ready to build and run this app again:</p>\r\n<pre>\r\n<code>Console.WriteLine(repo.LastPush);\r\n</code></pre>\r\n<p>\r\n\tYour version should now match the&nbsp;<a href=\"https://github.com/dotnet/samples/tree/master/csharp/getting-started/console-webapiclient\" target=\"_blank\">finished sample</a>.</p>"
          },
          {
            "Using Attributes in C#": "<p>\r\n\tAttributes provide a way of associating information with code in a declarative way. They can also provide a reusable element that can be applied to a variety of targets.</p>\r\n<p>\r\n\tConsider the&nbsp;<code>[Obsolete]</code>&nbsp;attribute. It can be applied to classes, structs, methods, constructors, and more. It&nbsp;<em>declares</em>&nbsp;that the element is obsolete. It&#39;s then up to the C# compiler to look for this attribute, and do some action in response.</p>\r\n<p>\r\n\tIn this tutorial, you&#39;ll be introduced to how to add attributes to your code, how to create and use your own attributes, and how to use some attributes that are built into .NET Core.</p>\r\n<h2>\r\n\tPrerequisites</h2>\r\n<p>\r\n\tYou&rsquo;ll need to setup your machine to run .NET core. You can find the installation instructions on the&nbsp;<a href=\"https://www.microsoft.com/net/core\" target=\"_blank\">.NET Core</a>&nbsp;page. You can run this application on Windows, Ubuntu Linux, macOS or in a Docker container. You&rsquo;ll need to install your favorite code editor. The descriptions below use&nbsp;<a href=\"https://code.visualstudio.com/\" target=\"_blank\">Visual Studio Code</a>&nbsp;which is an open source, cross platform editor. However, you can use whatever tools you are comfortable with.</p>\r\n<h2>\r\n\tCreate the Application</h2>\r\n<p>\r\n\tNow that you&#39;ve installed all the tools, create a new .NET Core application. To use the command line generator, execute the following command in your favorite shell:</p>\r\n<p>\r\n\t<code>dotnet new console</code></p>\r\n<p>\r\n\tThis command will create barebones .NET core project files. You will need to execute&nbsp;<code>dotnet restore</code>&nbsp;to restore the dependencies needed to compile this project.</p>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tStarting with .NET Core 2.0 SDK, you don&#39;t have to run&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-restore\" target=\"_blank\"><code>dotnet restore</code></a>&nbsp;because it&#39;s run implicitly by all commands that require a restore to occur, such as&nbsp;<code>dotnet new</code>,&nbsp;<code>dotnet build</code>and&nbsp;<code>dotnet run</code>. It&#39;s still a valid command in certain scenarios where doing an explicit restore makes sense, such as&nbsp;<a href=\"https://docs.microsoft.com/azure/devops/build-release/apps/aspnet/build-aspnet-core\" target=\"_blank\">continuous integration builds in Azure DevOps Services</a>&nbsp;or in build systems that need to explicitly control the time at which the restore occurs.</p>\r\n</div>\r\n<p>\r\n\tTo execute the program, use&nbsp;<code>dotnet run</code>. You should see &quot;Hello, World&quot; output to the console.</p>\r\n<h2>\r\n\tHow to add attributes to code</h2>\r\n<p>\r\n\tIn C#, attributes are classes that inherit from the&nbsp;<code>Attribute</code>&nbsp;base class. Any class that inherits from&nbsp;<code>Attribute</code>&nbsp;can be used as a sort of &quot;tag&quot; on other pieces of code. For instance, there is an attribute called&nbsp;<code>ObsoleteAttribute</code>. This is used to signal that code is obsolete and shouldn&#39;t be used anymore. You can place this attribute on a class, for instance, by using square brackets.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>[<span>Obsolete</span>]\r\n<span>public</span> <span>class</span> <span>MyClass</span>\r\n{\r\n\r\n}\r\n</code></pre>\r\n<p>\r\n\tNote that while the class is called&nbsp;<code>ObsoleteAttribute</code>, it&#39;s only necessary to use&nbsp;<code>[Obsolete]</code>&nbsp;in the code. This is a convention that C# follows. You can use the full name&nbsp;<code>[ObsoleteAttribute]</code>&nbsp;if you choose.</p>\r\n<p>\r\n\tWhen marking a class obsolete, it&#39;s a good idea to provide some information as to&nbsp;<em>why</em>&nbsp;it&#39;s obsolete, and/or&nbsp;<em>what</em>&nbsp;to use instead. Do this by passing a string parameter to the Obsolete attribute.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>[<span>Obsolete(<span>&quot;ThisClass is obsolete. Use ThisClass2 instead.&quot;</span>)</span>]\r\n<span>public</span> <span>class</span> <span>ThisClass</span>\r\n{\r\n\r\n}\r\n</code></pre>\r\n<p>\r\n\tThe string is being passed as an argument to an&nbsp;<code>ObsoleteAttribute</code>&nbsp;constructor, just as if you were writing&nbsp;<code>var attr = new ObsoleteAttribute(&quot;some string&quot;)</code>.</p>\r\n<p>\r\n\tParameters to an attribute constructor are limited to simple types/literals:&nbsp;<code>bool, int, double, string, Type, enums, etc</code>&nbsp;and arrays of those types. You can not use an expression or a variable. You are free to use positional or named parameters.</p>\r\n<h2>\r\n\tHow to create your own attribute</h2>\r\n<p>\r\n\tCreating an attribute is as simple as inheriting from the&nbsp;<code>Attribute</code>&nbsp;base class.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>class</span> <span>MySpecialAttribute</span> : <span>Attribute</span>\r\n{\r\n\r\n}\r\n</code></pre>\r\n<p>\r\n\tWith the above, I can now use&nbsp;<code>[MySpecial]</code>&nbsp;(or&nbsp;<code>[MySpecialAttribute]</code>) as an attribute elsewhere in the code base.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>[<span>MySpecial</span>]\r\n<span>public</span> <span>class</span> <span>SomeOtherClass</span>\r\n{\r\n\r\n}\r\n</code></pre>\r\n<p>\r\n\tAttributes in the .NET base class library like&nbsp;<code>ObsoleteAttribute</code>&nbsp;trigger certain behaviors within the compiler. However, any attribute you create acts only as metadata, and doesn&#39;t result in any code within the attribute class being executed. It&#39;s up to you to act on that metadata elsewhere in your code (more on that later in the tutorial).</p>\r\n<p>\r\n\tThere is a &#39;gotcha&#39; here to watch out for. As mentioned above, only certain types are allowed to be passed as arguments when using attributes. However, when creating an attribute type, the C# compiler won&#39;t stop you from creating those parameters. In the below example, I&#39;ve created an attribute with a constructor that compiles just fine.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>class</span> <span>GotchaAttribute</span> : <span>Attribute</span>\r\n{\r\n    <span><span>public</span> <span>GotchaAttribute</span>(<span>Foo myClass, <span>string</span> str</span>) </span>{\r\n        \r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tHowever, you will be unable to use this constructor with attribute syntax.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>[<span>Gotcha(new Foo(), <span>&quot;test&quot;</span>)</span>] <span>// does not compile</span>\r\n<span>public</span> <span>class</span> <span>AttributeFail</span>\r\n{\r\n\r\n}\r\n</code></pre>\r\n<p>\r\n\tThe above will cause a compiler error like&nbsp;<code>Attribute constructor parameter &#39;myClass&#39; has type &#39;Foo&#39;, which is not a valid attribute parameter type</code></p>\r\n<h2>\r\n\tHow to restrict attribute usage</h2>\r\n<p>\r\n\tAttributes can be used on a number of &quot;targets&quot;. The above examples show them on classes, but they can also be used on:</p>\r\n<ul>\r\n\t<li>\r\n\t\tAssembly</li>\r\n\t<li>\r\n\t\tClass</li>\r\n\t<li>\r\n\t\tConstructor</li>\r\n\t<li>\r\n\t\tDelegate</li>\r\n\t<li>\r\n\t\tEnum</li>\r\n\t<li>\r\n\t\tEvent</li>\r\n\t<li>\r\n\t\tField</li>\r\n\t<li>\r\n\t\tGenericParameter</li>\r\n\t<li>\r\n\t\tInterface</li>\r\n\t<li>\r\n\t\tMethod</li>\r\n\t<li>\r\n\t\tModule</li>\r\n\t<li>\r\n\t\tParameter</li>\r\n\t<li>\r\n\t\tProperty</li>\r\n\t<li>\r\n\t\tReturnValue</li>\r\n\t<li>\r\n\t\tStruct</li>\r\n</ul>\r\n<p>\r\n\tWhen you create an attribute class, by default, C# will allow you to use that attribute on any of the possible attribute targets. If you want to restrict your attribute to certain targets, you can do so by using the&nbsp;<code>AttributeUsageAttribute</code>&nbsp;on your attribute class. That&#39;s right, an attribute on an attribute!</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>[<span>AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)</span>]\r\n<span>public</span> <span>class</span> <span>MyAttributeForClassAndStructOnly</span> : <span>Attribute</span>\r\n{\r\n\r\n}\r\n</code></pre>\r\n<p>\r\n\tIf you attempt to put the above attribute on something that&#39;s not a class or a struct, you will get a compiler error like&nbsp;<code>Attribute &#39;MyAttributeForClassAndStructOnly&#39; is not valid on this declaration type. It is only valid on &#39;class, struct&#39; declarations</code></p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>class</span> <span>Foo</span>\r\n{\r\n    <span>// if the below attribute was uncommented, it would cause a compiler error</span>\r\n    <span>// [MyAttributeForClassAndStructOnly]</span>\r\n    <span><span>public</span> <span>Foo</span>() \r\n    </span>{ }\r\n}\r\n</code></pre>\r\n<h2>\r\n\tHow to use attributes attached to a code element</h2>\r\n<p>\r\n\tAttributes act as metadata. Without some outward force, they won&#39;t actually do anything.</p>\r\n<p>\r\n\tTo find and act on attributes,&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/reflection\" target=\"_blank\">Reflection</a>&nbsp;is generally needed. I won&#39;t cover Reflection in-depth in this tutorial, but the basic idea is that Reflection allows you to write code in C# that examines other code.</p>\r\n<p>\r\n\tFor instance, you can use Reflection to get information about a class:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>TypeInfo typeInfo = <span>typeof</span>(MyClass).GetTypeInfo();\r\nConsole.WriteLine(<span>&quot;The assembly qualified name of MyClass is &quot;</span> + typeInfo.AssemblyQualifiedName);\r\n</code></pre>\r\n<p>\r\n\tThat will print out something like:&nbsp;<code>The assembly qualified name of MyClass is ConsoleApplication.MyClass, attributes, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null</code></p>\r\n<p>\r\n\tOnce you have a&nbsp;<code>TypeInfo</code>&nbsp;object (or a&nbsp;<code>MemberInfo</code>,&nbsp;<code>FieldInfo</code>, etc), you can use the&nbsp;<code>GetCustomAttributes</code>&nbsp;method. This will return a collection of&nbsp;<code>Attribute</code>&nbsp;objects. You can also use&nbsp;<code>GetCustomAttribute</code>&nbsp;and specify an Attribute type.</p>\r\n<p>\r\n\tHere&#39;s an example of using&nbsp;<code>GetCustomAttributes</code>&nbsp;on a&nbsp;<code>MemberInfo</code>&nbsp;instance for&nbsp;<code>MyClass</code>&nbsp;(which we saw earlier has an&nbsp;<code>[Obsolete]</code>&nbsp;attribute on it).</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>var</span> attrs = typeInfo.GetCustomAttributes();\r\n<span>foreach</span>(<span>var</span> attr <span>in</span> attrs)\r\n    Console.WriteLine(<span>&quot;Attribute on MyClass: &quot;</span> + attr.GetType().Name);\r\n</code></pre>\r\n<p>\r\n\tThat will print to console:&nbsp;<code>Attribute on MyClass: ObsoleteAttribute</code>. Try adding other attributes to&nbsp;<code>MyClass</code>.</p>\r\n<p>\r\n\tIt&#39;s important to note that these&nbsp;<code>Attribute</code>&nbsp;objects are instantiated lazily. That is, they won&#39;t be instantiated until you use&nbsp;<code>GetCustomAttribute</code>&nbsp;or&nbsp;<code>GetCustomAttributes</code>. They are also instantiated each time. Calling&nbsp;<code>GetCustomAttributes</code>&nbsp;twice in a row will return two different instances of&nbsp;<code>ObsoleteAttribute</code>.</p>\r\n<h2>\r\n\tCommon attributes in the base class library (BCL)</h2>\r\n<p>\r\n\tAttributes are used by many tools and frameworks. NUnit uses attributes like&nbsp;<code>[Test]</code>&nbsp;and&nbsp;<code>[TestFixture]</code>&nbsp;that are used by the NUnit test runner. ASP.NET MVC uses attributes like&nbsp;<code>[Authorize]</code>&nbsp;and provides an action filter framework to perform cross-cutting concerns on MVC actions.&nbsp;<a href=\"https://www.postsharp.net/\" target=\"_blank\">PostSharp</a>&nbsp;uses the attribute syntax to allow aspect-oriented programming in C#.</p>\r\n<p>\r\n\tHere are a few notable attributes built into the .NET Core base class libraries:</p>\r\n<ul>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\t<code>[Obsolete]</code>. This one was used in the above examples, and it lives in the&nbsp;<code>System</code>&nbsp;namespace. It is useful to provide declarative documentation about a changing code base. A message can be provided in the form of a string, and another boolean parameter can be used to escalate from a compiler warning to a compiler error.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\t<code>[Conditional]</code>. This attribute is in the&nbsp;<code>System.Diagnostics</code>&nbsp;namespace. This attribute can be applied to methods (or attribute classes). You must pass a string to the constructor. If that string matches a&nbsp;<code>#define</code>&nbsp;directive, then any calls to that method (but not the method itself) will be removed by the C# compiler. Typically this is used for debugging (diagnostics) purposes.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\t<code>[CallerMemberName]</code>. This attribute can be used on parameters, and lives in the&nbsp;<code>System.Runtime.CompilerServices</code>&nbsp;namespace. This is an attribute that is used to inject the name of the method that is calling another method. This is typically used as a way to eliminate &#39;magic strings&#39; when implementing INotifyPropertyChanged in various UI frameworks. As an example:</p>\r\n\t</li>\r\n</ul>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>class</span> <span>MyUIClass</span> : <span>INotifyPropertyChanged</span>\r\n{\r\n    <span>public</span> <span>event</span> PropertyChangedEventHandler PropertyChanged;\r\n\r\n    <span><span>public</span> <span>void</span> <span>RaisePropertyChanged</span>(<span>[CallerMemberName] <span>string</span> propertyName = <span>null</span></span>)\r\n    </span>{\r\n        PropertyChanged?.Invoke(<span>this</span>, <span>new</span> PropertyChangedEventArgs(propertyName));\r\n    }\r\n\r\n    <span>private</span> <span>string</span> _name;\r\n    <span>public</span> <span>string</span> Name \r\n    {\r\n        <span>get</span> { <span>return</span> _name;}\r\n        <span>set</span> \r\n        {\r\n            <span>if</span> (<span>value</span> != _name) \r\n            {\r\n                _name = <span>value</span>;\r\n                RaisePropertyChanged();   <span>// notice that &quot;Name&quot; is not needed here explicitly</span>\r\n            }\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tIn the above code, you don&#39;t have to have a literal&nbsp;<code>&quot;Name&quot;</code>&nbsp;string. This can help prevent typo-related bugs and also makes for smoother refactoring/renaming.</p>"
          },
          {
            "String Interpolation": "<p>\r\n\tThis tutorial shows you how to use&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated\" target=\"_blank\">string interpolation</a>&nbsp;to format and include expression results in a result string. The examples assume that you are familiar with basic C# concepts and .NET type formatting. If you are new to string interpolation or .NET type formatting, check out the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/intro-to-csharp/interpolated-strings\" target=\"_blank\">interactive string interpolation tutorial</a>&nbsp;first. For more information about formatting types in .NET, see the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/base-types/formatting-types\" target=\"_blank\">Formatting Types in .NET</a>&nbsp;topic.</p>\r\n<div>\r\n\t<p>\r\n\t\tThe C# examples in this article run in the&nbsp;<a href=\"https://try.dot.net/\" target=\"_blank\">Try.NET</a>&nbsp;inline code runner and playground. Select the&nbsp;<span>Run</span>&nbsp;button to run an example in an interactive window. Once you execute the code, you can modify it and run the modified code by selecting&nbsp;<span>Run</span>&nbsp;again. The modified code either runs in the interactive window or, if compilation fails, the interactive window displays all C# compiler error messages.</p>\r\n</div>\r\n<h2>\r\n\tIntroduction</h2>\r\n<p>\r\n\tThe&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated\" target=\"_blank\">string interpolation</a>&nbsp;feature is built on top of the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/base-types/composite-formatting\" target=\"_blank\">composite formatting</a>&nbsp;feature and provides a more readable and convenient syntax to include formatted expression results in a result string.</p>\r\n<p>\r\n\tTo identify a string literal as an interpolated string, prepend it with the&nbsp;<code>$</code>&nbsp;symbol. You can embed any valid C# expression that returns a value in an interpolated string. In the following example, as soon as an expression is evaluated, its result is converted into a string and included in a result string:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>double</span> a = <span>3</span>;\r\n<span>double</span> b = <span>4</span>;\r\nConsole.WriteLine(<span>$&quot;Area of the right triangle with legs of <span>{a}</span> and <span>{b}</span> is <span>{<span>0.5</span> * a * b}</span>&quot;</span>);\r\nConsole.WriteLine(<span>$&quot;Length of the hypotenuse of the right triangle with legs of <span>{a}</span> and <span>{b}</span> is <span>{CalculateHypotenuse(a, b)}</span>&quot;</span>);\r\n\r\n<span><span>double</span> <span>CalculateHypotenuse</span>(<span><span>double</span> leg1, <span>double</span> leg2</span>) </span>=&gt; Math.Sqrt(leg1 * leg1 + leg2 * leg2);\r\n\r\n<span>// Expected output:</span>\r\n<span>// Area of the right triangle with legs of 3 and 4 is 6</span>\r\n<span>// Length of the hypotenuse of the right triangle with legs of 3 and 4 is 5</span>\r\n</code></pre>\r\n<p>\r\n\tAs the example shows, you include an expression in an interpolated string by enclosing it with braces:</p>\r\n<pre>\r\n<code>{&lt;interpolatedExpression&gt;}\r\n</code></pre>\r\n<p>\r\n\tAt compile time, an interpolated string is typically transformed into a&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.format\" target=\"_blank\">String.Format</a>&nbsp;method call. That makes all the capabilities of the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/base-types/composite-formatting\" target=\"_blank\">string composite formatting</a>&nbsp;feature available to you to use with interpolated strings as well.</p>\r\n<h2>\r\n\tHow to specify a format string for an interpolated expression</h2>\r\n<p>\r\n\tYou specify a format string that is supported by the type of the expression result by following the interpolated expression with a colon (&quot;:&quot;) and the format string:</p>\r\n<pre>\r\n<code>{&lt;interpolatedExpression&gt;:&lt;formatString&gt;}\r\n</code></pre>\r\n<p>\r\n\tThe following example shows how to specify standard and custom format strings for expressions that produce date and time or numeric results:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>var</span> date = <span>new</span> DateTime(<span>1731</span>, <span>11</span>, <span>25</span>);\r\nConsole.WriteLine(<span>$&quot;On <span>{date:dddd, MMMM dd, yyyy}</span> Leonhard Euler introduced the letter e to denote <span>{Math.E:F5}</span> in a letter to Christian Goldbach.&quot;</span>);\r\n\r\n<span>// Expected output:</span>\r\n<span>// On Sunday, November 25, 1731 Leonhard Euler introduced the letter e to denote 2.71828 in a letter to Christian Goldbach.</span>\r\n</code></pre>\r\n<p>\r\n\tFor more information, see the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/base-types/composite-formatting#format-string-component\" target=\"_blank\">Format String Component</a>&nbsp;section of the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/base-types/composite-formatting\" target=\"_blank\">Composite Formatting</a>&nbsp;topic. That section provides links to the topics that describe standard and custom format strings supported by .NET base types.</p>\r\n<h2>\r\n\tHow to control the field width and alignment of the formatted interpolated expression</h2>\r\n<p>\r\n\tYou specify the minimum field width and the alignment of the formatted expression result by following the interpolated expression with a comma (&quot;,&quot;) and the constant expression:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>{&lt;interpolatedExpression&gt;,&lt;alignment&gt;}\r\n</code></pre>\r\n<p>\r\n\tIf the&nbsp;<em>alignment</em>&nbsp;value is positive, the formatted expression result is right-aligned; if negative, it&#39;s left-aligned.</p>\r\n<p>\r\n\tIf you need to specify both alignment and a format string, start with the alignment component:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>{&lt;interpolatedExpression&gt;,&lt;alignment&gt;:&lt;formatString&gt;}\r\n</code></pre>\r\n<p>\r\n\tThe following example shows how to specify alignment and uses pipe characters (&quot;|&quot;) to delimit text fields:</p>\r\n<pre>\r\n<code><span>const</span> <span>int</span> NameAlignment = <span>-9</span>;\r\n<span>const</span> <span>int</span> ValueAlignment = <span>7</span>;\r\n\r\n<span>double</span> a = <span>3</span>;\r\n<span>double</span> b = <span>4</span>;\r\nConsole.WriteLine(<span>$&quot;Three classical Pythagorean means of <span>{a}</span> and <span>{b}</span>:&quot;</span>);\r\nConsole.WriteLine(<span>$&quot;|<span>{<span>&quot;Arithmetic&quot;</span>,NameAlignment}</span>|<span>{<span>0.5</span> * (a + b),ValueAlignment:F3}</span>|&quot;</span>);\r\nConsole.WriteLine(<span>$&quot;|<span>{<span>&quot;Geometric&quot;</span>,NameAlignment}</span>|<span>{Math.Sqrt(a * b),ValueAlignment:F3}</span>|&quot;</span>);\r\nConsole.WriteLine(<span>$&quot;|<span>{<span>&quot;Harmonic&quot;</span>,NameAlignment}</span>|<span>{<span>2</span> / (<span>1</span> / a + <span>1</span> / b),ValueAlignment:F3}</span>|&quot;</span>);\r\n\r\n<span>// Expected output:</span>\r\n<span>// Three classical Pythagorean means of 3 and 4:</span>\r\n<span>// |Arithmetic|  3.500|</span>\r\n<span>// |Geometric|  3.464|</span>\r\n<span>// |Harmonic |  3.429|</span>\r\n</code></pre>\r\n<p>\r\n\tAs the example output shows, if the length of the formatted expression result exceeds specified field width, the&nbsp;<em>alignment</em>&nbsp;value is ignored.</p>\r\n<p>\r\n\tFor more information, see the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/base-types/composite-formatting#alignment-component\" target=\"_blank\">Alignment Component</a>&nbsp;section of the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/base-types/composite-formatting\" target=\"_blank\">Composite Formatting</a>&nbsp;topic.</p>\r\n<h2>\r\n\tHow to use escape sequences in an interpolated string</h2>\r\n<p>\r\n\tInterpolated strings support all escape sequences that can be used in ordinary string literals. For more information, see&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/strings/index#string-escape-sequences\" target=\"_blank\">String escape sequences</a>.</p>\r\n<p>\r\n\tTo interpret escape sequences literally, use a&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/verbatim\" target=\"_blank\">verbatim</a>&nbsp;string literal. A verbatim interpolated string starts with the&nbsp;<code>$</code>&nbsp;character followed by the&nbsp;<code>@</code>&nbsp;character.</p>\r\n<p>\r\n\tTo include a brace, &quot;{&quot; or &quot;}&quot;, in a result string, use two braces, &quot;{{&quot; or &quot;}}&quot;. For more information, see the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/base-types/composite-formatting#escaping-braces\" target=\"_blank\">Escaping Braces</a>&nbsp;section of the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/base-types/composite-formatting\" target=\"_blank\">Composite Formatting</a>&nbsp;topic.</p>\r\n<p>\r\n\tThe following example shows how to include braces in a result string and construct a verbatim interpolated string:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>var</span> xs = <span>new</span> <span>int</span>[] { <span>1</span>, <span>2</span>, <span>7</span>, <span>9</span> };\r\n<span>var</span> ys = <span>new</span> <span>int</span>[] { <span>7</span>, <span>9</span>, <span>12</span> };\r\nConsole.WriteLine(<span>$&quot;Find the intersection of the {{<span>{<span>string</span>.Join(<span>&quot;, &quot;</span>,xs)}</span>}} and {{<span>{<span>string</span>.Join(<span>&quot;, &quot;</span>,ys)}</span>}} sets.&quot;</span>);\r\n\r\n<span>var</span> userName = <span>&quot;Jane&quot;</span>;\r\n<span>var</span> stringWithEscapes = <span>$&quot;C:\\\\Users\\\\<span>{userName}</span>\\\\Documents&quot;</span>;\r\n<span>var</span> verbatimInterpolated = <span>$@&quot;C:\\Users\\<span>{userName}</span>\\Documents&quot;</span>;\r\nConsole.WriteLine(stringWithEscapes);\r\nConsole.WriteLine(verbatimInterpolated);\r\n\r\n<span>// Expected output:</span>\r\n<span>// Find the intersection of the {1, 2, 7, 9} and {7, 9, 12} sets.</span>\r\n<span>// C:\\Users\\Jane\\Documents</span>\r\n<span>// C:\\Users\\Jane\\Documents</span>\r\n</code></pre>\r\n<h2>\r\n\tHow to use a ternary conditional operator&nbsp;<code>?:</code>&nbsp;in an interpolated expression</h2>\r\n<p>\r\n\tAs the colon (&quot;:&quot;) has special meaning in an item with an interpolated expression, in order to use a&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/conditional-operator\" target=\"_blank\">conditional operator</a>&nbsp;in an expression, enclose it in parentheses, as the following example shows:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>var</span> rand = <span>new</span> Random();\r\n<span>for</span> (<span>int</span> i = <span>0</span>; i &lt; <span>7</span>; i++)\r\n{\r\n    Console.WriteLine(<span>$&quot;Coin flip: <span>{(rand.NextDouble() &lt; <span>0.5</span> ? <span>&quot;heads&quot;</span> : <span>&quot;tails&quot;</span>)}</span>&quot;</span>);\r\n}\r\n</code></pre>\r\n<h2>\r\n\tHow to create a culture-specific result string with string interpolation</h2>\r\n<p>\r\n\tBy default, an interpolated string uses the current culture defined by the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.globalization.cultureinfo.currentculture#System_Globalization_CultureInfo_CurrentCulture\" target=\"_blank\">CultureInfo.CurrentCulture</a>property for all formatting operations. Use implicit conversion of an interpolated string to a&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.formattablestring\" target=\"_blank\">System.FormattableString</a>&nbsp;instance and call its&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.formattablestring.tostring#System_FormattableString_ToString_System_IFormatProvider_\" target=\"_blank\">ToString(IFormatProvider)</a>&nbsp;method to create a culture-specific result string. The following example shows how to do that:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>var</span> cultures = <span>new</span> System.Globalization.CultureInfo[]\r\n{\r\n    System.Globalization.CultureInfo.GetCultureInfo(<span>&quot;en-US&quot;</span>),\r\n    System.Globalization.CultureInfo.GetCultureInfo(<span>&quot;en-GB&quot;</span>),\r\n    System.Globalization.CultureInfo.GetCultureInfo(<span>&quot;nl-NL&quot;</span>),\r\n    System.Globalization.CultureInfo.InvariantCulture\r\n};\r\n\r\n<span>var</span> date = DateTime.Now;\r\n<span>var</span> number = <span>31</span>_415_926<span>.536</span>;\r\nFormattableString message = <span>$&quot;<span>{date,<span>20</span>}</span><span>{number,<span>20</span>:N3}</span>&quot;</span>;\r\n<span>foreach</span> (<span>var</span> culture <span>in</span> cultures)\r\n{\r\n    <span>var</span> cultureSpecificMessage = message.ToString(culture);\r\n    Console.WriteLine(<span>$&quot;<span>{culture.Name,<span>-10</span>}</span><span>{cultureSpecificMessage}</span>&quot;</span>);\r\n}\r\n\r\n<span>// Expected output is like:</span>\r\n<span>// en-US       5/17/18 3:44:55 PM      31,415,926.536</span>\r\n<span>// en-GB      17/05/2018 15:44:55      31,415,926.536</span>\r\n<span>// nl-NL        17-05-18 15:44:55      31.415.926,536</span>\r\n<span>//            05/17/2018 15:44:55      31,415,926.536</span>\r\n</code></pre>\r\n<p>\r\n\tAs the example shows, you can use one&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.formattablestring\" target=\"_blank\">FormattableString</a>&nbsp;instance to generate multiple result strings for various cultures.</p>\r\n<h2>\r\n\tHow to create a result string using the invariant culture</h2>\r\n<p>\r\n\tAlong with the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.formattablestring.tostring#System_FormattableString_ToString_System_IFormatProvider_\" target=\"_blank\">FormattableString.ToString(IFormatProvider)</a>&nbsp;method, you can use the static&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.formattablestring.invariant\" target=\"_blank\">FormattableString.Invariant</a>&nbsp;method to resolve an interpolated string to a result string for the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.globalization.cultureinfo.invariantculture#System_Globalization_CultureInfo_InvariantCulture\" target=\"_blank\">InvariantCulture</a>. The following example shows how to do that:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> messageInInvariantCulture = FormattableString.Invariant(<span>$&quot;Date and time in invariant culture: <span>{DateTime.Now}</span>&quot;</span>);\r\nConsole.WriteLine(messageInInvariantCulture);\r\n\r\n<span>// Expected output is like:</span>\r\n<span>// Date and time in invariant culture: 05/17/2018 15:46:24</span>\r\n</code></pre>\r\n<h2>\r\n\tConclusion</h2>\r\n<p>\r\n\tThis tutorial describes common scenarios of string interpolation usage. For more information about string interpolation, see the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated\" target=\"_blank\">String interpolation</a>&nbsp;topic. For more information about formatting types in .NET, see the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/base-types/formatting-types\" target=\"_blank\">Formatting Types in .NET</a>&nbsp;and&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/base-types/composite-formatting\" target=\"_blank\">Composite formatting</a>&nbsp;topics.</p>"
          },
          {
            "Working With Linq": "<p>\r\n\tThis tutorial teaches you a number of features in .NET Core and the C# language. You&rsquo;ll learn:</p>\r\n<ul>\r\n\t<li>\r\n\t\tHow to generate sequences with LINQ</li>\r\n\t<li>\r\n\t\tHow to write methods that can be easily used in LINQ queries.</li>\r\n\t<li>\r\n\t\tHow to distinguish between eager and lazy evaluation.</li>\r\n</ul>\r\n<p>\r\n\tYou&#39;ll learn these techniques by building an application that demonstrates one of the basic skills of any magician: the&nbsp;<a href=\"https://en.wikipedia.org/wiki/Faro_shuffle\" target=\"_blank\">faro shuffle</a>. Briefly, a faro shuffle is a technique where you split a card deck exactly in half, then the shuffle interleaves each one card from each half to rebuild the original deck.</p>\r\n<p>\r\n\tMagicians use this technique because every card is in a known location after each shuffle, and the order is a repeating pattern.</p>\r\n<p>\r\n\tFor your purposes, it is a light hearted look at manipulating sequences of data. The application you&#39;ll build will construct a card deck, and then perform a sequence of shuffles, writing the sequence out each time. You&#39;ll also compare the updated order to the original order.</p>\r\n<p>\r\n\tThis tutorial has multiple steps. After each step, you can run the application and see the progress. You can also see the&nbsp;<a href=\"https://github.com/dotnet/samples/blob/master/csharp/getting-started/console-linq\" target=\"_blank\">completed sample</a>&nbsp;in the dotnet/samples GitHub repository. For download instructions, see&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/samples-and-tutorials/index#viewing-and-downloading-samples\" target=\"_blank\">Samples and Tutorials</a>.</p>\r\n<h2>\r\n\tPrerequisites</h2>\r\n<p>\r\n\tYou&rsquo;ll need to setup your machine to run .NET core. You can find the installation instructions on the&nbsp;<a href=\"https://www.microsoft.com/net/core\" target=\"_blank\">.NET Core</a>&nbsp;page. You can run this application on Windows, Ubuntu Linux, OS X or in a Docker container. You&rsquo;ll need to install your favorite code editor. The descriptions below use&nbsp;<a href=\"https://code.visualstudio.com/\" target=\"_blank\">Visual Studio Code</a>&nbsp;which is an open source, cross platform editor. However, you can use whatever tools you are comfortable with.</p>\r\n<h2>\r\n\tCreate the Application</h2>\r\n<p>\r\n\tThe first step is to create a new application. Open a command prompt and create a new directory for your application. Make that the current directory. Type the command&nbsp;<code>dotnet new console</code>&nbsp;at the command prompt. This creates the starter files for a basic &quot;Hello World&quot; application.</p>\r\n<p>\r\n\tIf you&#39;ve never used C# before,&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/console-teleprompter\" target=\"_blank\">this tutorial</a>&nbsp;explains the structure of a C# program. You can read that and then return here to learn more about LINQ.</p>\r\n<h2>\r\n\tCreating the Data Set</h2>\r\n<p>\r\n\tBefore you begin, make sure that the following lines are at the top of the&nbsp;<code>Program.cs</code>&nbsp;file generated by&nbsp;<code>dotnet new console</code>:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Program.cs</span>\r\n<span>using</span> System;\r\n<span>using</span> System.Collections.Generic;\r\n<span>using</span> System.Linq;\r\n</code></pre>\r\n<p>\r\n\tIf these three lines (<code>using</code>&nbsp;statements) aren&#39;t at the top of the file, our program will not compile.</p>\r\n<p>\r\n\tNow that you have all of the references that you&#39;ll need, consider what constitutes a deck of cards. Commonly, a deck of playing cards has four suits, and each suit has thirteen values. Normally, you might consider creating a&nbsp;<code>Card</code>&nbsp;class right off the bat and populating a collection of&nbsp;<code>Card</code>&nbsp;objects by hand. With LINQ, you can be more concise than the usual way of dealing with creating a deck of cards. Instead of creating a&nbsp;<code>Card</code>&nbsp;class, you can create two sequences to represent suites and ranks, respectively. You&#39;ll create a really simple pair of&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/iterators#enumeration-sources-with-iterator-methods\" target=\"_blank\"><em>iterator methods</em></a>&nbsp;that will generate the ranks and suits as&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1\" target=\"_blank\">IEnumerable&lt;T&gt;</a>s of strings:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Program.cs</span>\r\n<span>// The Main() method</span>\r\n\r\n<span><span>static</span> IEnumerable&lt;<span>string</span>&gt; <span>Suits</span>()\r\n</span>{\r\n    <span>yield</span> <span>return</span> <span>&quot;clubs&quot;</span>;\r\n    <span>yield</span> <span>return</span> <span>&quot;diamonds&quot;</span>;\r\n    <span>yield</span> <span>return</span> <span>&quot;hearts&quot;</span>;\r\n    <span>yield</span> <span>return</span> <span>&quot;spades&quot;</span>;\r\n}\r\n\r\n<span><span>static</span> IEnumerable&lt;<span>string</span>&gt; <span>Ranks</span>()\r\n</span>{\r\n    <span>yield</span> <span>return</span> <span>&quot;two&quot;</span>;\r\n    <span>yield</span> <span>return</span> <span>&quot;three&quot;</span>;\r\n    <span>yield</span> <span>return</span> <span>&quot;four&quot;</span>;\r\n    <span>yield</span> <span>return</span> <span>&quot;five&quot;</span>;\r\n    <span>yield</span> <span>return</span> <span>&quot;six&quot;</span>;\r\n    <span>yield</span> <span>return</span> <span>&quot;seven&quot;</span>;\r\n    <span>yield</span> <span>return</span> <span>&quot;eight&quot;</span>;\r\n    <span>yield</span> <span>return</span> <span>&quot;nine&quot;</span>;\r\n    <span>yield</span> <span>return</span> <span>&quot;ten&quot;</span>;\r\n    <span>yield</span> <span>return</span> <span>&quot;jack&quot;</span>;\r\n    <span>yield</span> <span>return</span> <span>&quot;queen&quot;</span>;\r\n    <span>yield</span> <span>return</span> <span>&quot;king&quot;</span>;\r\n    <span>yield</span> <span>return</span> <span>&quot;ace&quot;</span>;\r\n}\r\n</code></pre>\r\n<p>\r\n\tPlace these underneath the&nbsp;<code>Main</code>&nbsp;method in your&nbsp;<code>Program.cs</code>&nbsp;file. These two methods both utilize the&nbsp;<code>yield return</code>&nbsp;syntax to produce a sequence as they run. The compiler builds an object that implements&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1\" target=\"_blank\">IEnumerable&lt;T&gt;</a>&nbsp;and generates the sequence of strings as they are requested.</p>\r\n<p>\r\n\tNow, use these iterator methods to create the deck of cards. You&#39;ll place the LINQ query in our&nbsp;<code>Main</code>&nbsp;method. Here&#39;s a look at it:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Program.cs</span>\r\n<span><span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)\r\n</span>{\r\n    <span>var</span> startingDeck = <span><span>from</span> s <span>in</span> <span>Suits</span>()\r\n                       <span>from</span> r <span>in</span> <span>Ranks</span>()\r\n                       <span>select</span> new </span>{ Suit = s, Rank = r };\r\n\r\n    <span>// Display each card that we&#39;ve generated and placed in startingDeck in the console</span>\r\n    <span>foreach</span> (<span>var</span> card <span>in</span> startingDeck)\r\n    {\r\n        Console.WriteLine(card);\r\n    } \r\n}\r\n</code></pre>\r\n<p>\r\n\tThe multiple&nbsp;<code>from</code>&nbsp;clauses produce a&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.selectmany\" target=\"_blank\">SelectMany</a>, which creates a single sequence from combining each element in the first sequence with each element in the second sequence. The order is important for our purposes. The first element in the first source sequence (Suits) is combined with every element in the second sequence (Ranks). This produces all thirteen cards of first suit. That process is repeated with each element in the first sequence (Suits). The end result is a deck of cards ordered by suits, followed by values.</p>\r\n<p>\r\n\tIt&#39;s important to keep in mind that whether you choose to write your LINQ in the query syntax used above or use method syntax instead, it&#39;s always possible to go from one form of syntax to the other. The above query written in query syntax can be written in method syntax as:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>var</span> startingDeck = Suits().SelectMany(suit =&gt; Ranks().Select(rank =&gt; <span>new</span> { Suit = suit, Rank = rank }));\r\n</code></pre>\r\n<p>\r\n\tThe compiler translates LINQ statements written with query syntax into the equivalent method call syntax. Therefore, regardless of your syntax choice, the two versions of the query produce the same result. Choose which syntax works best for your situation: for instance, if you&#39;re working in a team where some of the members have difficulty with method syntax, try to prefer using query syntax.</p>\r\n<p>\r\n\tGo ahead and run the sample you&#39;ve built at this point. It will display all 52 cards in the deck. You may find it very helpful to run this sample under a debugger to observe how the&nbsp;<code>Suits()</code>&nbsp;and&nbsp;<code>Ranks()</code>&nbsp;methods execute. You can clearly see that each string in each sequence is generated only as it is needed.</p>\r\n<p>\r\n\t<img alt=\"Console window showing the app writing out 52 cards\" data-linktype=\"relative-path\" src=\"https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/media/working-with-linq/console.png\" style=\"border: 0px; box-sizing: inherit; max-width: 100%; height: auto; display: inline-block;\" /></p>\r\n<h2>\r\n\tManipulating the Order</h2>\r\n<p>\r\n\tNext, focus on how you&#39;re going to shuffle the cards in the deck. The first step in any good shuffle is to split the deck in two. The&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.take\" target=\"_blank\">Take</a>&nbsp;and&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.skip\" target=\"_blank\">Skip</a>&nbsp;methods that are part of the LINQ APIs provide that feature for you. Place them underneath the&nbsp;<code>foreach</code>&nbsp;loop:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Program.cs</span>\r\n<span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)\r\n</span>{\r\n    <span>var</span> startingDeck = <span><span>from</span> s <span>in</span> <span>Suits</span>()\r\n                       <span>from</span> r <span>in</span> <span>Ranks</span>()\r\n                       <span>select</span> new </span>{ Suit = s, Rank = r };\r\n\r\n    <span>foreach</span> (<span>var</span> c <span>in</span> startingDeck)\r\n    {\r\n        Console.WriteLine(c);\r\n    }\r\n\r\n    <span>// 52 cards in a deck, so 52 / 2 = 26    </span>\r\n    <span>var</span> top = startingDeck.Take(<span>26</span>);\r\n    <span>var</span> bottom = startingDeck.Skip(<span>26</span>);\r\n}\r\n</code></pre>\r\n<p>\r\n\tHowever, there&#39;s no shuffle method to take advantage of in the standard library, so you&#39;ll have to write your own. The shuffle method you&#39;ll be creating illustrates several techniques that you&#39;ll use with LINQ-based programs, so each part of this process will be explained in steps.</p>\r\n<p>\r\n\tIn order to add some functionality to how you interact with the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1\" target=\"_blank\">IEnumerable&lt;T&gt;</a>&nbsp;you&#39;ll get back from LINQ queries, you&#39;ll need to write some special kinds of methods called&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods\" target=\"_blank\">extension methods</a>. Briefly, an extension method is a special purpose&nbsp;<em>static method</em>&nbsp;that adds new functionality to an already-existing type without having to modify the original type you want to add functionality to.</p>\r\n<p>\r\n\tGive your extension methods a new home by adding a new&nbsp;<em>static</em>&nbsp;class file to your program called&nbsp;<code>Extensions.cs</code>, and then start building out the first extension method:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Extensions.cs</span>\r\n<span>using</span> System;\r\n<span>using</span> System.Collections.Generic;\r\n<span>using</span> System.Linq;\r\n\r\n<span>namespace</span> <span>LinqFaroShuffle</span>\r\n{\r\n    <span>public</span> <span>static</span> <span>class</span> <span>Extensions</span>\r\n    {\r\n        <span>public</span> <span>static</span> IEnumerable&lt;T&gt; InterleaveSequenceWith&lt;T&gt;(<span>this</span> IEnumerable&lt;T&gt; first, IEnumerable&lt;T&gt; second)\r\n        {\r\n            <span>// Your implementation will go here soon enough</span>\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tLook at the method signature for a moment, specifically the parameters:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>static</span> IEnumerable&lt;T&gt; InterleaveSequenceWith&lt;T&gt; (<span>this</span> IEnumerable&lt;T&gt; first, IEnumerable&lt;T&gt; second)\r\n</code></pre>\r\n<p>\r\n\tYou can see the addition of the&nbsp;<code>this</code>&nbsp;modifier on the first argument to the method. That means you call the method as though it were a member method of the type of the first argument. This method declaration also follows a standard idiom where the input and output types are&nbsp;<code>IEnumerable&lt;T&gt;</code>. That practice enables LINQ methods to be chained together to perform more complex queries.</p>\r\n<p>\r\n\tNaturally, since you split the deck into halves, you&#39;ll need to join those halves together. In code, this means you&#39;ll be enumerating both of the sequences you acquired through&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.take\" target=\"_blank\">Take</a>&nbsp;and&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.skip\" target=\"_blank\">Skip</a>&nbsp;at once,&nbsp;<em><code>interleaving</code></em>&nbsp;the elements, and creating one sequence: your now-shuffled deck of cards. Writing a LINQ method that works with two sequences requires that you understand how&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1\" target=\"_blank\">IEnumerable&lt;T&gt;</a>works.</p>\r\n<p>\r\n\tThe&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1\" target=\"_blank\">IEnumerable&lt;T&gt;</a>&nbsp;interface has one method:&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1.getenumerator\" target=\"_blank\">GetEnumerator</a>. The object returned by&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1.getenumerator\" target=\"_blank\">GetEnumerator</a>&nbsp;has a method to move to the next element, and a property that retrieves the current element in the sequence. You will use those two members to enumerate the collection and return the elements. This Interleave method will be an iterator method, so instead of building a collection and returning the collection, you&#39;ll use the&nbsp;<code>yield return</code>&nbsp;syntax shown above.</p>\r\n<p>\r\n\tHere&#39;s the implementation of that method:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>static</span> IEnumerable&lt;T&gt; InterleaveSequenceWith&lt;T&gt;\r\n    (<span>this</span> IEnumerable&lt;T&gt; first, IEnumerable&lt;T&gt; second)\r\n{\r\n    <span>var</span> firstIter = first.GetEnumerator();\r\n    <span>var</span> secondIter = second.GetEnumerator();\r\n\r\n    <span>while</span> (firstIter.MoveNext() &amp;&amp; secondIter.MoveNext())\r\n    {\r\n        <span>yield</span> <span>return</span> firstIter.Current;\r\n        <span>yield</span> <span>return</span> secondIter.Current;\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tNow that you&#39;ve written this method, go back to the&nbsp;<code>Main</code>&nbsp;method and shuffle the deck once:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Program.cs</span>\r\n<span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)\r\n</span>{\r\n    <span>var</span> startingDeck = <span><span>from</span> s <span>in</span> <span>Suits</span>()\r\n                       <span>from</span> r <span>in</span> <span>Ranks</span>()\r\n                       <span>select</span> new </span>{ Suit = s, Rank = r };\r\n\r\n    <span>foreach</span> (<span>var</span> c <span>in</span> startingDeck)\r\n    {\r\n        Console.WriteLine(c);\r\n    }\r\n        \r\n    <span>var</span> top = startingDeck.Take(<span>26</span>);\r\n    <span>var</span> bottom = startingDeck.Skip(<span>26</span>);\r\n    <span>var</span> shuffle = top.InterleaveSequenceWith(bottom);\r\n\r\n    <span>foreach</span> (<span>var</span> c <span>in</span> shuffle)\r\n    {\r\n        Console.WriteLine(c);\r\n    }\r\n}\r\n</code></pre>\r\n<h2>\r\n\tComparisons</h2>\r\n<p>\r\n\tHow many shuffles it takes to set the deck back to its original order? To find out, you&#39;ll need to write a method that determines if two sequences are equal. After you have that method, you&#39;ll need to place the code that shuffles the deck in a loop, and check to see when the deck is back in order.</p>\r\n<p>\r\n\tWriting a method to determine if the two sequences are equal should be straightforward. It&#39;s a similar structure to the method you wrote to shuffle the deck. Only this time, instead of&nbsp;<code>yield return</code>ing each element, you&#39;ll compare the matching elements of each sequence. When the entire sequence has been enumerated, if every element matches, the sequences are the same:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>static</span> <span>bool</span> SequenceEquals&lt;T&gt;\r\n    (<span>this</span> IEnumerable&lt;T&gt; first, IEnumerable&lt;T&gt; second)\r\n{\r\n    <span>var</span> firstIter = first.GetEnumerator();\r\n    <span>var</span> secondIter = second.GetEnumerator();\r\n\r\n    <span>while</span> (firstIter.MoveNext() &amp;&amp; secondIter.MoveNext())\r\n    {\r\n        <span>if</span> (!firstIter.Current.Equals(secondIter.Current))\r\n        {\r\n            <span>return</span> <span>false</span>;\r\n        }\r\n    }\r\n\r\n    <span>return</span> <span>true</span>;\r\n}\r\n</code></pre>\r\n<p>\r\n\tThis shows a second LINQ idiom: terminal methods. They take a sequence as input (or in this case, two sequences), and return a single scalar value. When using terminal methods, they are always the final method in a chain of methods for a LINQ query, hence the name &quot;terminal&quot;.</p>\r\n<p>\r\n\tYou can see this in action when you use it to determine when the deck is back in its original order. Put the shuffle code inside a loop, and stop when the sequence is back in its original order by applying the&nbsp;<code>SequenceEquals()</code>&nbsp;method. You can see it would always be the final method in any query, because it returns a single value instead of a sequence:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Program.cs</span>\r\n<span><span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)\r\n</span>{\r\n    <span>// Query for building the deck</span>\r\n\r\n    <span>// Shuffling using InterleaveSequenceWith&lt;T&gt;();</span>\r\n\r\n    <span>var</span> times = <span>0</span>;\r\n    <span>// We can re-use the shuffle variable from earlier, or you can make a new one</span>\r\n    shuffle = startingDeck;\r\n    <span>do</span>\r\n    {\r\n        shuffle = shuffle.Take(<span>26</span>).InterleaveSequenceWith(shuffle.Skip(<span>26</span>));\r\n\r\n        <span>foreach</span> (<span>var</span> card <span>in</span> shuffle)\r\n        {\r\n            Console.WriteLine(card);\r\n        }\r\n        Console.WriteLine();\r\n        times++;\r\n\r\n    } <span>while</span> (!startingDeck.SequenceEquals(shuffle));\r\n\r\n    Console.WriteLine(times);\r\n}\r\n</code></pre>\r\n<p>\r\n\tRun the code you&#39;ve got so far and take note of how the deck rearranges on each shuffle. After 8 shuffles (iterations of the do-while loop), the deck returns to the original configuration it was in when you first created it from the starting LINQ query.</p>\r\n<h2>\r\n\tOptimizations</h2>\r\n<p>\r\n\tThe sample you&#39;ve built so far executes an&nbsp;<em>out shuffle</em>, where the top and bottom cards stay the same on each run. Let&#39;s make one change: we&#39;ll use an&nbsp;<em>in shuffle</em>&nbsp;instead, where all 52 cards change position. For an in shuffle, you interleave the deck so that the first card in the bottom half becomes the first card in the deck. That means the last card in the top half becomes the bottom card. This is a simple change to a singular line of code. Update the current shuffle query by switching the positions of&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.take\" target=\"_blank\">Take</a>&nbsp;and&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.skip\" target=\"_blank\">Skip</a>. This will change the order of the top and bottom halves of the deck:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>shuffle = shuffle.Skip(<span>26</span>).InterleaveSequenceWith(shuffle.Take(<span>26</span>));\r\n</code></pre>\r\n<p>\r\n\tRun the program again, and you&#39;ll see that it takes 52 iterations for the deck to reorder itself. You&#39;ll also start to notice some serious performance degradations as the program continues to run.</p>\r\n<p>\r\n\tThere are a number of reasons for this. You can tackle one of the major causes of this performance drop: inefficient use of&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/deferred-execution-and-lazy-evaluation-in-linq-to-xml\" target=\"_blank\"><em>lazy evaluation</em></a>.</p>\r\n<p>\r\n\tBriefly, lazy evaluation states that the evaluation of a statement is not performed until its value is needed. LINQ queries are statements that are evaluated lazily. The sequences are generated only as the elements are requested. Usually, that&#39;s a major benefit of LINQ. However, in a use such as this program, this causes exponential growth in execution time.</p>\r\n<p>\r\n\tRemember that we generated the original deck using a LINQ query. Each shuffle is generated by performing three LINQ queries on the previous deck. All these are performed lazily. That also means they are performed again each time the sequence is requested. By the time you get to the 52nd iteration, you&#39;re regenerating the original deck many, many times. Let&#39;s write a log to demonstrate this behavior. Then, you&#39;ll fix it.</p>\r\n<p>\r\n\tIn your&nbsp;<code>Extensions.cs</code>&nbsp;file, type in or copy the method below. This extension method creates a new file called&nbsp;<code>debug.log</code>&nbsp;within your project directory and records what query is currently being executed to the log file. This extension method can be appended to any query to mark that the query executed.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>static</span> IEnumerable&lt;T&gt; LogQuery&lt;T&gt;\r\n    (<span>this</span> IEnumerable&lt;T&gt; sequence, <span>string</span> tag)\r\n{\r\n    <span>// File.AppendText creates a new file if the file doesn&#39;t exist.</span>\r\n    <span>using</span> (<span>var</span> writer = File.AppendText(<span>&quot;debug.log&quot;</span>))\r\n    {\r\n        writer.WriteLine(<span>$&quot;Executing Query <span>{tag}</span>&quot;</span>);\r\n    }\r\n\r\n    <span>return</span> sequence;\r\n}\r\n</code></pre>\r\n<p>\r\n\tNext, instrument the definition of each query with a log message:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Program.cs</span>\r\n<span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)\r\n</span>{\r\n    <span>var</span> startingDeck = (<span><span>from</span> s <span>in</span> <span>Suits</span>().<span>LogQuery</span>(<span><span>&quot;Suit Generation&quot;</span></span>)\r\n                        <span>from</span> r <span>in</span> <span>Ranks</span>().<span>LogQuery</span>(<span><span>&quot;Rank Generation&quot;</span></span>)\r\n                        <span>select</span> new </span>{ Suit = s, Rank = r }).LogQuery(<span>&quot;Starting Deck&quot;</span>);\r\n\r\n    <span>foreach</span> (<span>var</span> c <span>in</span> startingDeck)\r\n    {\r\n        Console.WriteLine(c);\r\n    }\r\n        \r\n    Console.WriteLine();\r\n    <span>var</span> times = <span>0</span>;\r\n    <span>var</span> shuffle = startingDeck;\r\n\r\n    <span>do</span>\r\n    {\r\n        <span>// Out shuffle</span>\r\n        <span>/*\r\n        shuffle = shuffle.Take(26)\r\n            .LogQuery(&quot;Top Half&quot;)\r\n            .InterleaveSequenceWith(shuffle.Skip(26)\r\n            .LogQuery(&quot;Bottom Half&quot;))\r\n            .LogQuery(&quot;Shuffle&quot;);\r\n        */</span>\r\n\r\n        <span>// In shuffle</span>\r\n        shuffle = shuffle.Skip(<span>26</span>).LogQuery(<span>&quot;Bottom Half&quot;</span>)\r\n                .InterleaveSequenceWith(shuffle.Take(<span>26</span>).LogQuery(<span>&quot;Top Half&quot;</span>))\r\n                .LogQuery(<span>&quot;Shuffle&quot;</span>);\r\n\r\n        <span>foreach</span> (<span>var</span> c <span>in</span> shuffle)\r\n        {\r\n            Console.WriteLine(c);\r\n        }\r\n\r\n        times++;\r\n        Console.WriteLine(times);\r\n    } <span>while</span> (!startingDeck.SequenceEquals(shuffle));\r\n\r\n    Console.WriteLine(times);\r\n}\r\n</code></pre>\r\n<p>\r\n\tNotice that you don&#39;t log every time you access a query. You log only when you create the original query. The program still takes a long time to run, but now you can see why. If you run out of patience running the in shuffle with logging turned on, switch back to the out shuffle. You&#39;ll still see the lazy evaluation effects. In one run, it executes 2592 queries, including all the value and suit generation.</p>\r\n<p>\r\n\tYou can improve the performance of the code here to reduce the number of executions you make. A simple fix you can make is to&nbsp;<em>cache</em>&nbsp;the results of the original LINQ query that constructs the deck of cards. Currently, you&#39;re executing the queries again and again every time the do-while loop goes through an iteration, re-constructing the deck of cards and resshuffling it every time. To cache the deck of cards, you can leverage the LINQ methods&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.toarray\" target=\"_blank\">ToArray</a>&nbsp;and&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.tolist\" target=\"_blank\">ToList</a>; when you append them to the queries, they&#39;ll perform the same actions you&#39;ve told them to, but now they&#39;ll store the results in an array or a list, depending on which method you choose to call. Append the LINQ method&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.toarray\" target=\"_blank\">ToArray</a>to both queries and run the program again:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)\r\n</span>{\r\n    <span>var</span> startingDeck = (<span><span>from</span> s <span>in</span> <span>Suits</span>().<span>LogQuery</span>(<span><span>&quot;Suit Generation&quot;</span></span>)\r\n                        <span>from</span> r <span>in</span> <span>Ranks</span>().<span>LogQuery</span>(<span><span>&quot;Value Generation&quot;</span></span>)\r\n                        <span>select</span> new </span>{ Suit = s, Rank = r })\r\n                        .LogQuery(<span>&quot;Starting Deck&quot;</span>)\r\n                        .ToArray();\r\n\r\n    <span>foreach</span> (<span>var</span> c <span>in</span> startingDeck)\r\n    {\r\n        Console.WriteLine(c);\r\n    }\r\n\r\n    Console.WriteLine();\r\n\r\n    <span>var</span> times = <span>0</span>;\r\n    <span>var</span> shuffle = startingDeck;\r\n\r\n    <span>do</span>\r\n    {\r\n        <span>/*\r\n        shuffle = shuffle.Take(26)\r\n            .LogQuery(&quot;Top Half&quot;)\r\n            .InterleaveSequenceWith(shuffle.Skip(26).LogQuery(&quot;Bottom Half&quot;))\r\n            .LogQuery(&quot;Shuffle&quot;)\r\n            .ToArray();\r\n        */</span>\r\n\r\n        shuffle = shuffle.Skip(<span>26</span>)\r\n            .LogQuery(<span>&quot;Bottom Half&quot;</span>)\r\n            .InterleaveSequenceWith(shuffle.Take(<span>26</span>).LogQuery(<span>&quot;Top Half&quot;</span>))\r\n            .LogQuery(<span>&quot;Shuffle&quot;</span>)\r\n            .ToArray();\r\n\r\n        <span>foreach</span> (<span>var</span> c <span>in</span> shuffle)\r\n        {\r\n            Console.WriteLine(c);\r\n        }\r\n\r\n        times++;\r\n        Console.WriteLine(times);\r\n    } <span>while</span> (!startingDeck.SequenceEquals(shuffle));\r\n\r\n    Console.WriteLine(times);\r\n}\r\n</code></pre>\r\n<p>\r\n\tNow the out shuffle is down to 30 queries. Run again with the in shuffle and you&#39;ll see similar improvements: it now executes 162 queries.</p>\r\n<p>\r\n\tPlease note that this example is&nbsp;<span>designed</span>&nbsp;to highlight the use cases where lazy evaluation can cause performance difficulties. While it&#39;s important to see where lazy evaluation can impact code performance, it&#39;s equally important to understand that not all queries should run eagerly. The performance hit you incur without using&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.toarray\" target=\"_blank\">ToArray</a>&nbsp;is because each new arrangement of the deck of cards is built from the previous arrangement. Using lazy evaluation means each new deck configuration is built from the original deck, even executing the code that built the&nbsp;<code>startingDeck</code>. That causes a large amount of extra work.</p>\r\n<p>\r\n\tIn practice, some algorithms run well using eager evaluation, and others run well using lazy evaluation. For daily usage, lazy evaluation is usually a better choice when the data source is a separate process, like a database engine. For databases, lazy evaluation allows more complex queries to execute only one round trip to the database process and back to the rest of your code. LINQ is flexible whether you choose to utilize lazy or eager evaluation, so measure your processes and pick whichever kind of evaluation gives you the best performance.</p>\r\n<h2>\r\n\tConclusion</h2>\r\n<p>\r\n\tIn this project, you covered:</p>\r\n<ul>\r\n\t<li>\r\n\t\tusing LINQ queries to aggregate data into a meaningful sequence</li>\r\n\t<li>\r\n\t\twriting Extension methods to add our own custom functionality to LINQ queries</li>\r\n\t<li>\r\n\t\tlocating areas in our code where our LINQ queries might run into performance issues like degraded speed</li>\r\n\t<li>\r\n\t\tlazy and eager evaluation in regards to LINQ queries and the implications they might have on query performance</li>\r\n</ul>\r\n<p>\r\n\tAside from LINQ, you learned a bit about a technique magicians use for card tricks. Magicians use the Faro shuffle because they can control where every card moves in the deck. Now that you know, don&#39;t spoil it for everyone else!</p>\r\n<p>\r\n\tFor more information on LINQ, see:</p>\r\n<ul>\r\n\t<li>\r\n\t\t<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/index\" target=\"_blank\">Language Integrated Query (LINQ)</a>\r\n\t\t<ul>\r\n\t\t\t<li>\r\n\t\t\t\t<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/introduction-to-linq\" target=\"_blank\">Introduction to LINQ</a></li>\r\n\t\t\t<li>\r\n\t\t\t\t<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq\" target=\"_blank\">Getting Started With LINQ in C#</a>\r\n\t\t\t\t<ul>\r\n\t\t\t\t\t<li>\r\n\t\t\t\t\t\t<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/basic-linq-query-operations\" target=\"_blank\">Basic LINQ Query Operations (C#)</a></li>\r\n\t\t\t\t\t<li>\r\n\t\t\t\t\t\t<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/data-transformations-with-linq\" target=\"_blank\">Data Transformations With LINQ (C#)</a></li>\r\n\t\t\t\t\t<li>\r\n\t\t\t\t\t\t<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq\" target=\"_blank\">Query Syntax and Method Syntax in LINQ (C#)</a></li>\r\n\t\t\t\t\t<li>\r\n\t\t\t\t\t\t<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/features-that-support-linq\" target=\"_blank\">C# Features That Support LINQ</a></li>\r\n\t\t\t\t</ul>\r\n\t\t\t</li>\r\n\t\t</ul>\r\n\t</li>\r\n</ul>"
          },
          {
            "Microservices hosted in Docker": "<p>\r\n\tThis tutorial details the tasks necessary to build and deploy an ASP.NET Core microservice in a Docker container. During the course of this tutorial, you&#39;ll learn:</p>\r\n<ul>\r\n\t<li>\r\n\t\tHow to generate an ASP.NET Core application.</li>\r\n\t<li>\r\n\t\tHow to create a development Docker environment.</li>\r\n\t<li>\r\n\t\tHow to build a Docker image based on an existing image.</li>\r\n\t<li>\r\n\t\tHow to deploy your service into a Docker container.</li>\r\n</ul>\r\n<p>\r\n\tAlong the way, you&#39;ll also see some C# language features:</p>\r\n<ul>\r\n\t<li>\r\n\t\tHow to convert C# objects into JSON payloads.</li>\r\n\t<li>\r\n\t\tHow to build immutable Data Transfer Objects.</li>\r\n\t<li>\r\n\t\tHow to process incoming HTTP Requests and generate the HTTP Response.</li>\r\n\t<li>\r\n\t\tHow to work with nullable value types.</li>\r\n</ul>\r\n<p>\r\n\tYou can&nbsp;<a href=\"https://github.com/dotnet/samples/tree/master/csharp/getting-started/WeatherMicroservice\" target=\"_blank\">view or download the sample app</a>&nbsp;for this topic.</p>\r\n<h2>\r\n\tWhy Docker?</h2>\r\n<p>\r\n\tDocker makes it easy to create standard machine images to host your services in a data center, or the public cloud. Docker enables you to configure the image, and replicate it as needed to scale the installation of your application.</p>\r\n<p>\r\n\tAll the code in this tutorial will work in any .NET Core environment. The additional tasks for a Docker installation will work for an ASP.NET Core application.</p>\r\n<h2>\r\n\tPrerequisites</h2>\r\n<p>\r\n\tYou&rsquo;ll need to setup your machine to run .NET Core. You can find the installation instructions on the&nbsp;<a href=\"https://www.microsoft.com/net/core\" target=\"_blank\">.NET Core</a>&nbsp;page. You can run this application on Windows, Linux, macOS or in a Docker container. You&rsquo;ll need to install your favorite code editor. The descriptions below use&nbsp;<a href=\"https://code.visualstudio.com/\" target=\"_blank\">Visual Studio Code</a>&nbsp;which is an open source, cross platform editor. However, you can use whatever tools you are comfortable with.</p>\r\n<p>\r\n\tYou&#39;ll also need to install the Docker engine. See the&nbsp;<a href=\"https://docs.docker.com/install/overview/\" target=\"_blank\">Docker Installation page</a>&nbsp;for instructions for your platform. Docker can be installed in many Linux distributions, macOS, or Windows. The page referenced above contains sections to each of the available installations.</p>\r\n<h2>\r\n\tCreate the Application</h2>\r\n<p>\r\n\tNow that you&#39;ve installed all the tools, create a new ASP.NET Core application in a directory called &quot;WeatherMicroservice&quot; by executing the following command in your favorite shell:</p>\r\n<div>\r\n\t<span>console</span></div>\r\n<pre>\r\n<code>dotnet new web -o WeatherMicroservice\r\n</code></pre>\r\n<p>\r\n\tThe&nbsp;<code>dotnet</code>&nbsp;command runs the tools necessary for .NET development. Each verb executes a different command.</p>\r\n<p>\r\n\tThe&nbsp;<code>dotnet new</code>&nbsp;command is used to create .Net Core projects.</p>\r\n<p>\r\n\tThe&nbsp;<code>-o WeatherMicroservice</code>&nbsp;option after the&nbsp;<code>dotnet new</code>&nbsp;command is used to give the location to create the ASP.NET Core application.</p>\r\n<p>\r\n\tFor this microservice, we want the simplest, most lightweight web application possible, so we used the &quot;ASP.NET Core Empty&quot; template, by specifying its short name,&nbsp;<code>web</code>.</p>\r\n<p>\r\n\tThe template creates four files for you:</p>\r\n<ul>\r\n\t<li>\r\n\t\tA Startup.cs file. This contains the basis of the application.</li>\r\n\t<li>\r\n\t\tA Program.cs file. This contains the entry point of the application.</li>\r\n\t<li>\r\n\t\tA WeatherMicroservice.csproj file. This is the build file for the application.</li>\r\n\t<li>\r\n\t\tA Properties/launchSettings.json file. This contains debugging settings used by IDEs.</li>\r\n</ul>\r\n<p>\r\n\tNow you can run the template generated application:</p>\r\n<div>\r\n\t<span>console</span></div>\r\n<pre>\r\n<code>dotnet run\r\n</code></pre>\r\n<p>\r\n\tThis command will first restore dependencies required to build the application and then it will build the application.</p>\r\n<p>\r\n\tThe default configuration listens to&nbsp;<code>http://localhost:5000</code>. You can open a browser and navigate to that page and see a &quot;Hello World!&quot; message.</p>\r\n<p>\r\n\tWhen you&#39;re done, you can shut down the application by pressing&nbsp;<kbd>Ctrl</kbd>+<kbd>C</kbd>.</p>\r\n<h3>\r\n\tAnatomy of an ASP.NET Core application</h3>\r\n<p>\r\n\tNow that you&#39;ve built the application, let&#39;s look at how this functionality is implemented. There are two of the generated files that are particularly interesting at this point: WeatherMicroservice.csproj and Startup.cs.</p>\r\n<p>\r\n\tThe .csproj file contains information about the project. The two nodes that are most interesting are&nbsp;<code>&lt;TargetFramework&gt;</code>&nbsp;and&nbsp;<code>&lt;PackageReference&gt;</code>.</p>\r\n<p>\r\n\tThe&nbsp;<code>&lt;TargetFramework&gt;</code>&nbsp;node specifies the version of .NET that will run this application.</p>\r\n<p>\r\n\tEach&nbsp;<code>&lt;PackageReference&gt;</code>&nbsp;node is used to specify a package that is needed for this application.</p>\r\n<p>\r\n\tThe application is implemented in Startup.cs. This file contains the startup class.</p>\r\n<p>\r\n\tThe two methods are called by the ASP.NET Core infrastructure to configure and run the application. The&nbsp;<code>ConfigureServices</code>&nbsp;method describes the services that are necessary for this application. You&#39;re building a lean microservice, so it doesn&#39;t need to configure any dependencies. The&nbsp;<code>Configure</code>method configures the handlers for incoming HTTP Requests. The template generates a simple handler that responds to any request with the text &#39;Hello World!&#39;.</p>\r\n<h2>\r\n\tBuild a microservice</h2>\r\n<p>\r\n\tThe service you&#39;re going to build will deliver weather reports from anywhere around the globe. In a production application, you&#39;d call some service to retrieve weather data. For our sample, we&#39;ll generate a random weather forecast.</p>\r\n<p>\r\n\tThere are a number of tasks you&#39;ll need to perform in order to implement our random weather service:</p>\r\n<ul>\r\n\t<li>\r\n\t\tParse the incoming request to read the latitude and longitude.</li>\r\n\t<li>\r\n\t\tGenerate some random forecast data.</li>\r\n\t<li>\r\n\t\tConvert that random forecast data from C# objects into JSON packets.</li>\r\n\t<li>\r\n\t\tSet the response header to indicate that your service sends back JSON.</li>\r\n\t<li>\r\n\t\tWrite the response.</li>\r\n</ul>\r\n<p>\r\n\tThe next sections walk you through each of these steps.</p>\r\n<h3>\r\n\tParsing the Query String</h3>\r\n<p>\r\n\tYou&#39;ll begin by parsing the query string. The service will accept &#39;lat&#39; and &#39;long&#39; arguments on the query string in this form:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>http://localhost:5000/?lat=-35.55&amp;long=-12.35\r\n</code></pre>\r\n<p>\r\n\tAll the changes you need to make are in the lambda expression defined as the argument to&nbsp;<code>app.Run</code>in your startup class.</p>\r\n<p>\r\n\tThe argument on the lambda expression is the&nbsp;<code>HttpContext</code>&nbsp;for the request. One of its properties is the&nbsp;<code>Request</code>&nbsp;object. The&nbsp;<code>Request</code>&nbsp;object has a&nbsp;<code>Query</code>&nbsp;property that contains a dictionary of all the values on the query string for the request. The first addition is to find the latitude and longitude values:</p>\r\n<div>\r\n\t<span>C#</span></div>\r\n<pre>\r\n<code><span>var</span> latString = context.Request.Query[<span>&quot;lat&quot;</span>].FirstOrDefault();\r\n<span>var</span> longString = context.Request.Query[<span>&quot;long&quot;</span>].FirstOrDefault();\r\n</code></pre>\r\n<p>\r\n\tThe&nbsp;<code>Query</code>&nbsp;dictionary values are&nbsp;<code>StringValue</code>&nbsp;type. That type can contain a collection of strings. For your weather service, each value is a single string. That&#39;s why there&#39;s the call to&nbsp;<code>FirstOrDefault()</code>&nbsp;in the code above.</p>\r\n<p>\r\n\tNext, you need to convert the strings to doubles. The method you&#39;ll use to convert the string to a double is&nbsp;<code>double.TryParse()</code>:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>bool</span> <span>TryParse</span>(<span><span>string</span> s, <span>out</span> <span>double</span> result</span>)</span>;\r\n</code></pre>\r\n<p>\r\n\tThis method leverages C# out parameters to indicate if the input string can be converted to a double. If the string does represent a valid representation for a double, the method returns true, and the&nbsp;<code>result</code>&nbsp;argument contains the value. If the string does not represent a valid double, the method returns false.</p>\r\n<p>\r\n\tYou can adapt that API with the use of an&nbsp;<em>extension method</em>&nbsp;that returns a&nbsp;<em>nullable double</em>. A&nbsp;<em>nullable value type</em>&nbsp;is a type that represents some value type, and can also hold a missing, or null value. A nullable type is represented by appending the&nbsp;<code>?</code>&nbsp;character to the type declaration.</p>\r\n<p>\r\n\tExtension methods are methods that are defined as static methods, but by adding the&nbsp;<code>this</code>&nbsp;modifier on the first parameter, can be called as though they are members of that class. Extension methods may only be defined in static classes. Here&#39;s the definition of the class containing the extension method for parse:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>static</span> <span>class</span> <span>Extensions</span>\r\n{\r\n    <span>public</span> <span>static</span> <span>double</span>? TryParse(<span>this</span> <span>string</span> input)\r\n    {\r\n        <span>if</span> (<span>double</span>.TryParse(input, <span>out</span> <span>var</span> result))\r\n        {\r\n            <span>return</span> result;\r\n        }\r\n        <span>else</span>\r\n        {\r\n            <span>return</span> <span>null</span>;\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tBefore calling the extension method, change the current culture to invariant:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>CultureInfo.CurrentCulture = CultureInfo.InvariantCulture;\r\n</code></pre>\r\n<p>\r\n\tThis ensures that your application parses numbers the same on any server, regardless of its default culture.</p>\r\n<p>\r\n\tNow you can use the extension method to convert the query string arguments into the double type:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>var</span> latitude = latString.TryParse();\r\n<span>var</span> longitude = longString.TryParse();\r\n</code></pre>\r\n<p>\r\n\tTo easily test the parsing code, update the response to include the values of the arguments:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>await</span> context.Response.WriteAsync(<span>$&quot;Retrieving Weather for lat: <span>{latitude}</span>, long: <span>{longitude}</span>&quot;</span>);                \r\n</code></pre>\r\n<p>\r\n\tAt this point, you can run the web application and see if your parsing code is working. Add values to the web request in a browser, and you should see the updated results.</p>\r\n<h3>\r\n\tBuild a random weather forecast</h3>\r\n<p>\r\n\tYour next task is to build a random weather forecast. Let&#39;s start with a data container that holds the values you&#39;d want for a weather forecast:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>class</span> <span>WeatherReport</span>\r\n{\r\n    <span>private</span> <span>static</span> <span>readonly</span> <span>string</span>[] PossibleConditions =\r\n    {\r\n        <span>&quot;Sunny&quot;</span>,\r\n        <span>&quot;Mostly Sunny&quot;</span>,\r\n        <span>&quot;Partly Sunny&quot;</span>,\r\n        <span>&quot;Partly Cloudy&quot;</span>,\r\n        <span>&quot;Mostly Cloudy&quot;</span>,\r\n        <span>&quot;Rain&quot;</span>\r\n    };\r\n\r\n    <span>public</span> <span>int</span> HighTemperatureFahrenheit { <span>get</span>; }\r\n    <span>public</span> <span>int</span> LowTemperatureFahrenheit { <span>get</span>; }\r\n    <span>public</span> <span>int</span> AverageWindSpeedMph { <span>get</span>; }\r\n    <span>public</span> <span>string</span> Condition { <span>get</span>; }\r\n}\r\n</code></pre>\r\n<p>\r\n\tNext, build a constructor that randomly sets those values. This constructor uses the values for the latitude and longitude to seed the&nbsp;<code>Random</code>&nbsp;number generator. That means the forecast for the same location is the same. If you change the arguments for the latitude and longitude, you&#39;ll get a different forecast (because you start with a different seed).</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>public</span> <span>WeatherReport</span>(<span><span>double</span> latitude, <span>double</span> longitude, <span>int</span> daysInFuture</span>)\r\n</span>{\r\n    <span>var</span> generator = <span>new</span> Random((<span>int</span>)(latitude + longitude) + daysInFuture);\r\n\r\n    HighTemperatureFahrenheit = generator.Next(<span>40</span>, <span>100</span>);\r\n    LowTemperatureFahrenheit = generator.Next(<span>0</span>, HighTemperatureFahrenheit);\r\n    AverageWindSpeedMph = generator.Next(<span>0</span>, <span>45</span>);\r\n    Condition = PossibleConditions[generator.Next(<span>0</span>, PossibleConditions.Length - <span>1</span>)];\r\n}\r\n</code></pre>\r\n<p>\r\n\tYou can now generate the 5-day forecast in your response method:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>if</span> (latitude.HasValue &amp;&amp; longitude.HasValue)\r\n{\r\n    <span>var</span> forecast = <span>new</span> List&lt;WeatherReport&gt;();\r\n    <span>for</span> (<span>var</span> days = <span>1</span>; days &lt;= <span>5</span>; days++)\r\n    {\r\n        forecast.Add(<span>new</span> WeatherReport(latitude.Value, longitude.Value, days));\r\n    }\r\n}\r\n</code></pre>\r\n<h3>\r\n\tBuild the JSON response</h3>\r\n<p>\r\n\tThe final code task on the server is to convert the&nbsp;<code>WeatherReport</code>&nbsp;list into JSON document, and send that back to the client. Let&#39;s start by creating the JSON document. You&#39;ll add the Newtonsoft JSON serializer to the list of dependencies. You can do that using the following&nbsp;<code>dotnet</code>&nbsp;command:</p>\r\n<div>\r\n\t<span>console</span></div>\r\n<pre>\r\n<code>dotnet add package Newtonsoft.Json\r\n</code></pre>\r\n<p>\r\n\tThen, you can use the&nbsp;<code>JsonConvert</code>&nbsp;class to write the object to a string:</p>\r\n<div>\r\n\t<span>C#</span></div>\r\n<pre>\r\n<code><span>var</span> json = JsonConvert.SerializeObject(forecast, Formatting.Indented);\r\ncontext.Response.ContentType = <span>&quot;application/json; charset=utf-8&quot;</span>;\r\n<span>await</span> context.Response.WriteAsync(json);\r\n</code></pre>\r\n<p>\r\n\tThe code above converts the forecast object (a list of&nbsp;<code>WeatherForecast</code>&nbsp;objects) into a JSON document. After you&#39;ve constructed the response document, you set the content type to&nbsp;<code>application/json</code>, and write the string.</p>\r\n<p>\r\n\tThe application now runs and returns random forecasts.</p>\r\n<h2>\r\n\tBuild a Docker image</h2>\r\n<p>\r\n\tOur final task is to run the application in Docker. We&#39;ll create a Docker container that runs a Docker image that represents our application.</p>\r\n<p>\r\n\tA&nbsp;<em><span>Docker Image</span></em>&nbsp;is a file that defines the environment for running the application.</p>\r\n<p>\r\n\tA&nbsp;<em><span>Docker Container</span></em>&nbsp;represents a running instance of a Docker Image.</p>\r\n<p>\r\n\tBy analogy, you can think of the&nbsp;<em>Docker Image</em>&nbsp;as a&nbsp;<em>class</em>, and the&nbsp;<em>Docker Container</em>&nbsp;as an object, or an instance of that class.</p>\r\n<p>\r\n\tThe following Dockerfile will serve for our purposes:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>FROM microsoft/dotnet:2.1-sdk AS build\r\nWORKDIR /app\r\n\r\n# Copy csproj and restore as distinct layers\r\nCOPY *.csproj ./\r\nRUN dotnet restore\r\n\r\n# Copy everything else and build\r\nCOPY . ./\r\nRUN dotnet publish -c Release -o out\r\n\r\n# Build runtime image\r\nFROM microsoft/dotnet:2.1-aspnetcore-runtime\r\nWORKDIR /app\r\nCOPY --from=build /app/out .\r\nENTRYPOINT [&quot;dotnet&quot;, &quot;WeatherMicroservice.dll&quot;]\r\n</code></pre>\r\n<p>\r\n\tLet&#39;s go over its contents.</p>\r\n<p>\r\n\tThe first line specifies the source image used for building the application:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>FROM microsoft/dotnet:2.1-sdk AS build\r\n</code></pre>\r\n<p>\r\n\tDocker allows you to configure a machine image based on a source template. That means you don&#39;t have to supply all the machine parameters when you start, you only need to supply any changes. The changes here will be to include our application.</p>\r\n<p>\r\n\tIn this sample, we&#39;ll use the&nbsp;<code>2.1-sdk</code>&nbsp;version of the&nbsp;<code>dotnet</code>&nbsp;image. This is the easiest way to create a working Docker environment. This image includes the .NET Core runtime, and the .NET Core SDK. That makes it easier to get started and build, but does create a larger image, so we&#39;ll use this image for building the application and a different image to run it.</p>\r\n<p>\r\n\tThe next lines setup and build your application:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>WORKDIR /app\r\n\r\n# Copy csproj and restore as distinct layers\r\nCOPY *.csproj ./\r\nRUN dotnet restore\r\n\r\n# Copy everything else and build\r\nCOPY . ./\r\nRUN dotnet publish -c Release -o out\r\n</code></pre>\r\n<p>\r\n\tThis will copy the project file from the current directory to the Docker VM, and restore all the packages. Using the dotnet CLI means that the Docker image must include the .NET Core SDK. After that, the rest of your application gets copied, and the&nbsp;<code>dotnet publish</code>&nbsp;command builds and packages your application.</p>\r\n<p>\r\n\tFinally, we create a second Docker image that runs the application:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code># Build runtime image\r\nFROM microsoft/dotnet:2.1-aspnetcore-runtime\r\nWORKDIR /app\r\nCOPY --from=build /app/out .\r\nENTRYPOINT [&quot;dotnet&quot;, &quot;WeatherMicroservice.dll&quot;]\r\n</code></pre>\r\n<p>\r\n\tThis image uses the&nbsp;<code>2.1-aspnetcore-runtime</code>&nbsp;version of the&nbsp;<code>dotnet</code>&nbsp;image, which contains everything necessary to run ASP.NET Core applications, but does not include the .NET Core SDK. This means this image can&#39;t be used to build .NET Core applications, but it also makes the final image smaller.</p>\r\n<p>\r\n\tTo make this work, we copy the built application from the first image to the second one.</p>\r\n<p>\r\n\tThe&nbsp;<code>ENTRYPOINT</code>&nbsp;command informs Docker what command starts the service.</p>\r\n<h2>\r\n\tBuilding and running the image in a container</h2>\r\n<p>\r\n\tLet&#39;s build an image and run the service inside a Docker container. You don&#39;t want all the files from your local directory copied into the image. Instead, you&#39;ll build the application in the container. You&#39;ll create a&nbsp;<code>.dockerignore</code>&nbsp;file to specify the directories that are not copied into the image. You don&#39;t want any of the build assets copied. Specify the build and publish directories in the&nbsp;<code>.dockerignore</code>&nbsp;file:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>bin/*\r\nobj/*\r\nout/*\r\n</code></pre>\r\n<p>\r\n\tYou build the image using the&nbsp;<code>docker build</code>&nbsp;command. Run the following command from the directory containing your code.</p>\r\n<div>\r\n\t<span>console</span></div>\r\n<pre>\r\n<code>docker build -t weather-microservice .\r\n</code></pre>\r\n<p>\r\n\tThis command builds the container image based on all the information in your Dockerfile. The&nbsp;<code>-t</code>argument provides a tag, or name, for this container image. In the command line above, the tag used for the Docker container is&nbsp;<code>weather-microservice</code>. When this command completes, you have a container ready to run your new service.</p>\r\n<p>\r\n\tRun the following command to start the container and launch your service:</p>\r\n<div>\r\n\t<span>console</span></div>\r\n<pre>\r\n<code>docker run -d -p 80:80 --name hello-docker weather-microservice\r\n</code></pre>\r\n<p>\r\n\tThe&nbsp;<code>-d</code>&nbsp;option means to run the container detached from the current terminal. That means you won&#39;t see the command output in your terminal. The&nbsp;<code>-p</code>&nbsp;option indicates the port mapping between the service and the host. Here it says that any incoming request on port 80 should be forwarded to port 80 on the container. Using 80 matches the port your service is listening on, which is the default port for production applications. The&nbsp;<code>--name</code>&nbsp;argument names your running container. It&#39;s a convenient name you can use to work with that container.</p>\r\n<p>\r\n\tYou can see if the image is running by checking the command:</p>\r\n<div>\r\n\t<span>console</span></div>\r\n<pre>\r\n<code>docker ps\r\n</code></pre>\r\n<p>\r\n\tIf your container is running, you&#39;ll see a line that lists it in the running processes. (It may be the only one.)</p>\r\n<p>\r\n\tYou can test your service by opening a browser and navigating to localhost, and specifying a latitude and longitude:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>http://localhost/?lat=35.5&amp;long=40.75\r\n</code></pre>\r\n<h2>\r\n\tAttaching to a running container</h2>\r\n<p>\r\n\tWhen you ran your service in a command window, you could see diagnostic information printed for each request. You don&#39;t see that information when your container is running in detached mode. The Docker attach command enables you to attach to a running container so that you can see the log information. Run this command from a command window:</p>\r\n<div>\r\n\t<span>console</span></div>\r\n<pre>\r\n<code>docker attach --sig-proxy=false hello-docker\r\n</code></pre>\r\n<p>\r\n\tThe&nbsp;<code>--sig-proxy=false</code>&nbsp;argument means that&nbsp;<kbd>Ctrl</kbd>+<kbd>C</kbd>&nbsp;commands do not get sent to the container process, but rather stop the&nbsp;<code>docker attach</code>&nbsp;command. The final argument is the name given to the container in the&nbsp;<code>docker run</code>&nbsp;command.</p>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tYou can also use the Docker assigned container ID to refer to any container. If you didn&#39;t specify a name for your container in&nbsp;<code>docker run</code>&nbsp;you must use the container ID.</p>\r\n</div>\r\n<p>\r\n\tOpen a browser and navigate to your service. You&#39;ll see the diagnostic messages in the command windows from the attached running container.</p>\r\n<p>\r\n\tPress&nbsp;<kbd>Ctrl</kbd>+<kbd>C</kbd>&nbsp;to stop the attach process.</p>\r\n<p>\r\n\tWhen you are done working with your container, you can stop it:</p>\r\n<div>\r\n\t<span>console</span></div>\r\n<pre>\r\n<code>docker stop hello-docker\r\n</code></pre>\r\n<p>\r\n\tThe container and image is still available for you to restart. If you want to remove the container from your machine, you use this command:</p>\r\n<div>\r\n\t<span>console</span></div>\r\n<pre>\r\n<code>docker rm hello-docker\r\n</code></pre>\r\n<p>\r\n\tIf you want to remove unused images from your machine, you use this command:</p>\r\n<div>\r\n\t<span>console</span></div>\r\n<pre>\r\n<code>docker rmi weather-microservice\r\n</code></pre>\r\n<h2>\r\n\tConclusion</h2>\r\n<p>\r\n\tIn this tutorial, you built an ASP.NET Core microservice, and added a few simple features.</p>\r\n<p>\r\n\tYou built a Docker container image for that service, and ran that container on your machine. You attached a terminal window to the service, and saw the diagnostic messages from your service.</p>\r\n<p>\r\n\tAlong the way, you saw several features of the C# language in action.</p>"
          },
          {
            "Type System": "<h2>\r\n\tTypes, Variables, and Values</h2>\r\n<p>\r\n\tC# is a strongly-typed language. Every variable and constant has a type, as does every expression that evaluates to a value. Every method signature specifies a type for each input parameter and for the return value. The .NET class library defines a set of built-in numeric types as well as more complex types that represent a wide variety of logical constructs, such as the file system, network connections, collections and arrays of objects, and dates. A typical C# program uses types from the class library as well as user-defined types that model the concepts that are specific to the program&#39;s problem domain.</p>\r\n<p>\r\n\tThe information stored in a type can include the following:</p>\r\n<ul>\r\n\t<li>\r\n\t\tThe storage space that a variable of the type requires.</li>\r\n\t<li>\r\n\t\tThe maximum and minimum values that it can represent.</li>\r\n\t<li>\r\n\t\tThe members (methods, fields, events, and so on) that it contains.</li>\r\n\t<li>\r\n\t\tThe base type it inherits from.</li>\r\n\t<li>\r\n\t\tThe location where the memory for variables will be allocated at run time.</li>\r\n\t<li>\r\n\t\tThe kinds of operations that are permitted.</li>\r\n</ul>\r\n<p>\r\n\tThe compiler uses type information to make sure that all operations that are performed in your code are&nbsp;<em>type safe</em>. For example, if you declare a variable of type&nbsp;int, the compiler allows you to use the variable in addition and subtraction operations. If you try to perform those same operations on a variable of type&nbsp;bool, the compiler generates an error, as shown in the following example:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>int</span> a = <span>5</span>;             \r\n<span>int</span> b = a + <span>2</span>; <span>//OK</span>\r\n\r\n<span>bool</span> test = <span>true</span>;\r\n  \r\n<span>// Error. Operator &#39;+&#39; cannot be applied to operands of type &#39;int&#39; and &#39;bool&#39;.</span>\r\n<span>int</span> c = a + test;\r\n</code></pre>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tC and C++ developers, notice that in C#,&nbsp;bool&nbsp;is not convertible to&nbsp;int.</p>\r\n</div>\r\n<p>\r\n\tThe compiler embeds the type information into the executable file as metadata. The common language runtime (CLR) uses that metadata at run time to further guarantee type safety when it allocates and reclaims memory.</p>\r\n<h3>\r\n\tSpecifying Types in Variable Declarations</h3>\r\n<p>\r\n\tWhen you declare a variable or constant in a program, you must either specify its type or use the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/var\" target=\"_blank\">var</a>keyword to let the compiler infer the type. The following example shows some variable declarations that use both built-in numeric types and complex user-defined types:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Declaration only:</span>\r\n<span>float</span> temperature;\r\n<span>string</span> name;\r\nMyClass myClass;\r\n\r\n<span>// Declaration with initializers (four examples):</span>\r\n<span>char</span> firstLetter = <span>&#39;C&#39;</span>;\r\n<span>var</span> limit = <span>3</span>;\r\n<span>int</span>[] source = { <span>0</span>, <span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span> };\r\n<span>var</span> query = <span>from</span> item <span>in</span> source\r\n            <span>where</span> item &lt;= limit\r\n            <span>select</span> item;\r\n</code></pre>\r\n<p>\r\n\tThe types of method parameters and return values are specified in the method signature. The following signature shows a method that requires an&nbsp;int&nbsp;as an input argument and returns a string:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>public</span> <span>string</span> <span>GetName</span>(<span><span>int</span> ID</span>)\r\n</span>{\r\n    <span>if</span> (ID &lt; names.Length)\r\n        <span>return</span> names[ID];\r\n    <span>else</span>\r\n        <span>return</span> String.Empty;\r\n}\r\n<span>private</span> <span>string</span>[] names = { <span>&quot;Spencer&quot;</span>, <span>&quot;Sally&quot;</span>, <span>&quot;Doug&quot;</span> };\r\n</code></pre>\r\n<p>\r\n\tAfter a variable is declared, it cannot be re-declared with a new type, and it cannot be assigned a value that is not compatible with its declared type. For example, you cannot declare an&nbsp;int&nbsp;and then assign it a Boolean value of&nbsp;true. However, values can be converted to other types, for example when they are assigned to new variables or passed as method arguments. A&nbsp;<em>type conversion</em>&nbsp;that does not cause data loss is performed automatically by the compiler. A conversion that might cause data loss requires a&nbsp;<em>cast</em>&nbsp;in the source code.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<h2>\r\n\tBuilt-in Types</h2>\r\n<p>\r\n\tC# provides a standard set of built-in numeric types to represent integers, floating point values, Boolean expressions, text characters, decimal values, and other types of data. There are also built-in&nbsp;<code>string</code>&nbsp;and&nbsp;<code>object</code>&nbsp;types. These are available for you to use in any C# program. For more information about the built-in types, see&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/reference-tables-for-types\" target=\"_blank\">Reference Tables for Types</a><span>.</span></p>\r\n<h2>\r\n\tCustom Types</h2>\r\n<p>\r\n\t<span>You use the&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/struct\" target=\"_blank\">struct</a><span>,&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/class\" target=\"_blank\">class</a><span>,&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface\" target=\"_blank\">interface</a><span>, and&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum\" target=\"_blank\">enum</a>&nbsp;constructs to create your own custom types. The .NET class library itself is a collection of custom types provided by Microsoft that you can use in your own applications. By default, the most frequently used types in the class library are available in any C# program. Others become available only when you explicitly add a project reference to the assembly in which they are defined. After the compiler has a reference to the assembly, you can declare variables (and constants) of the types declared in that assembly in source code.&nbsp;<span>For more information, see&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/standard/class-library-overview\" target=\"_blank\">.NET Class Library</a><span>.</span></p>\r\n<p>\r\n\t&nbsp;</p>\r\n<h2>\r\n\tThe Common Type System</h2>\r\n<p>\r\n\tIt is important to understand two fundamental points about the type system in .NET:</p>\r\n<ul>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tIt supports the principle of inheritance. Types can derive from other types, called&nbsp;<em>base types</em>. The derived type inherits (with some restrictions) the methods, properties, and other members of the base type. The base type can in turn derive from some other type, in which case the derived type inherits the members of both base types in its inheritance hierarchy. All types, including built-in numeric types such as&nbsp;System.Int32&nbsp;(C# keyword:&nbsp;int), derive ultimately from a single base type, which is&nbsp;System.Object&nbsp;(C# keyword:&nbsp;object). This unified type hierarchy is called the&nbsp;Common Type System&nbsp;(CTS).&nbsp;</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tEach type in the CTS is defined as either a&nbsp;<em>value type</em>&nbsp;or a&nbsp;<em>reference type</em>. This includes all custom types in the .NET class library and also your own user-defined types. Types that you define by using the&nbsp;struct&nbsp;keyword are value types; all the built-in numeric types are&nbsp;<code>structs</code>. Types that you define by using the&nbsp;class&nbsp;keyword are reference types. Reference types and value types have different compile-time rules, and different run-time behavior.</p>\r\n\t</li>\r\n</ul>\r\n<p>\r\n\tThe following illustration shows the relationship between value types and reference types in the CTS.</p>\r\n<p>\r\n\t<img alt=\"Value Types and Reference Types\" data-linktype=\"relative-path\" src=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/media/valuetypescts.png\" style=\"border: 0px; box-sizing: inherit; max-width: 100%; height: auto; display: inline-block;\" title=\"ValueTypesCTS\" /><br />\r\n\tValue types and reference types in the CTS</p>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tYou can see that the most commonly used types are all organized in the&nbsp;System&nbsp;namespace. However, the namespace in which a type is contained has no relation to whether it is a value type or reference type.</p>\r\n</div>\r\n<h3>\r\n\tValue Types</h3>\r\n<p>\r\n\tValue types derive from&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.valuetype\" target=\"_blank\">System.ValueType</a>, which derives from&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.object\" target=\"_blank\">System.Object</a>. Types that derive from&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.valuetype\" target=\"_blank\">System.ValueType</a>&nbsp;have special behavior in the CLR. Value type variables directly contain their values, which means that the memory is allocated inline in whatever context the variable is declared. There is no separate heap allocation or garbage collection overhead for value-type variables.</p>\r\n<p>\r\n\tThere are two categories of value types:&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/struct\" target=\"_blank\">struct</a>&nbsp;and&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum\" target=\"_blank\">enum</a>.<span>There are two categories of value types:&nbsp;struct&nbsp;and&nbsp;enum.</span></p>\r\n<p>\r\n\t&nbsp;</p>\r\n<p>\r\n\tThe built-in numeric types are structs, and they have properties and methods that you can access:</p>\r\n<pre>\r\n<code><span>// Static method on type Byte.  </span>\r\n<span>byte</span> b = Byte.MaxValue;  \r\n</code></pre>\r\n<p>\r\n\tBut you declare and assign values to them as if they were simple non-aggregate types:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>byte</span> num = <span>0xA</span>;  \r\n<span>int</span> i = <span>5</span>;  \r\n<span>char</span> c = <span>&#39;Z&#39;</span>;  \r\n</code></pre>\r\n<p>\r\n\t<span>Value types are&nbsp;</span><em>sealed</em><span>, which means, for example, that you cannot derive a type from&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.int32\" target=\"_blank\">System.Int32</a><span>, and you cannot define a struct to inherit from any user-defined class or struct because a struct can only inherit from&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.valuetype\" target=\"_blank\">System.ValueType</a><span>. However, a struct can implement one or more interfaces. You can cast a struct type to any interface type that it implements; this causes a&nbsp;</span><em>boxing</em><span>&nbsp;operation to wrap the struct inside a reference type object on the managed heap. Boxing operations occur when you pass a value type to a method that takes a&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.object\" target=\"_blank\">System.Object</a><span>&nbsp;or any interface type as an input parameter. For more information, see&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing\" target=\"_blank\">Boxing and Unboxing</a><span>.</span>You use the&nbsp;struct&nbsp;keyword to create your own custom value types. Typically, a struct is used as a container for a small set of related variables, as shown in the following example:</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>struct</span> CoOrds\r\n{\r\n    <span>public</span> <span>int</span> x, y;\r\n\r\n    <span><span>public</span> <span>CoOrds</span>(<span><span>int</span> p1, <span>int</span> p2</span>)\r\n    </span>{\r\n        x = p1;\r\n        y = p2;\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tFor more information about structs, see&nbsp;Structs. For more information about value types in .NET, see&nbsp;Value Types.</p>\r\n<p>\r\n\tThe other category of value types is&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum\" target=\"_blank\">enum</a>. An enum defines a set of named integral constants. For example, the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.io.filemode\" target=\"_blank\">System.IO.FileMode</a>&nbsp;enumeration in the .NET class library contains a set of named constant integers that specify how a file should be opened. It is defined as shown in the following example:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>enum</span> FileMode\r\n{\r\n    CreateNew = <span>1</span>,\r\n    Create = <span>2</span>,\r\n    Open = <span>3</span>,\r\n    OpenOrCreate = <span>4</span>,\r\n    Truncate = <span>5</span>,\r\n    Append = <span>6</span>,\r\n}\r\n</code></pre>\r\n<p>\r\n\tThe&nbsp;<code>System.IO.FileMode.Create</code>&nbsp;constant has a value of 2. However, the name is much more meaningful for humans reading the source code, and for that reason it is better to use enumerations instead of constant literal numbers.</p>\r\n<p>\r\n\tAll enums inherit from&nbsp;System.Enum, which inherits from&nbsp;System.ValueType. All the rules that apply to structs also apply to enums.</p>\r\n<h3>\r\n\tReference Types</h3>\r\n<p>\r\n\tA type that is defined as a&nbsp;class,&nbsp;delegate, array, or&nbsp;interface&nbsp;is a&nbsp;<em>reference type</em>. At run time, when you declare a variable of a reference type, the variable contains the value&nbsp;null&nbsp;until you explicitly create an object by using the&nbsp;new&nbsp;operator, or assign it an object that has been created elsewhere by using&nbsp;<code>new</code>, as shown in the following example:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>MyClass mc = <span>new</span> MyClass();  \r\nMyClass mc2 = mc;  \r\n</code></pre>\r\n<p>\r\n\tAn interface must be initialized together with a class object that implements it. If&nbsp;<code>MyClass</code>&nbsp;implements&nbsp;<code>IMyInterface</code>, you create an instance of&nbsp;<code>IMyInterface</code>&nbsp;as shown in the following example:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>IMyInterface iface = <span>new</span> MyClass();  \r\n</code></pre>\r\n<p>\r\n\tWhen the object is created, the memory is allocated on the managed heap, and the variable holds only a reference to the location of the object. Types on the managed heap require overhead both when they are allocated and when they are reclaimed by the automatic memory management functionality of the CLR, which is known as&nbsp;<em>garbage collection</em>. However, garbage collection is also highly optimized, and in most scenarios it does not create a performance issue. For more information about garbage collection, see&nbsp;Automatic Memory Management.</p>\r\n<p>\r\n\tAll arrays are reference types, even if their elements are value types. Arrays implicitly derive from the&nbsp;System.Array&nbsp;class, but you declare and use them with the simplified syntax that is provided by C#, as shown in the following example:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Declare and initialize an array of integers.</span>\r\n<span>int</span>[] nums = { <span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span> };\r\n\r\n<span>// Access an instance property of System.Array.</span>\r\n<span>int</span> len = nums.Length;\r\n</code></pre>\r\n<p>\r\n\tReference types fully support inheritance. When you create a class, you can inherit from any other interface or class that is not defined as&nbsp;sealed, and other classes can inherit from your class and override your virtual methods. For more information about how to create your own classes, see&nbsp;Classes and Structs. For more information about inheritance and virtual methods, see&nbsp;Inheritance.</p>\r\n<h2>\r\n\tTypes of Literal Values</h2>\r\n<p>\r\n\tIn C#, literal values receive a type from the compiler. You can specify how a numeric literal should be typed by appending a letter to the end of the number. For example, to specify that the value 4.56 should be treated as a float, append an &quot;f&quot; or &quot;F&quot; after the number:&nbsp;<code>4.56f</code>. If no letter is appended, the compiler will infer a type for the literal. For more information about which types can be specified with letter suffixes, see the reference pages for individual types in&nbsp;Value Types.</p>\r\n<p>\r\n\tBecause literals are typed, and all types derive ultimately from&nbsp;System.Object, you can write and compile code such as the following:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> s = <span>&quot;The answer is &quot;</span> + <span>5.</span>ToString();\r\n<span>// Outputs: &quot;The answer is 5&quot;</span>\r\nConsole.WriteLine(s);\r\n\r\nType type = <span>12345.</span>GetType();\r\n<span>// Outputs: &quot;System.Int32&quot;</span>\r\nConsole.WriteLine(type);\r\n</code></pre>\r\n<h2>\r\n\tGeneric Types</h2>\r\n<p>\r\n\tA type can be declared with one or more&nbsp;<em>type parameters</em>&nbsp;that serve as a placeholder for the actual type (the&nbsp;<em>concrete type</em>) that client code will provide when it creates an instance of the type. Such types are called&nbsp;<em>generic types</em>. For example, the .NET type&nbsp;System.Collections.Generic.List&lt;T&gt;&nbsp;has one type parameter that by convention is given the name&nbsp;<em>T</em>. When you create an instance of the type, you specify the type of the objects that the list will contain, for example, string:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>List&lt;<span>string</span>&gt; stringList = <span>new</span> List&lt;<span>string</span>&gt;();\r\nstringList.Add(<span>&quot;String example&quot;</span>);\r\n<span>// compile time error adding a type other than a string:</span>\r\nstringList.Add(<span>4</span>);\r\n</code></pre>\r\n<p>\r\n\tThe use of the type parameter makes it possible to reuse the same class to hold any type of element, without having to convert each element to&nbsp;object. Generic collection classes are called&nbsp;<em>strongly-typed collections</em>&nbsp;because the compiler knows the specific type of the collection&#39;s elements and can raise an error at compile-time if, for example, you try to add an integer to the&nbsp;<code>stringList</code>&nbsp;object in the previous example.</p>\r\n<h2>\r\n\tImplicit Types, Anonymous Types, and Nullable Types</h2>\r\n<p>\r\n\tAs stated previously, you can implicitly type a local variable (but not class members) by using the&nbsp;varkeyword. The variable still receives a type at compile time, but the type is provided by the compiler.</p>\r\n<p>\r\n\tIn some cases, it is inconvenient to create a named type for simple sets of related values that you do not intend to store or pass outside method boundaries. You can create&nbsp;<em>anonymous types</em>&nbsp;for this purpose.</p>\r\n<p>\r\n\tAs stated previously, you can implicitly type a local variable (but not class members) by using the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/var\" target=\"_blank\">var</a>keyword. The variable still receives a type at compile time, but the type is provided by the compiler. For more information, see&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables\" target=\"_blank\">Implicitly Typed Local Variables</a>.</p>\r\n<p>\r\n\tIn some cases, it is inconvenient to create a named type for simple sets of related values that you do not intend to store or pass outside method boundaries. You can create&nbsp;<em>anonymous types</em>&nbsp;for this purpose. For more information, see&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/anonymous-types\" target=\"_blank\">Anonymous Types</a>.</p>\r\n<p>\r\n\tOrdinary value types cannot have a value of&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/null\" target=\"_blank\">null</a>. However, you can create nullable value types by affixing a&nbsp;<code>?</code>&nbsp;after the type. For example,&nbsp;<code>int?</code>&nbsp;is an&nbsp;<code>int</code>&nbsp;type that can also have the value&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/null\" target=\"_blank\">null</a>. In the CTS, nullable types are instances of the generic struct type&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.nullable-1\" target=\"_blank\">System.Nullable&lt;T&gt;</a>. Nullable types are especially useful when you are passing data to and from databases in which numeric values might be null. For more information, see&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/nullable-types/index\" target=\"_blank\">Nullable Types</a>.</p>"
          },
          {
            "Casting and Type Conversions": "<p>\r\n\tBecause C# is statically-typed at compile time, after a variable is declared, it cannot be declared again or assigned a value of another type unless that type is implicitly convertible to the variable&#39;s type. For example, the&nbsp;<code>string</code>&nbsp;cannot be implicitly converted to&nbsp;<code>int</code>. Therefore, after you declare&nbsp;<code>i</code>&nbsp;as an&nbsp;<code>int</code>, you cannot assign the string &quot;Hello&quot; to it, as the following code shows:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>int</span> i;  \r\ni = <span>&quot;Hello&quot;</span>; <span>// error CS0029: Cannot implicitly convert type &#39;string&#39; to &#39;int&#39;</span>\r\n</code></pre>\r\n<p>\r\n\tHowever, you might sometimes need to copy a value into a variable or method parameter of another type. For example, you might have an integer variable that you need to pass to a method whose parameter is typed as&nbsp;<code>double</code>. Or you might need to assign a class variable to a variable of an interface type. These kinds of operations are called&nbsp;<em>type conversions</em>. In C#, you can perform the following kinds of conversions:</p>\r\n<ul>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\t<span>Implicit conversions</span>: No special syntax is required because the conversion is type safe and no data will be lost. Examples include conversions from smaller to larger integral types, and conversions from derived classes to base classes.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\t<span>Explicit conversions (casts)</span>: Explicit conversions require a cast operator. Casting is required when information might be lost in the conversion, or when the conversion might not succeed for other reasons. Typical examples include numeric conversion to a type that has less precision or a smaller range, and conversion of a base-class instance to a derived class.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\t<span>User-defined conversions</span>: User-defined conversions are performed by special methods that you can define to enable explicit and implicit conversions between custom types that do not have a base class&ndash;derived class relationship.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\t<span>Conversions with helper classes</span>: To convert between non-compatible types, such as integers and&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.datetime\" target=\"_blank\">System.DateTime</a><span>&nbsp;objects, or hexadecimal strings and byte arrays, you can use the&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.bitconverter\" target=\"_blank\">System.BitConverter</a><span>&nbsp;class, the&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.convert\" target=\"_blank\">System.Convert</a><span>&nbsp;class, and the&nbsp;</span><code>Parse</code><span>&nbsp;methods of the built-in numeric types, such as&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.int32.parse\" target=\"_blank\">Int32.Parse</a><span>. For more information, see&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/how-to-convert-a-byte-array-to-an-int\" target=\"_blank\">How to: Convert a byte Array to an int</a><span>,&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/how-to-convert-a-string-to-a-number\" target=\"_blank\">How to: Convert a String to a Number</a><span>, and&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/how-to-convert-between-hexadecimal-strings-and-numeric-types\" target=\"_blank\">How to: Convert Between Hexadecimal Strings and Numeric Types</a><span>.</span></p>\r\n\t</li>\r\n</ul>\r\n<h2>\r\n\tImplicit Conversions</h2>\r\n<p>\r\n\tFor built-in numeric types, an implicit conversion can be made when the value to be stored can fit into the variable without being truncated or rounded off. For example, a variable of type&nbsp;long&nbsp;(64-bit integer) can store any value that an&nbsp;int&nbsp;(32-bit integer) can store. In the following example, the compiler implicitly converts the value of&nbsp;<code>num</code>&nbsp;on the right to a type&nbsp;<code>long</code>&nbsp;before assigning it to&nbsp;<code>bigNum</code>.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Implicit conversion. A long can</span>\r\n<span>// hold any value an int can hold, and more!</span>\r\n<span>int</span> num = <span>2147483647</span>;\r\n<span>long</span> bigNum = num;\r\n</code></pre>\r\n<p>\r\n\tFor a complete list of all implicit numeric conversions, see&nbsp;Implicit Numeric Conversions Table.</p>\r\n<p>\r\n\tFor reference types, an implicit conversion always exists from a class to any one of its direct or indirect base classes or interfaces. No special syntax is necessary because a derived class always contains all the members of a base class.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>Derived d = new Derived();  \r\nBase b = d; // Always OK.  \r\n</code></pre>\r\n<h2>\r\n\tExplicit Conversions</h2>\r\n<p>\r\n\tHowever, if a conversion cannot be made without a risk of losing information, the compiler requires that you perform an explicit conversion, which is called a&nbsp;<em>cast</em>. A cast is a way of explicitly informing the compiler that you intend to make the conversion and that you are aware that data loss might occur. To perform a cast, specify the type that you are casting to in parentheses in front of the value or variable to be converted. The following program casts a&nbsp;double&nbsp;to an&nbsp;int. The program will not compile without the cast.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>Test</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>double</span> x = <span>1234.7</span>;\r\n        <span>int</span> a;\r\n        <span>// Cast double to int.</span>\r\n        a = (<span>int</span>)x;\r\n        System.Console.WriteLine(a);\r\n    }\r\n}\r\n<span>// Output: 1234</span>\r\n</code></pre>\r\n<p>\r\n\tFor a list of the explicit numeric conversions that are allowed, see&nbsp;Explicit Numeric Conversions Table.</p>\r\n<p>\r\n\tFor reference types, an explicit cast is required if you need to convert from a base type to a derived type:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Create a new derived type.  </span>\r\nGiraffe g = <span>new</span> Giraffe();  \r\n  \r\n<span>// Implicit conversion to base type is safe.  </span>\r\nAnimal a = g;  \r\n  \r\n<span>// Explicit conversion is required to cast back  </span>\r\n<span>// to derived type. Note: This will compile but will  </span>\r\n<span>// throw an exception at run time if the right-side  </span>\r\n<span>// object is not in fact a Giraffe.  </span>\r\nGiraffe g2 = (Giraffe) a;  \r\n</code></pre>\r\n<p>\r\n\tA cast operation between reference types does not change the run-time type of the underlying object; it only changes the type of the value that is being used as a reference to that object. For more information,&nbsp;<span>see&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/polymorphism\" target=\"_blank\">Polymorphism</a><span>.</span></p>\r\n<h2>\r\n\tType Conversion Exceptions at Run Time</h2>\r\n<p>\r\n\tIn some reference type conversions, the compiler cannot determine whether a cast will be valid. It is possible for a cast operation that compiles correctly to fail at run time. As shown in the following example, a type cast that fails at run time will cause an&nbsp;InvalidCastException&nbsp;to be thrown.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>\r\n<span>using</span> System;\r\n\r\n<span>class</span> <span>Animal</span>\r\n{\r\n    <span><span>public</span> <span>void</span> <span>Eat</span>() </span>{ Console.WriteLine(<span>&quot;Eating.&quot;</span>); }\r\n    <span><span>public</span> <span>override</span> <span>string</span> <span>ToString</span>()\r\n    </span>{\r\n        <span>return</span> <span>&quot;I am an animal.&quot;</span>;\r\n    }\r\n}\r\n<span>class</span> <span>Reptile</span> : <span>Animal</span> { }\r\n<span>class</span> <span>Mammal</span> : <span>Animal</span> { }\r\n\r\n<span>class</span> <span>UnSafeCast</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{            \r\n        Test(<span>new</span> Mammal());\r\n\r\n        <span>// Keep the console window open in debug mode.</span>\r\n        Console.WriteLine(<span>&quot;Press any key to exit.&quot;</span>);\r\n        Console.ReadKey();\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>Test</span>(<span>Animal a</span>)\r\n    </span>{\r\n        <span>// Cause InvalidCastException at run time </span>\r\n        <span>// because Mammal is not convertible to Reptile.</span>\r\n        Reptile r = (Reptile)a;\r\n    }\r\n\r\n}\r\n</code></pre>\r\n<p>\r\n\tC# provides the&nbsp;is&nbsp;and&nbsp;as&nbsp;operators to enable you to test for compatibility before actually performing a cast.</p>"
          },
          {
            "Boxing and Unboxing": "<p>\r\n\tBoxing is the process of converting&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types\" target=\"_blank\">value type</a>&nbsp; to the type&nbsp;<code>object</code>&nbsp;or to any interface type implemented by this value type. When the CLR boxes a value type, it wraps the value inside a System.Object and stores it on the managed heap. Unboxing extracts the value type from the object. Boxing is implicit; unboxing is explicit. The concept of boxing and unboxing underlies the C# unified view of the type system in which a value of any type can be treated as an object.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<p>\r\n\tIn the following example, the integer variable&nbsp;<code>i</code>&nbsp;is&nbsp;<em>boxed</em>&nbsp;and assigned to object&nbsp;<code>o</code>.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>int</span> i = <span>123</span>;\r\n<span>// The following line boxes i.</span>\r\n<span>object</span> o = i;  \r\n</code></pre>\r\n<p>\r\n\tThe object&nbsp;<code>o</code>&nbsp;can then be unboxed and assigned to integer variable&nbsp;<code>i</code>:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>o = <span>123</span>;\r\ni = (<span>int</span>)o;  <span>// unboxing</span>\r\n</code></pre>\r\n<p>\r\n\tThe following examples illustrate how boxing is used in C#.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// String.Concat example.</span>\r\n<span>// String.Concat has many versions. Rest the mouse pointer on </span>\r\n<span>// Concat in the following statement to verify that the version</span>\r\n<span>// that is used here takes three object arguments. Both 42 and</span>\r\n<span>// true must be boxed.</span>\r\nConsole.WriteLine(String.Concat(<span>&quot;Answer&quot;</span>, <span>42</span>, <span>true</span>));\r\n\r\n\r\n<span>// List example.</span>\r\n<span>// Create a list of objects to hold a heterogeneous collection </span>\r\n<span>// of elements.</span>\r\nList&lt;<span>object</span>&gt; mixedList = <span>new</span> List&lt;<span>object</span>&gt;();\r\n\r\n<span>// Add a string element to the list. </span>\r\nmixedList.Add(<span>&quot;First Group:&quot;</span>);\r\n\r\n<span>// Add some integers to the list. </span>\r\n<span>for</span> (<span>int</span> j = <span>1</span>; j &lt; <span>5</span>; j++)\r\n{\r\n    <span>// Rest the mouse pointer over j to verify that you are adding</span>\r\n    <span>// an int to a list of objects. Each element j is boxed when </span>\r\n    <span>// you add j to mixedList.</span>\r\n    mixedList.Add(j);\r\n}\r\n\r\n<span>// Add another string and more integers.</span>\r\nmixedList.Add(<span>&quot;Second Group:&quot;</span>);\r\n<span>for</span> (<span>int</span> j = <span>5</span>; j &lt; <span>10</span>; j++)\r\n{\r\n    mixedList.Add(j);\r\n}\r\n\r\n<span>// Display the elements in the list. Declare the loop variable by </span>\r\n<span>// using var, so that the compiler assigns its type.</span>\r\n<span>foreach</span> (<span>var</span> item <span>in</span> mixedList)\r\n{\r\n    <span>// Rest the mouse pointer over item to verify that the elements</span>\r\n    <span>// of mixedList are objects.</span>\r\n    Console.WriteLine(item);\r\n}\r\n\r\n<span>// The following loop sums the squares of the first group of boxed</span>\r\n<span>// integers in mixedList. The list elements are objects, and cannot</span>\r\n<span>// be multiplied or added to the sum until they are unboxed. The</span>\r\n<span>// unboxing must be done explicitly.</span>\r\n<span>var</span> sum = <span>0</span>;\r\n<span>for</span> (<span>var</span> j = <span>1</span>; j &lt; <span>5</span>; j++)\r\n{\r\n    <span>// The following statement causes a compiler error: Operator </span>\r\n    <span>// &#39;*&#39; cannot be applied to operands of type &#39;object&#39; and</span>\r\n    <span>// &#39;object&#39;. </span>\r\n    <span>//sum += mixedList[j] * mixedList[j]);</span>\r\n\r\n    <span>// After the list elements are unboxed, the computation does </span>\r\n    <span>// not cause a compiler error.</span>\r\n    sum += (<span>int</span>)mixedList[j] * (<span>int</span>)mixedList[j];\r\n}\r\n\r\n<span>// The sum displayed is 30, the sum of 1 + 4 + 9 + 16.</span>\r\nConsole.WriteLine(<span>&quot;Sum: &quot;</span> + sum);\r\n\r\n<span>// Output:</span>\r\n<span>// Answer42True</span>\r\n<span>// First Group:</span>\r\n<span>// 1</span>\r\n<span>// 2</span>\r\n<span>// 3</span>\r\n<span>// 4</span>\r\n<span>// Second Group:</span>\r\n<span>// 5</span>\r\n<span>// 6</span>\r\n<span>// 7</span>\r\n<span>// 8</span>\r\n<span>// 9</span>\r\n<span>// Sum: 30</span>\r\n</code></pre>\r\n<h2>\r\n\tPerformance</h2>\r\n<p>\r\n\tIn relation to simple assignments, boxing and unboxing are computationally expensive processes. When a&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types\" target=\"_blank\">value type</a>&nbsp;is boxed, a new object must be allocated and constructed. To a lesser degree, the cast required for unboxing is also expensive computationally.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<h2>\r\n\tBoxing</h2>\r\n<p>\r\n\tBoxing is used to store&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types\" target=\"_blank\">value type</a>s in the garbage-collected heap. Boxing is an implicit conversion of a&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types\" target=\"_blank\">value type</a>&nbsp;to the type&nbsp;<code>object</code>&nbsp;or to any interface type implemented by this value type. Boxing a value type allocates an object instance on the heap and copies the value into the new object.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<p>\r\n\tConsider the following declaration of a value-type variable:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>int</span> i = <span>123</span>;\r\n</code></pre>\r\n<p>\r\n\tThe following statement implicitly applies the boxing operation on the variable&nbsp;<code>i</code>:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Boxing copies the value of i into object o.</span>\r\n<span>object</span> o = i;  \r\n</code></pre>\r\n<p>\r\n\tThe result of this statement is creating an object reference&nbsp;<code>o</code>, on the stack, that references a value of the type&nbsp;<code>int</code>, on the heap. This value is a copy of the value-type value assigned to the variable&nbsp;<code>i</code>. The difference between the two variables,&nbsp;<code>i</code>&nbsp;and&nbsp;<code>o</code>, is illustrated in the following figure.</p>\r\n<p>\r\n\t<img alt=\"BoxingConversion graphic\" data-linktype=\"relative-path\" src=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/media/vcboxingconversion.gif\" style=\"border: 0px; box-sizing: inherit; max-width: 100%; height: auto; display: inline-block;\" title=\"vcBoxingConversion\" /><br />\r\n\tBoxing Conversion</p>\r\n<p>\r\n\tIt is also possible to perform the boxing explicitly as in the following example, but explicit boxing is never required:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>int</span> i = <span>123</span>;\r\n<span>object</span> o = (<span>object</span>)i;  <span>// explicit boxing</span>\r\n</code></pre>\r\n<h2>\r\n\tDescription</h2>\r\n<p>\r\n\tThis example converts an integer variable&nbsp;<code>i</code>&nbsp;to an object&nbsp;<code>o</code>&nbsp;by using boxing. Then, the value stored in the variable&nbsp;<code>i</code>&nbsp;is changed from&nbsp;<code>123</code>&nbsp;to&nbsp;<code>456</code>. The example shows that the original&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types\" target=\"_blank\">value type</a>&nbsp;and the boxed object use separate memory locations, and therefore can store different values.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<h2>\r\n\tExample</h2>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>TestBoxing</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>int</span> i = <span>123</span>;\r\n\r\n        <span>// Boxing copies the value of i into object o.</span>\r\n        <span>object</span> o = i;  \r\n\r\n        <span>// Change the value of i.</span>\r\n        i = <span>456</span>;  \r\n\r\n        <span>// The change in i doesn&#39;t affect the value stored in o.</span>\r\n        System.Console.WriteLine(<span>&quot;The value-type value = {0}&quot;</span>, i);\r\n        System.Console.WriteLine(<span>&quot;The object-type value = {0}&quot;</span>, o);\r\n    }\r\n}\r\n<span>/* Output:\r\n    The value-type value = 456\r\n    The object-type value = 123\r\n*/</span>\r\n</code></pre>\r\n<h2>\r\n\tUnboxing</h2>\r\n<p>\r\n\tUnboxing is an explicit conversion from the type&nbsp;<code>object</code>&nbsp;to a&nbsp;value type&nbsp;or from an interface type to a value type that implements the interface. An unboxing operation consists of:</p>\r\n<ul>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tChecking the object instance to make sure that it is a boxed value of the given value type.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tCopying the value from the instance into the value-type variable.</p>\r\n\t</li>\r\n</ul>\r\n<p>\r\n\tThe following statements demonstrate both boxing and unboxing operations:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>int</span> i = <span>123</span>;      <span>// a value type</span>\r\n<span>object</span> o = i;     <span>// boxing</span>\r\n<span>int</span> j = (<span>int</span>)o;   <span>// unboxing</span>\r\n</code></pre>\r\n<p>\r\n\tThe following figure demonstrates the result of the previous statements.</p>\r\n<p>\r\n\t<img alt=\"UnBoxing Conversion graphic\" data-linktype=\"relative-path\" src=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/media/vcunboxingconversion.gif\" style=\"border: 0px; box-sizing: inherit; max-width: 100%; height: auto; display: inline-block;\" title=\"vcUnBoxingConversion\" /><br />\r\n\tUnboxing Conversion</p>\r\n<p>\r\n\tFor the unboxing of value types to succeed at run time, the item being unboxed must be a reference to an object that was previously created by boxing an instance of that value type. Attempting to unbox&nbsp;<code>null</code>&nbsp;causes a&nbsp;<span>&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.nullreferenceexception\" target=\"_blank\">NullReferenceException</a>. Attempting to unbox a reference to an incompatible value type causes an&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.invalidcastexception\" target=\"_blank\">InvalidCastException</a>.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example demonstrates a case of invalid unboxing and the resulting&nbsp;<code>InvalidCastException</code>. Using&nbsp;<code>try</code>&nbsp;and&nbsp;<code>catch</code>, an error message is displayed when the error occurs.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>TestUnboxing</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>int</span> i = <span>123</span>;\r\n        <span>object</span> o = i;  <span>// implicit boxing</span>\r\n\r\n        <span>try</span>\r\n        {\r\n            <span>int</span> j = (<span>short</span>)o;  <span>// attempt to unbox</span>\r\n\r\n            System.Console.WriteLine(<span>&quot;Unboxing OK.&quot;</span>);\r\n        }\r\n        <span>catch</span> (System.InvalidCastException e)\r\n        {\r\n            System.Console.WriteLine(<span>&quot;{0} Error: Incorrect unboxing.&quot;</span>, e.Message);\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tThis program outputs:</p>\r\n<p>\r\n\t<code>Specified cast is not valid. Error: Incorrect unboxing.</code></p>\r\n<p>\r\n\tIf you change the statement:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>int</span> j = (<span>short</span>) o;  \r\n</code></pre>\r\n<p>\r\n\tto:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>int</span> j = (<span>int</span>) o;  \r\n</code></pre>\r\n<p>\r\n\tthe conversion will be performed, and you will get the output:</p>\r\n<p>\r\n\t<code>Unboxing OK.</code></p>"
          },
          {
            "Using type dynamic": "<p>\r\n\tC# 4 introduces a new type,&nbsp;<code>dynamic</code>. The type is a static type, but an object of type&nbsp;<code>dynamic</code>bypasses static type checking. In most cases, it functions like it has type&nbsp;<code>object</code>. At compile time, an element that is typed as&nbsp;<code>dynamic</code>&nbsp;is assumed to support any operation. Therefore, you do not have to be concerned about whether the object gets its value from a COM API, from a dynamic language such as IronPython, from the HTML Document Object Model (DOM), from reflection, or from somewhere else in the program. However, if the code is not valid, errors are caught at run time.</p>\r\n<p>\r\n\tFor example, if instance method&nbsp;<code>exampleMethod1</code>&nbsp;in the following code has only one parameter, the compiler recognizes that the first call to the method,&nbsp;<code>ec.exampleMethod1(10, 4)</code>, is not valid because it contains two arguments. The call causes a compiler error. The second call to the method,&nbsp;<code>dynamic_ec.exampleMethod1(10, 4)</code>, is not checked by the compiler because the type of&nbsp;<code>dynamic_ec</code>&nbsp;is&nbsp;<code>dynamic</code>. Therefore, no compiler error is reported. However, the error does not escape notice indefinitely. It is caught at run time and causes a run-time exception.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)\r\n</span>{\r\n    ExampleClass ec = <span>new</span> ExampleClass();\r\n    <span>// The following call to exampleMethod1 causes a compiler error </span>\r\n    <span>// if exampleMethod1 has only one parameter. Uncomment the line</span>\r\n    <span>// to see the error.</span>\r\n    <span>//ec.exampleMethod1(10, 4);</span>\r\n\r\n    <span>dynamic</span> dynamic_ec = <span>new</span> ExampleClass();\r\n    <span>// The following line is not identified as an error by the</span>\r\n    <span>// compiler, but it causes a run-time exception.</span>\r\n    dynamic_ec.exampleMethod1(<span>10</span>, <span>4</span>);\r\n\r\n    <span>// The following calls also do not cause compiler errors, whether </span>\r\n    <span>// appropriate methods exist or not.</span>\r\n    dynamic_ec.someMethod(<span>&quot;some argument&quot;</span>, <span>7</span>, <span>null</span>);\r\n    dynamic_ec.nonexistentMethod();\r\n}\r\n</code></pre>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>ExampleClass</span>\r\n{\r\n    <span><span>public</span> <span>ExampleClass</span>() </span>{ }\r\n    <span><span>public</span> <span>ExampleClass</span>(<span><span>int</span> v</span>) </span>{ }\r\n\r\n    <span><span>public</span> <span>void</span> <span>exampleMethod1</span>(<span><span>int</span> i</span>) </span>{ }\r\n\r\n    <span><span>public</span> <span>void</span> <span>exampleMethod2</span>(<span><span>string</span> str</span>) </span>{ }\r\n}\r\n</code></pre>\r\n<p>\r\n\tThe role of the compiler in these examples is to package together information about what each statement is proposing to do to the object or expression that is typed as&nbsp;<code>dynamic</code>. At run time, the stored information is examined, and any statement that is not valid causes a run-time exception.</p>\r\n<p>\r\n\tThe result of most dynamic operations is itself&nbsp;<code>dynamic</code>. For example, if you rest the mouse pointer over the use of&nbsp;<code>testSum</code>&nbsp;in the following example, IntelliSense displays the type&nbsp;<span>(local variable) dynamic testSum</span>.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>dynamic</span> d = <span>1</span>;\r\n<span>var</span> testSum = d + <span>3</span>;\r\n<span>// Rest the mouse pointer over testSum in the following statement.</span>\r\nSystem.Console.WriteLine(testSum);\r\n</code></pre>\r\n<p>\r\n\tOperations in which the result is not&nbsp;<code>dynamic</code>&nbsp;include:</p>\r\n<ul>\r\n\t<li>\r\n\t\tConversions from&nbsp;<code>dynamic</code>&nbsp;to another type.</li>\r\n\t<li>\r\n\t\tConstructor calls that include arguments of type&nbsp;<code>dynamic</code>.</li>\r\n</ul>\r\n<p>\r\n\tFor example, the type of&nbsp;<code>testInstance</code>&nbsp;in the following declaration is&nbsp;<code>ExampleClass</code>, not&nbsp;<code>dynamic</code>:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>var</span> testInstance = <span>new</span> ExampleClass(d);\r\n</code></pre>\r\n<p>\r\n\tConversion examples are shown in the following section, &quot;Conversions.&quot;</p>\r\n<h2>\r\n\tConversions</h2>\r\n<p>\r\n\tConversions between dynamic objects and other types are easy. This enables the developer to switch between dynamic and non-dynamic behavior.</p>\r\n<p>\r\n\tAny object can be converted to dynamic type implicitly, as shown in the following examples.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>dynamic</span> d1 = <span>7</span>;\r\n<span>dynamic</span> d2 = <span>&quot;a string&quot;</span>;\r\n<span>dynamic</span> d3 = System.DateTime.Today;\r\n<span>dynamic</span> d4 = System.Diagnostics.Process.GetProcesses();\r\n</code></pre>\r\n<p>\r\n\tConversely, an implicit conversion can be dynamically applied to any expression of type&nbsp;<code>dynamic</code>.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>int</span> i = d1;\r\n<span>string</span> str = d2;\r\nDateTime dt = d3;\r\nSystem.Diagnostics.Process[] procs = d4;\r\n</code></pre>\r\n<h2>\r\n\tOverload resolution with arguments of type dynamic</h2>\r\n<p>\r\n\tOverload resolution occurs at run time instead of at compile time if one or more of the arguments in a method call have the type&nbsp;<code>dynamic</code>, or if the receiver of the method call is of type&nbsp;<code>dynamic</code>. In the following example, if the only accessible&nbsp;<code>exampleMethod2</code>&nbsp;method is defined to take a string argument, sending&nbsp;<code>d1</code>&nbsp;as the argument does not cause a compiler error, but it does cause a run-time exception. Overload resolution fails at run time because the run-time type of&nbsp;<code>d1</code>&nbsp;is&nbsp;<code>int</code>, and&nbsp;<code>exampleMethod2</code>requires a string.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Valid.</span>\r\nec.exampleMethod2(<span>&quot;a string&quot;</span>);\r\n\r\n<span>// The following statement does not cause a compiler error, even though ec is not</span>\r\n<span>// dynamic. A run-time exception is raised because the run-time type of d1 is int.</span>\r\nec.exampleMethod2(d1);\r\n<span>// The following statement does cause a compiler error.</span>\r\n<span>//ec.exampleMethod2(7);</span>\r\n</code></pre>\r\n<h2>\r\n\tDynamic language runtime</h2>\r\n<p>\r\n\tThe dynamic language runtime (DLR) is a new API in .NET Framework 4. It provides the infrastructure that supports the&nbsp;<code>dynamic</code>&nbsp;type in C#, and also the implementation of dynamic programming languages such as IronPython and IronRuby.&nbsp;</p>\r\n<h2>\r\n\tCOM interop</h2>\r\n<p>\r\n\tC# 4 includes several features that improve the experience of interoperating with COM APIs such as the Office Automation APIs. Among the improvements are the use of the&nbsp;<code>dynamic</code>&nbsp;type, and of&nbsp;named and optional arguments.</p>\r\n<p>\r\n\tMany COM methods allow for variation in argument types and return type by designating the types as&nbsp;<code>object</code>. This has necessitated explicit casting of the values to coordinate with strongly typed variables in C#. If you compile by using the&nbsp;/link (C# Compiler Options)&nbsp;option, the introduction of the&nbsp;<code>dynamic</code>type enables you to treat the occurrences of&nbsp;<code>object</code>&nbsp;in COM signatures as if they were of type&nbsp;<code>dynamic</code>, and thereby to avoid much of the casting. For example, the following statements contrast how you access a cell in a Microsoft Office Excel spreadsheet with the&nbsp;<code>dynamic</code>&nbsp;type and without the&nbsp;<code>dynamic</code>&nbsp;type.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Before the introduction of dynamic.</span>\r\n((Excel.Range)excelApp.Cells[<span>1</span>, <span>1</span>]).Value2 = <span>&quot;Name&quot;</span>;\r\nExcel.Range range2008 = (Excel.Range)excelApp.Cells[<span>1</span>, <span>1</span>];\r\n</code></pre>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// After the introduction of dynamic, the access to the Value property and</span>\r\n<span>// the conversion to Excel.Range are handled by the run-time COM binder.</span>\r\nexcelApp.Cells[<span>1</span>, <span>1</span>].Value = <span>&quot;Name&quot;</span>;\r\nExcel.Range range2010 = excelApp.Cells[<span>1</span>, <span>1</span>];</code></pre>"
          },
          {
            "Walkthrough: Creating and Using Dynamic Objects": "<p>\r\n\tDynamic objects expose members such as properties and methods at run time, instead of in at compile time. This enables you to create objects to work with structures that do not match a static type or format. For example, you can use a dynamic object to reference the HTML Document Object Model (DOM), which can contain any combination of valid HTML markup elements and attributes. Because each HTML document is unique, the members for a particular HTML document are determined at run time. A common method to reference an attribute of an HTML element is to pass the name of the attribute to the&nbsp;<code>GetProperty</code>&nbsp;method of the element. To reference the&nbsp;<code>id</code>&nbsp;attribute of the HTML element&nbsp;<code>&lt;div id=&quot;Div1&quot;&gt;</code>, you first obtain a reference to the&nbsp;<code>&lt;div&gt;</code>&nbsp;element, and then use&nbsp;<code>divElement.GetProperty(&quot;id&quot;)</code>. If you use a dynamic object, you can reference the&nbsp;<code>id</code>&nbsp;attribute as&nbsp;<code>divElement.id</code>.</p>\r\n<p>\r\n\tDynamic objects also provide convenient access to dynamic languages such as IronPython and IronRuby. You can use a dynamic object to refer to a dynamic script that is interpreted at run time.</p>\r\n<p>\r\n\tYou reference a dynamic object by using late binding. In C#, you specify the type of a late-bound object as&nbsp;<code>dynamic</code>. In Visual Basic, you specify the type of a late-bound object as&nbsp;<code>Object</code>. For more information, see&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/dynamic\" target=\"_blank\">dynamic</a>&nbsp;and&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/visual-basic/programming-guide/language-features/early-late-binding/index\" target=\"_blank\">Early and Late Binding</a>.</p>\r\n<p>\r\n\tYou can create custom dynamic objects by using the classes in the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.dynamic\" target=\"_blank\">System.Dynamic</a>&nbsp;namespace. For example, you can create an&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.dynamic.expandoobject\" target=\"_blank\">ExpandoObject</a>&nbsp;and specify the members of that object at run time. You can also create your own type that inherits the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.dynamic.dynamicobject\" target=\"_blank\">DynamicObject</a>&nbsp;class. You can then override the members of the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.dynamic.dynamicobject\" target=\"_blank\">DynamicObject</a>&nbsp;class to provide run-time dynamic functionality.<span>In this walkthrough you will perform the following tasks:</span></p>\r\n<p>\r\n\t&nbsp;</p>\r\n<ul>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tCreate a custom object that dynamically exposes the contents of a text file as properties of an object.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tCreate a project that uses an&nbsp;<code>IronPython</code>&nbsp;library.</p>\r\n\t</li>\r\n</ul>\r\n<h2>\r\n\tPrerequisites</h2>\r\n<p>\r\n\tYou need&nbsp;IronPython&nbsp;for .NET to complete this walkthrough. Go to their&nbsp;Download page&nbsp;to obtain the latest version.</p>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tYour computer might show different names or locations for some of the Visual Studio user interface elements in the following instructions. The Visual Studio edition that you have and the settings that you use determine these elements. For more information, see&nbsp;Personalizing the IDE.</p>\r\n</div>\r\n<h2>\r\n\tCreating a Custom Dynamic Object</h2>\r\n<p>\r\n\tThe first project that you create in this walkthrough defines a custom dynamic object that searches the contents of a text file. Text to search for is specified by the name of a dynamic property. For example, if calling code specifies&nbsp;<code>dynamicFile.Sample</code>, the dynamic class returns a generic list of strings that contains all of the lines from the file that begin with &quot;Sample&quot;. The search is case-insensitive. The dynamic class also supports two optional arguments. The first argument is a search option enum value that specifies that the dynamic class should search for matches at the start of the line, the end of the line, or anywhere in the line. The second argument specifies that the dynamic class should trim leading and trailing spaces from each line before searching. For example, if calling code specifies&nbsp;<code>dynamicFile.Sample(StringSearchOption.Contains)</code>, the dynamic class searches for &quot;Sample&quot; anywhere in a line. If calling code specifies&nbsp;<code>dynamicFile.Sample(StringSearchOption.StartsWith, false)</code>, the dynamic class searches for &quot;Sample&quot; at the start of each line, and does not remove leading and trailing spaces. The default behavior of the dynamic class is to search for a match at the start of each line and to remove leading and trailing spaces.</p>\r\n<h3>\r\n\tTo create a custom dynamic class</h3>\r\n<ol>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tStart Visual Studio.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tOn the&nbsp;<span>File</span>&nbsp;menu, point to&nbsp;<span>New</span>&nbsp;and then click&nbsp;<span>Project</span>.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tIn the&nbsp;<span>New Project</span>&nbsp;dialog box, in the&nbsp;<span>Project Types</span>&nbsp;pane, make sure that&nbsp;<span>Windows</span>&nbsp;is selected. Select&nbsp;<span>Console Application</span>&nbsp;in the&nbsp;<span>Templates</span>&nbsp;pane. In the&nbsp;<span>Name</span>&nbsp;box, type&nbsp;<code>DynamicSample</code>, and then click&nbsp;<span>OK</span>. The new project is created.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tRight-click the DynamicSample project and point to&nbsp;<span>Add</span>, and then click&nbsp;<span>Class</span>. In the&nbsp;<span>Name</span>&nbsp;box, type&nbsp;<code>ReadOnlyFile</code>, and then click&nbsp;<span>OK</span>. A new file is added that contains the ReadOnlyFile class.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tAt the top of the ReadOnlyFile.cs or ReadOnlyFile.vb file, add the following code to import the&nbsp;System.IO&nbsp;and&nbsp;System.Dynamic&nbsp;namespaces.</p>\r\n\t\t<div>\r\n\t\t\t&nbsp;</div>\r\n\t\t<pre>\r\n\t\t<code><span>using</span> System.IO;\r\n<span>using</span> System.Dynamic;\r\n</code></pre>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tThe custom dynamic object uses an enum to determine the search criteria. Before the class statement, add the following enum definition.</p>\r\n\t\t<div>\r\n\t\t\t&nbsp;</div>\r\n\t\t<pre>\r\n\t\t<code><span>public</span> <span>enum</span> StringSearchOption\r\n{\r\n    StartsWith,\r\n    Contains,\r\n    EndsWith\r\n}\r\n</code></pre>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tUpdate the class statement to inherit the&nbsp;<code>DynamicObject</code>&nbsp;class, as shown in the following code example.</p>\r\n\t\t<div>\r\n\t\t\t&nbsp;</div>\r\n\t\t<pre>\r\n\t\t<code><span>class</span> <span>ReadOnlyFile</span> : <span>DynamicObject</span>\r\n</code></pre>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tAdd the following code to the&nbsp;<code>ReadOnlyFile</code>&nbsp;class to define a private field for the file path and a constructor for the&nbsp;<code>ReadOnlyFile</code>&nbsp;class.</p>\r\n\t\t<div>\r\n\t\t\t&nbsp;</div>\r\n\t\t<pre>\r\n\t\t<code><span>// Store the path to the file and the initial line count value.</span>\r\n<span>private</span> <span>string</span> p_filePath;\r\n\r\n<span>// Public constructor. Verify that file exists and store the path in </span>\r\n<span>// the private variable.</span>\r\n<span><span>public</span> <span>ReadOnlyFile</span>(<span><span>string</span> filePath</span>)\r\n</span>{\r\n    <span>if</span> (!File.Exists(filePath))\r\n    {\r\n        <span>throw</span> <span>new</span> Exception(<span>&quot;File path does not exist.&quot;</span>);\r\n    }\r\n\r\n    p_filePath = filePath;\r\n}\r\n</code></pre>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tAdd the following&nbsp;<code>GetPropertyValue</code>&nbsp;method to the&nbsp;<code>ReadOnlyFile</code>&nbsp;class. The&nbsp;<code>GetPropertyValue</code>method takes, as input, search criteria and returns the lines from a text file that match that search criteria. The dynamic methods provided by the&nbsp;<code>ReadOnlyFile</code>&nbsp;class call the&nbsp;<code>GetPropertyValue</code>method to retrieve their respective results.</p>\r\n\t\t<div>\r\n\t\t\t&nbsp;</div>\r\n\t\t<pre>\r\n\t\t<code><span><span>public</span> List&lt;<span>string</span>&gt; <span>GetPropertyValue</span>(<span><span>string</span> propertyName,\r\n                                     StringSearchOption StringSearchOption = StringSearchOption.StartsWith,\r\n                                     <span>bool</span> trimSpaces = <span>true</span></span>) \r\n</span>{\r\n    StreamReader sr = <span>null</span>;\r\n    List&lt;<span>string</span>&gt; results = <span>new</span> List&lt;<span>string</span>&gt;();\r\n    <span>string</span> line = <span>&quot;&quot;</span>;\r\n    <span>string</span> testLine = <span>&quot;&quot;</span>;\r\n\r\n    <span>try</span>\r\n    {\r\n        sr = <span>new</span> StreamReader(p_filePath);\r\n\r\n        <span>while</span> (!sr.EndOfStream)\r\n        {\r\n            line = sr.ReadLine();\r\n\r\n            <span>// Perform a case-insensitive search by using the specified search options.</span>\r\n            testLine = line.ToUpper();\r\n            <span>if</span> (trimSpaces) { testLine = testLine.Trim(); }\r\n\r\n            <span>switch</span> (StringSearchOption)\r\n            {\r\n                <span>case</span> StringSearchOption.StartsWith:\r\n                    <span>if</span> (testLine.StartsWith(propertyName.ToUpper())) { results.Add(line); }\r\n                    <span>break</span>;\r\n                <span>case</span> StringSearchOption.Contains:\r\n                    <span>if</span> (testLine.Contains(propertyName.ToUpper())) { results.Add(line); }\r\n                    <span>break</span>;\r\n                <span>case</span> StringSearchOption.EndsWith:\r\n                    <span>if</span> (testLine.EndsWith(propertyName.ToUpper())) { results.Add(line); }\r\n                    <span>break</span>;\r\n            }\r\n        }\r\n    }\r\n    <span>catch</span>\r\n    {\r\n        <span>// Trap any exception that occurs in reading the file and return null.</span>\r\n        results = <span>null</span>;\r\n    }\r\n    <span>finally</span>\r\n    {\r\n        <span>if</span> (sr != <span>null</span>) {sr.Close();}\r\n    }\r\n\r\n    <span>return</span> results;\r\n}\r\n</code></pre>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tAfter the&nbsp;<code>GetPropertyValue</code>&nbsp;method, add the following code to override the&nbsp;TryGetMembermethod of the&nbsp;DynamicObject&nbsp;class. The&nbsp;TryGetMember&nbsp;method is called when a member of a dynamic class is requested and no arguments are specified. The&nbsp;<code>binder</code>&nbsp;argument contains information about the referenced member, and the&nbsp;<code>result</code>&nbsp;argument references the result returned for the specified member. The&nbsp;TryGetMember&nbsp;method returns a Boolean value that returns&nbsp;<code>true</code>&nbsp;if the requested member exists; otherwise it returns&nbsp;<code>false</code>.</p>\r\n\t\t<div>\r\n\t\t\t&nbsp;</div>\r\n\t\t<pre>\r\n\t\t<code><span>// Implement the TryGetMember method of the DynamicObject class for dynamic member calls.</span>\r\n<span><span>public</span> <span>override</span> <span>bool</span> <span>TryGetMember</span>(<span>GetMemberBinder binder,\r\n                                  <span>out</span> <span>object</span> result</span>) \r\n</span>{\r\n    result = GetPropertyValue(binder.Name);\r\n    <span>return</span> result == <span>null</span> ? <span>false</span> : <span>true</span>;\r\n}&nbsp;</code></pre>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tAfter the&nbsp;<code>TryGetMember</code><span>&nbsp;method, add the following code to override the&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.dynamic.dynamicobject.tryinvokemember\" target=\"_blank\">TryInvokeMember</a><span>method of the&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.dynamic.dynamicobject\" target=\"_blank\">DynamicObject</a><span>&nbsp;class. The&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.dynamic.dynamicobject.tryinvokemember\" target=\"_blank\">TryInvokeMember</a><span>&nbsp;method is called when a member of a dynamic class is requested with arguments. The&nbsp;</span><code>binder</code><span>&nbsp;argument contains information about the referenced member, and the&nbsp;</span><code>result</code><span>&nbsp;argument references the result returned for the specified member.</span></p>\r\n\t\t<p>\r\n\t\t\tThe custom version of the&nbsp;<code>TryInvokeMember</code>&nbsp;method expects the first argument to be a value from the&nbsp;<code>StringSearchOption</code>&nbsp;enum that you defined in a previous step. The&nbsp;<code>TryInvokeMember</code>method expects the second argument to be a Boolean value. If one or both arguments are valid values, they are passed to the&nbsp;<code>GetPropertyValue</code>&nbsp;method to retrieve the results.</p>\r\n\t\t<div>\r\n\t\t\t&nbsp;</div>\r\n\t\t<pre>\r\n\t\t<code><span>// Implement the TryInvokeMember method of the DynamicObject class for </span>\r\n<span>// dynamic member calls that have arguments.</span>\r\n<span><span>public</span> <span>override</span> <span>bool</span> <span>TryInvokeMember</span>(<span>InvokeMemberBinder binder,\r\n                                     <span>object</span>[] args,\r\n                                     <span>out</span> <span>object</span> result</span>)\r\n</span>{\r\n    StringSearchOption StringSearchOption = StringSearchOption.StartsWith;\r\n    <span>bool</span> trimSpaces = <span>true</span>;\r\n\r\n    <span>try</span>\r\n    {\r\n        <span>if</span> (args.Length &gt; <span>0</span>) { StringSearchOption = (StringSearchOption)args[<span>0</span>]; }\r\n    }\r\n    <span>catch</span>\r\n    {\r\n        <span>throw</span> <span>new</span> ArgumentException(<span>&quot;StringSearchOption argument must be a StringSearchOption enum value.&quot;</span>);\r\n    }\r\n\r\n    <span>try</span>\r\n    {\r\n        <span>if</span> (args.Length &gt; <span>1</span>) { trimSpaces = (<span>bool</span>)args[<span>1</span>]; }\r\n    }\r\n    <span>catch</span>\r\n    {\r\n        <span>throw</span> <span>new</span> ArgumentException(<span>&quot;trimSpaces argument must be a Boolean value.&quot;</span>);\r\n    }\r\n\r\n    result = GetPropertyValue(binder.Name, StringSearchOption, trimSpaces);\r\n\r\n    <span>return</span> result == <span>null</span> ? <span>false</span> : <span>true</span>;\r\n}\r\n</code></pre>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tThe&nbsp;<code>args</code>&nbsp;argument contains an array of the arguments that are passed to the member. The&nbsp;TryInvokeMember&nbsp;method returns a Boolean value that returns&nbsp;<code>true</code>&nbsp;if the requested member exists; otherwise it returns&nbsp;<code>false</code>.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tSave and close the file.</p>\r\n\t</li>\r\n</ol>\r\n<h4>\r\n\tTo create a sample text file</h4>\r\n<ol>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tRight-click the DynamicSample project and point to&nbsp;<span>Add</span>, and then click&nbsp;<span>New Item</span>. In the&nbsp;<span>Installed Templates</span>&nbsp;pane, select&nbsp;<span>General</span>, and then select the&nbsp;<span>Text File</span>&nbsp;template. Leave the default name of TextFile1.txt in the&nbsp;<span>Name</span>&nbsp;box, and then click&nbsp;<span>Add</span>. A new text file is added to the project.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tCopy the following text to the TextFile1.txt file.</p>\r\n\t\t<div>\r\n\t\t\t&nbsp;</div>\r\n\t\t<pre>\r\n\t\t<code>List of customers and suppliers  \r\n\r\nSupplier: Lucerne Publishing (https://www.lucernepublishing.com/)  \r\nCustomer: Preston, Chris  \r\nCustomer: Hines, Patrick  \r\nCustomer: Cameron, Maria  \r\nSupplier: Graphic Design Institute (https://www.graphicdesigninstitute.com/)   \r\nSupplier: Fabrikam, Inc. (https://www.fabrikam.com/)   \r\nCustomer: Seubert, Roxanne  \r\nSupplier: Proseware, Inc. (http://www.proseware.com/)   \r\nCustomer: Adolphi, Stephan  \r\nCustomer: Koch, Paul  \r\n</code></pre>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tSave and close the file.</p>\r\n\t</li>\r\n</ol>\r\n<h4>\r\n\tTo create a sample application that uses the custom dynamic object</h4>\r\n<ol>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tIn&nbsp;<span>Solution Explorer</span>, double-click the Module1.vb file if you are using Visual Basic or the Program.cs file if you are using Visual C#.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tAdd the following code to the Main procedure to create an instance of the&nbsp;<code>ReadOnlyFile</code>&nbsp;class for the TextFile1.txt file. The code uses late binding to call dynamic members and retrieve lines of text that contain the string &quot;Customer&quot;.</p>\r\n\t\t<div>\r\n\t\t\t&nbsp;</div>\r\n\t\t<pre>\r\n\t\t<code><span>dynamic</span> rFile = <span>new</span> ReadOnlyFile(<span>@&quot;..\\..\\TextFile1.txt&quot;</span>);\r\n<span>foreach</span> (<span>string</span> line <span>in</span> rFile.Customer)\r\n{\r\n    Console.WriteLine(line);\r\n}\r\nConsole.WriteLine(<span>&quot;----------------------------&quot;</span>);\r\n<span>foreach</span> (<span>string</span> line <span>in</span> rFile.Customer(StringSearchOption.Contains, <span>true</span>))\r\n{\r\n    Console.WriteLine(line);\r\n}\r\n</code></pre>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tSave the file and press CTRL+F5 to build and run the application.</p>\r\n\t</li>\r\n</ol>\r\n<h2>\r\n\tCalling a Dynamic Language Library</h2>\r\n<p>\r\n\tThe next project that you create in this walkthrough accesses a library that is written in the dynamic language IronPython.</p>\r\n<h3>\r\n\tTo create a custom dynamic class</h3>\r\n<ol>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tIn Visual Studio, on the&nbsp;<span>File</span>&nbsp;menu, point to&nbsp;<span>New</span>&nbsp;and then click&nbsp;<span>Project</span>.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tIn the&nbsp;<span>New Project</span>&nbsp;dialog box, in the&nbsp;<span>Project Types</span>&nbsp;pane, make sure that&nbsp;<span>Windows</span>&nbsp;is selected. Select&nbsp;<span>Console Application</span>&nbsp;in the&nbsp;<span>Templates</span>&nbsp;pane. In the&nbsp;<span>Name</span>&nbsp;box, type&nbsp;<code>DynamicIronPythonSample</code>, and then click&nbsp;<span>OK</span>. The new project is created.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tIf you are using Visual Basic, right-click the DynamicIronPythonSample project and then click&nbsp;<span>Properties</span>. Click the&nbsp;<span>References</span>&nbsp;tab. Click the&nbsp;<span>Add</span>&nbsp;button. If you are using Visual C#, in&nbsp;<span>Solution Explorer</span>, right-click the&nbsp;<span>References</span>&nbsp;folder and then click&nbsp;<span>Add Reference</span>.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tOn the&nbsp;<span>Browse</span>&nbsp;tab, browse to the folder where the IronPython libraries are installed. For example, C:\\Program Files\\IronPython 2.6 for .NET 4.0. Select the&nbsp;<span>IronPython.dll</span>,&nbsp;<span>IronPython.Modules.dll</span>,&nbsp;<span>Microsoft.Scripting.dll</span>, and&nbsp;<span>Microsoft.Dynamic.dll</span>&nbsp;libraries. Click&nbsp;<span>OK</span>.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tIf you are using Visual Basic, edit the Module1.vb file. If you are using Visual C#, edit the Program.cs file.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tAt the top of the file, add the following code to import the&nbsp;<code>Microsoft.Scripting.Hosting</code>&nbsp;and&nbsp;<code>IronPython.Hosting</code>&nbsp;namespaces from the IronPython libraries.</p>\r\n\t\t<div>\r\n\t\t\t&nbsp;</div>\r\n\t\t<pre>\r\n\t\t<code><span>using</span> Microsoft.Scripting.Hosting;\r\n<span>using</span> IronPython.Hosting;\r\n</code></pre>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tIn the Main method, add the following code to create a new&nbsp;<code>Microsoft.Scripting.Hosting.ScriptRuntime</code>&nbsp;object to host the IronPython libraries. The&nbsp;<code>ScriptRuntime</code>&nbsp;object loads the IronPython library module random.py.</p>\r\n\t\t<div>\r\n\t\t\t&nbsp;</div>\r\n\t\t<pre>\r\n\t\t<code><span>// Set the current directory to the IronPython libraries.</span>\r\nSystem.IO.Directory.SetCurrentDirectory(\r\n   Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) + \r\n   <span>@&quot;\\IronPython 2.6 for .NET 4.0\\Lib&quot;</span>);\r\n\r\n<span>// Create an instance of the random.py IronPython library.</span>\r\nConsole.WriteLine(<span>&quot;Loading random.py&quot;</span>);\r\nScriptRuntime py = Python.CreateRuntime();\r\n<span>dynamic</span> random = py.UseFile(<span>&quot;random.py&quot;</span>);\r\nConsole.WriteLine(<span>&quot;random.py loaded.&quot;</span>);\r\n</code></pre>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tAfter the code to load the random.py module, add the following code to create an array of integers. The array is passed to the&nbsp;<code>shuffle</code>&nbsp;method of the random.py module, which randomly sorts the values in the array.</p>\r\n\t\t<div>\r\n\t\t\t&nbsp;</div>\r\n\t\t<pre>\r\n\t\t<code><span>// Initialize an enumerable set of integers.</span>\r\n<span>int</span>[] items = Enumerable.Range(<span>1</span>, <span>7</span>).ToArray();\r\n\r\n<span>// Randomly shuffle the array of integers by using IronPython.</span>\r\n<span>for</span> (<span>int</span> i = <span>0</span>; i &lt; <span>5</span>; i++)\r\n{\r\n    random.shuffle(items);\r\n    <span>foreach</span> (<span>int</span> item <span>in</span> items)\r\n    {\r\n        Console.WriteLine(item);\r\n    }\r\n    Console.WriteLine(<span>&quot;-------------------&quot;</span>);\r\n}\r\n</code></pre>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tSave the file and press CTRL+F5 to build and run the application.</p>\r\n\t</li>\r\n</ol>"
          },
          {
            "How to: Convert a byte Array to an int": "<p>\r\n\t<span>This example shows you how to use the&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.bitconverter\" target=\"_blank\">BitConverter</a><span>&nbsp;class to convert an array of bytes to an&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/int\" target=\"_blank\">int</a><span>&nbsp;and back to an array of bytes. You may have to convert from bytes to a built-in data type after you read bytes off the network, for example. In addition to the&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.bitconverter.toint32#System_BitConverter_ToInt32_System_Byte___System_Int32_\" target=\"_blank\">ToInt32(Byte[],&ensp;Int32)</a><span>&nbsp;method in the example, the following table lists methods in the&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.bitconverter\" target=\"_blank\">BitConverter</a><span>&nbsp;class that convert bytes (from an array of bytes) to other built-in types.</span></p>\r\n<div>\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tType returned</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tMethod</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>bool</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tToBoolean(Byte[],&ensp;Int32)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>char</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tToChar(Byte[],&ensp;Int32)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>double</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tToDouble(Byte[],&ensp;Int32)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>short</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tToInt16(Byte[],&ensp;Int32)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>int</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tToInt32(Byte[],&ensp;Int32)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>long</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tToInt64(Byte[],&ensp;Int32)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>float</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tToSingle(Byte[],&ensp;Int32)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>ushort</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tToUInt16(Byte[],&ensp;Int32)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>uint</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tToUInt32(Byte[],&ensp;Int32)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>ulong</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tToUInt64(Byte[],&ensp;Int32)</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThis example initializes an array of bytes, reverses the array if the computer architecture is little-endian (that is, the least significant byte is stored first), and then calls the&nbsp;ToInt32(Byte[],&ensp;Int32)&nbsp;method to convert four bytes in the array to an&nbsp;<code>int</code>. The second argument to&nbsp;ToInt32(Byte[],&ensp;Int32)&nbsp;specifies the start index of the array of bytes.</p>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tThe output may differ depending on the endianess of your computer&#39;s architecture.</p>\r\n</div>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>byte</span>[] bytes = { <span>0</span>, <span>0</span>, <span>0</span>, <span>25</span> };\r\n\r\n<span>// If the system architecture is little-endian (that is, little end first),</span>\r\n<span>// reverse the byte array.</span>\r\n<span>if</span> (BitConverter.IsLittleEndian)\r\n    Array.Reverse(bytes);\r\n\r\n<span>int</span> i = BitConverter.ToInt32(bytes, <span>0</span>);\r\nConsole.WriteLine(<span>&quot;int: {0}&quot;</span>, i);\r\n<span>// Output: int: 25</span>\r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tIn this example, the&nbsp;GetBytes(Int32)&nbsp;method of the&nbsp;BitConverter&nbsp;class is called to convert an&nbsp;<code>int</code>&nbsp;to an array of bytes.</p>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tThe output may differ depending on the endianess of your computer&#39;s architecture.</p>\r\n</div>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>byte</span>[] bytes = BitConverter.GetBytes(<span>201805978</span>);\r\nConsole.WriteLine(<span>&quot;byte array: &quot;</span> + BitConverter.ToString(bytes));\r\n<span>// Output: byte array: 9A-50-07-0C</span></code></pre>"
          },
          {
            "How to: Convert a String to a Number": "<p>\r\n\tYou can convert a&nbsp;<a href=\"http://semantic-portal.net/language-reference-types-referencetypes-string\" target=\"_blank\">string</a>&nbsp;to a number by using methods in the<span>&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.convert\" target=\"_blank\">Convert</a>&nbsp;class or by using the&nbsp;<code>TryParse</code>method found on the various numeric types (int, long, float, etc.).</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<p>\r\n\tIf you have a <a href=\"http://semantic-portal.net/language-reference-types-referencetypes-string\" target=\"_blank\">string</a>, it is slightly more efficient and straightforward to call a&nbsp;<code>TryParse</code>&nbsp;method (for example,&nbsp;<code>int.TryParse(&quot;11&quot;, out number)</code>). Using a&nbsp;Convert&nbsp;method is more useful for general objects that implement&nbsp;IConvertible.</p>\r\n<p>\r\n\t<span>You can use&nbsp;</span><code>Parse</code><span>&nbsp;or&nbsp;</span><code>TryParse</code><span>&nbsp;methods on the numeric type you expect the string contains, such as the&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.int32\" target=\"_blank\">System.Int32</a><span>&nbsp;type. The&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.convert.touint32\" target=\"_blank\">Convert.ToUInt32</a><span>&nbsp;method uses&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.int32.parse\" target=\"_blank\">Parse</a><span>&nbsp;internally. If the string is not in a valid format,&nbsp;</span><code>Parse</code><span>&nbsp;throws an exception whereas&nbsp;</span><code>TryParse</code><span>&nbsp;returns&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/false\" target=\"_blank\">false</a><span>.</span></p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe&nbsp;<code>Parse</code>&nbsp;and&nbsp;<code>TryParse</code>&nbsp;methods ignore white space at the beginning and at the end of the <a href=\"http://semantic-portal.net/language-reference-types-referencetypes-string\" target=\"_blank\">string</a>, but all other characters must be characters that form the appropriate numeric type (int, long, ulong, float, decimal, etc.). Any white space within the characters that form the number cause an error. For example, you can use&nbsp;<code>decimal.TryParse</code>&nbsp;to parse &quot;10&quot;, &quot;10.3&quot;, &quot; 10 &quot;, but you cannot use this method to parse 10 from &quot;10X&quot;, &quot;1 0&quot; (note space), &quot;10 .3&quot; (note space), &quot;10e1&quot; (<code>float.TryParse</code>&nbsp;works here), and so on.</p>\r\n<p>\r\n\tThe examples below demonstrate both successful and unsuccessful calls to&nbsp;<code>Parse</code>&nbsp;and&nbsp;<code>TryParse</code>.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System;\r\n<span>using</span> System.Text;\r\n</code></pre>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>int</span> numVal = Int32.Parse(<span>&quot;-105&quot;</span>);\r\nConsole.WriteLine(numVal);\r\n<span>// Output: -105</span>\r\n</code></pre>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// TryParse returns true if the conversion succeeded</span>\r\n<span>// and stores the result in j.</span>\r\n<span>int</span> j;\r\n<span>if</span> (Int32.TryParse(<span>&quot;-105&quot;</span>, <span>out</span> j))\r\n    Console.WriteLine(j);\r\n<span>else</span>\r\n    Console.WriteLine(<span>&quot;String could not be parsed.&quot;</span>);\r\n<span>// Output: -105</span>\r\n</code></pre>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>try</span>\r\n{\r\n    <span>int</span> m = Int32.Parse(<span>&quot;abc&quot;</span>);\r\n}\r\n<span>catch</span> (FormatException e)\r\n{\r\n    Console.WriteLine(e.Message);\r\n}\r\n<span>// Output: Input string was not in a correct format.</span>\r\n</code></pre>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> inputString = <span>&quot;abc&quot;</span>;\r\n<span>int</span> numValue;\r\n<span>bool</span> parsed = Int32.TryParse(inputString, <span>out</span> numValue);\r\n\r\n<span>if</span> (!parsed)\r\n    Console.WriteLine(<span>&quot;Int32.TryParse could not parse &#39;{0}&#39; to an int.\\n&quot;</span>, inputString);\r\n\r\n<span>// Output: Int32.TryParse could not parse &#39;abc&#39; to an int.</span>\r\n</code></pre>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// This snippet shows a couple of examples that extract number characters from the</span>\r\n<span>// beginning of the string to avoid TryParse errors.</span>\r\nStringBuilder sb = <span>new</span> StringBuilder();\r\n<span>var</span> str = <span>&quot;  10FFxxx&quot;</span>;\r\n<span>foreach</span> (<span>char</span> c <span>in</span> str) {\r\n    <span>// Check for numeric characters (hex in this case).  Add &quot;.&quot; and &quot;e&quot; if float,</span>\r\n    <span>// and remove letters.  Include initial space because it is harmless.</span>\r\n    <span>if</span> ((c &gt;= <span>&#39;0&#39;</span> &amp;&amp; c &lt;= <span>&#39;9&#39;</span>) || (c &gt;= <span>&#39;A&#39;</span> &amp;&amp; c &lt;= <span>&#39;F&#39;</span>) || (c &gt;= <span>&#39;a&#39;</span> &amp;&amp; c &lt;= <span>&#39;f&#39;</span>) || c == <span>&#39; &#39;</span>) {\r\n        sb.Append(c);\r\n    }\r\n    <span>else</span>\r\n        <span>break</span>;\r\n}\r\n<span>if</span> (<span>int</span>.TryParse(sb.ToString(), System.Globalization.NumberStyles.HexNumber, <span>null</span>, <span>out</span> <span>int</span> i))\r\n    Console.WriteLine(sb.ToString());\r\n\r\nstr = <span>&quot;   -10FFXXX&quot;</span>;\r\nsb.Clear();\r\n<span>foreach</span> (<span>char</span> c <span>in</span> str) {\r\n    <span>// Check for numeric characters (allow negative in this case but no hex digits). </span>\r\n    <span>// Though we use int.TryParse in the previous example and this one, int.TryParse does NOT</span>\r\n    <span>// allow a sign character (-) AND hex digits at the same time.</span>\r\n    <span>// Include initial space because it is harmless.</span>\r\n    <span>if</span> ((c &gt;= <span>&#39;0&#39;</span> &amp;&amp; c &lt;= <span>&#39;9&#39;</span>) || c == <span>&#39; &#39;</span> || c == <span>&#39;-&#39;</span>) {\r\n        sb.Append(c);\r\n    } <span>else</span>\r\n        <span>break</span>;\r\n}\r\n<span>if</span> (<span>int</span>.TryParse(sb.ToString(), <span>out</span> <span>int</span> j))\r\n    Console.WriteLine(sb.ToString());\r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following table lists some of the methods from the&nbsp;Convert&nbsp;class that you can use.</p>\r\n<div>\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tNumeric Type</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tMethod</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>decimal</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tToDecimal(String)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>float</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tToSingle(String)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>double</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tToDouble(String)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>short</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tToInt16(String)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>int</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tToInt32(String)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>long</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tToInt64(String)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>ushort</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tToUInt16(String)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>uint</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tToUInt32(String)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>ulong</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tToUInt64(String)</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<p>\r\n\tThis example calls the&nbsp;Convert.ToInt32(String)&nbsp;method to convert an input&nbsp;string&nbsp;to an&nbsp;int&nbsp;. The code catches the two most common exceptions that can be thrown by this method,&nbsp;FormatException&nbsp;and&nbsp;OverflowException. If the number can be incremented without overflowing the integer storage location, the program adds 1 to the result and prints the output.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System;\r\n<span>using</span> System.Text;\r\n</code></pre>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)\r\n</span>{\r\n    <span>int</span> numVal = <span>-1</span>;\r\n    <span>bool</span> repeat = <span>true</span>;\r\n\r\n    <span>while</span> (repeat)\r\n    {\r\n        Console.WriteLine(<span>&quot;Enter a number between &minus;2,147,483,648 and +2,147,483,647 (inclusive).&quot;</span>);\r\n\r\n        <span>string</span> input = Console.ReadLine();\r\n\r\n        <span>// ToInt32 can throw FormatException or OverflowException.</span>\r\n        <span>try</span>\r\n        {\r\n            numVal = Convert.ToInt32(input);\r\n        }\r\n        <span>catch</span> (FormatException e)\r\n        {\r\n            Console.WriteLine(<span>&quot;Input string is not a sequence of digits.&quot;</span>);\r\n        }\r\n        <span>catch</span> (OverflowException e)\r\n        {\r\n            Console.WriteLine(<span>&quot;The number cannot fit in an Int32.&quot;</span>);\r\n        }\r\n        <span>finally</span>\r\n        {\r\n            <span>if</span> (numVal &lt; Int32.MaxValue)\r\n            {\r\n                Console.WriteLine(<span>&quot;The new value is {0}&quot;</span>, numVal + <span>1</span>);\r\n            }\r\n            <span>else</span>\r\n            {\r\n                Console.WriteLine(<span>&quot;numVal cannot be incremented beyond its current value&quot;</span>);\r\n            }\r\n        }\r\n        Console.WriteLine(<span>&quot;Go again? Y/N&quot;</span>);\r\n        <span>string</span> go = Console.ReadLine();\r\n        <span>if</span> (go == <span>&quot;Y&quot;</span> || go == <span>&quot;y&quot;</span>)\r\n        {\r\n            repeat = <span>true</span>;\r\n        }\r\n        <span>else</span>\r\n        {\r\n            repeat = <span>false</span>;\r\n        }\r\n    }\r\n    <span>// Keep the console open in debug mode.</span>\r\n    Console.WriteLine(<span>&quot;Press any key to exit.&quot;</span>);\r\n    Console.ReadKey();    \r\n}\r\n<span>// Sample Output:</span>\r\n<span>// Enter a number between -2,147,483,648 and +2,147,483,647 (inclusive).</span>\r\n<span>// 473</span>\r\n<span>// The new value is 474</span>\r\n<span>// Go again? Y/N</span>\r\n<span>// y</span>\r\n<span>// Enter a number between -2,147,483,648 and +2,147,483,647 (inclusive).</span>\r\n<span>// 2147483647</span>\r\n<span>// numVal cannot be incremented beyond its current value</span>\r\n<span>// Go again? Y/N</span>\r\n<span>// Y</span>\r\n<span>// Enter a number between -2,147,483,648 and +2,147,483,647 (inclusive).</span>\r\n<span>// -1000</span>\r\n<span>// The new value is -999</span>\r\n<span>// Go again? Y/N</span>\r\n<span>// n</span>\r\n<span>// Press any key to exit.</span></code></pre>"
          },
          {
            "How to: Convert Between Hexadecimal Strings and Numeric Types": "<p>\r\n\tThese examples show you how to perform the following tasks:Obtain the hexadecimal value of each character in a&nbsp;string.</p>\r\n<ul>\r\n\t<li>\r\n\t\tObtain the&nbsp;char&nbsp;that corresponds to each value in a hexadecimal string.</li>\r\n\t<li>\r\n\t\tConvert a hexadecimal&nbsp;<code>string</code>&nbsp;to an&nbsp;int.</li>\r\n\t<li>\r\n\t\tConvert a hexadecimal&nbsp;<code>string</code>&nbsp;to a&nbsp;float.</li>\r\n\t<li>\r\n\t\tConvert a&nbsp;byte&nbsp;array to a hexadecimal&nbsp;<code>string</code>.</li>\r\n</ul>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tTThese examples show you how to perform the following tasks:</p>\r\n<ul>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tObtain the hexadecimal value of each character in a&nbsp;string.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tObtain the&nbsp;char&nbsp;that corresponds to each value in a hexadecimal string.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tConvert a hexadecimal&nbsp;<code>string</code>&nbsp;to an&nbsp;int.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tConvert a hexadecimal&nbsp;<code>string</code>&nbsp;to a&nbsp;float.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tConvert a&nbsp;byte&nbsp;array to a hexadecimal&nbsp;<code>string</code>.</p>\r\n\t</li>\r\n</ul>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThis example outputs the hexadecimal value of each character in a&nbsp;<code>string</code>. First it parses the&nbsp;<code>string</code>to an array of characters. Then it calls&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.convert.toint32#System_Convert_ToInt32_System_Char_\" target=\"_blank\">ToInt32(Char)</a>&nbsp;on each character to obtain its numeric value. Finally, it formats the number as its hexadecimal representation in a&nbsp;<code>string</code>.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>string input = &quot;Hello World!&quot;;\r\nchar[] values = input.ToCharArray();\r\nforeach (char letter in values)\r\n{\r\n    // Get the integral value of the character.\r\n    int value = Convert.ToInt32(letter);\r\n    // Convert the decimal value to a hexadecimal value in string form.\r\n    string hexOutput = String.Format(&quot;{0:X}&quot;, value);\r\n    Console.WriteLine(&quot;Hexadecimal value of {0} is {1}&quot;, letter, hexOutput);\r\n}\r\n/* Output:\r\n   Hexadecimal value of H is 48\r\n    Hexadecimal value of e is 65\r\n    Hexadecimal value of l is 6C\r\n    Hexadecimal value of l is 6C\r\n    Hexadecimal value of o is 6F\r\n    Hexadecimal value of   is 20\r\n    Hexadecimal value of W is 57\r\n    Hexadecimal value of o is 6F\r\n    Hexadecimal value of r is 72\r\n    Hexadecimal value of l is 6C\r\n    Hexadecimal value of d is 64\r\n    Hexadecimal value of ! is 21\r\n */\r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\t<span>This example parses a&nbsp;</span><code>string</code><span>&nbsp;of hexadecimal values and outputs the character corresponding to each hexadecimal value. First it calls the&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.split#System_String_Split_System_Char___\" target=\"_blank\">Split(Char[])</a><span>&nbsp;method to obtain each hexadecimal value as an individual&nbsp;</span><code>string</code><span>&nbsp;in an array. Then it calls&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.convert.toint32#System_Convert_ToInt32_System_String_System_Int32_\" target=\"_blank\">ToInt32(String, Int32)</a><span>&nbsp;to convert the hexadecimal value to a decimal value represented as an&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/int\" target=\"_blank\">int</a><span>. It shows two different ways to obtain the character corresponding to that character code. The first technique uses&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.char.convertfromutf32#System_Char_ConvertFromUtf32_System_Int32_\" target=\"_blank\">ConvertFromUtf32(Int32)</a><span>, which returns the character corresponding to the integer argument as a&nbsp;</span><code>string</code><span>. The second technique explicitly casts the&nbsp;</span><code>int</code><span>&nbsp;to a&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/char\" target=\"_blank\">char</a><span>.</span></p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>string hexValues = &quot;48 65 6C 6C 6F 20 57 6F 72 6C 64 21&quot;;\r\nstring[] hexValuesSplit = hexValues.Split(&#39; &#39;);\r\nforeach (string hex in hexValuesSplit)\r\n{\r\n    // Convert the number expressed in base-16 to an integer.\r\n    int value = Convert.ToInt32(hex, 16);\r\n    // Get the character corresponding to the integral value.\r\n    string stringValue = Char.ConvertFromUtf32(value);\r\n    char charValue = (char)value;\r\n    Console.WriteLine(&quot;hexadecimal value = {0}, int value = {1}, char value = {2} or {3}&quot;,\r\n                        hex, value, stringValue, charValue);\r\n}\r\n/* Output:\r\n    hexadecimal value = 48, int value = 72, char value = H or H\r\n    hexadecimal value = 65, int value = 101, char value = e or e\r\n    hexadecimal value = 6C, int value = 108, char value = l or l\r\n    hexadecimal value = 6C, int value = 108, char value = l or l\r\n    hexadecimal value = 6F, int value = 111, char value = o or o\r\n    hexadecimal value = 20, int value = 32, char value =   or\r\n    hexadecimal value = 57, int value = 87, char value = W or W\r\n    hexadecimal value = 6F, int value = 111, char value = o or o\r\n    hexadecimal value = 72, int value = 114, char value = r or r\r\n    hexadecimal value = 6C, int value = 108, char value = l or l\r\n    hexadecimal value = 64, int value = 100, char value = d or d\r\n    hexadecimal value = 21, int value = 33, char value = ! or !\r\n*/\r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThis example shows another way to convert a hexadecimal&nbsp;<code>string</code>&nbsp;to an integer, by calling the&nbsp;Parse(String, NumberStyles)&nbsp;method.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>string hexString = &quot;8E2&quot;;\r\nint num = Int32.Parse(hexString, System.Globalization.NumberStyles.HexNumber);\r\nConsole.WriteLine(num);\r\n//Output: 2274\r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example shows how to convert a hexadecimal&nbsp;<code>string</code>&nbsp;to a&nbsp;float&nbsp;by using the&nbsp;System.BitConverter&nbsp;class and the&nbsp;UInt32.Parse&nbsp;method.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>\r\nstring hexString = &quot;43480170&quot;;\r\nuint num = uint.Parse(hexString, System.Globalization.NumberStyles.AllowHexSpecifier);\r\n\r\nbyte[] floatVals = BitConverter.GetBytes(num);\r\nfloat f = BitConverter.ToSingle(floatVals, 0);\r\nConsole.WriteLine(&quot;float convert = {0}&quot;, f);\r\n\r\n// Output: 200.0056            \r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example shows how to convert a&nbsp;byte&nbsp;array to a hexadecimal string by using the&nbsp;System.BitConverter&nbsp;class.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>byte[] vals = { 0x01, 0xAA, 0xB1, 0xDC, 0x10, 0xDD };\r\n\r\nstring str = BitConverter.ToString(vals);\r\nConsole.WriteLine(str);\r\n\r\nstr = BitConverter.ToString(vals).Replace(&quot;-&quot;, &quot;&quot;);\r\nConsole.WriteLine(str);\r\n\r\n/*Output:\r\n  01-AA-B1-DC-10-DD\r\n  01AAB1DC10DD&nbsp;</code></pre>\r\n<p>\r\n\t&nbsp;*/First it parses the&nbsp;<code>string</code>to an array of characters. Then it calls&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.convert.toint32#System_Convert_ToInt32_System_Char_\" target=\"_blank\">ToInt32(Char)</a>&nbsp;on each character to obtain its numeric value. Finally, it formats the number as its hexadecimal representation in a&nbsp;<code>string</code>.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>string input = &quot;Hello World!&quot;;\r\nchar[] values = input.ToCharArray();\r\nforeach (char letter in values)\r\n{\r\n    // Get the integral value of the character.\r\n    int value = Convert.ToInt32(letter);\r\n    // Convert the decimal value to a hexadecimal value in string form.\r\n    string hexOutput = String.Format(&quot;{0:X}&quot;, value);\r\n    Console.WriteLine(&quot;Hexadecimal value of {0} is {1}&quot;, letter, hexOutput);\r\n}\r\n/* Output:\r\n   Hexadecimal value of H is 48\r\n    Hexadecimal value of e is 65\r\n    Hexadecimal value of l is 6C\r\n    Hexadecimal value of l is 6C\r\n    Hexadecimal value of o is 6F\r\n    Hexadecimal value of   is 20\r\n    Hexadecimal value of W is 57\r\n    Hexadecimal value of o is 6F\r\n    Hexadecimal value of r is 72\r\n    Hexadecimal value of l is 6C\r\n    Hexadecimal value of d is 64\r\n    Hexadecimal value of ! is 21\r\n */\r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThis example parses a&nbsp;<code>string</code>&nbsp;of hexadecimal values and outputs the character corresponding to each hexadecimal value. First it calls the&nbsp;Split(Char[])&nbsp;method to obtain each hexadecimal value as an individual&nbsp;<code>string</code>&nbsp;in an array. Then it calls&nbsp;ToInt32(String, Int32)&nbsp;to convert the hexadecimal value to a decimal value represented as an&nbsp;int. It shows two different ways to obtain the character corresponding to that character code. The first technique uses&nbsp;ConvertFromUtf32(Int32), which returns the character corresponding to the integer argument as a&nbsp;<code>string</code>. The second technique explicitly casts the&nbsp;<code>int</code>&nbsp;to a&nbsp;char.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>string hexValues = &quot;48 65 6C 6C 6F 20 57 6F 72 6C 64 21&quot;;\r\nstring[] hexValuesSplit = hexValues.Split(&#39; &#39;);\r\nforeach (string hex in hexValuesSplit)\r\n{\r\n    // Convert the number expressed in base-16 to an integer.\r\n    int value = Convert.ToInt32(hex, 16);\r\n    // Get the character corresponding to the integral value.\r\n    string stringValue = Char.ConvertFromUtf32(value);\r\n    char charValue = (char)value;\r\n    Console.WriteLine(&quot;hexadecimal value = {0}, int value = {1}, char value = {2} or {3}&quot;,\r\n                        hex, value, stringValue, charValue);\r\n}\r\n/* Output:\r\n    hexadecimal value = 48, int value = 72, char value = H or H\r\n    hexadecimal value = 65, int value = 101, char value = e or e\r\n    hexadecimal value = 6C, int value = 108, char value = l or l\r\n    hexadecimal value = 6C, int value = 108, char value = l or l\r\n    hexadecimal value = 6F, int value = 111, char value = o or o\r\n    hexadecimal value = 20, int value = 32, char value =   or\r\n    hexadecimal value = 57, int value = 87, char value = W or W\r\n    hexadecimal value = 6F, int value = 111, char value = o or o\r\n    hexadecimal value = 72, int value = 114, char value = r or r\r\n    hexadecimal value = 6C, int value = 108, char value = l or l\r\n    hexadecimal value = 64, int value = 100, char value = d or d\r\n    hexadecimal value = 21, int value = 33, char value = ! or !\r\n*/\r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThis example shows another way to convert a hexadecimal&nbsp;<code>string</code>&nbsp;to an integer, by calling the&nbsp;Parse(String, NumberStyles)&nbsp;method.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>string hexString = &quot;8E2&quot;;\r\nint num = Int32.Parse(hexString, System.Globalization.NumberStyles.HexNumber);\r\nConsole.WriteLine(num);\r\n//Output: 2274\r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example shows how to convert a hexadecimal&nbsp;<code>string</code>&nbsp;to a&nbsp;float&nbsp;by using the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.bitconverter\" target=\"_blank\">System.BitConverter</a><span>&nbsp;class and the&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.uint32.parse\" target=\"_blank\">UInt32.Parse</a><span>&nbsp;method.</span></p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>\r\nstring hexString = &quot;43480170&quot;;\r\nuint num = uint.Parse(hexString, System.Globalization.NumberStyles.AllowHexSpecifier);\r\n\r\nbyte[] floatVals = BitConverter.GetBytes(num);\r\nfloat f = BitConverter.ToSingle(floatVals, 0);\r\nConsole.WriteLine(&quot;float convert = {0}&quot;, f);\r\n\r\n// Output: 200.0056            \r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example shows how to convert a&nbsp;byte&nbsp;array to a hexadecimal string by using the&nbsp;System.BitConverter&nbsp;class.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>byte[] vals = { 0x01, 0xAA, 0xB1, 0xDC, 0x10, 0xDD };\r\n\r\nstring str = BitConverter.ToString(vals);\r\nConsole.WriteLine(str);\r\n\r\nstr = BitConverter.ToString(vals).Replace(&quot;-&quot;, &quot;&quot;);\r\nConsole.WriteLine(str);\r\n\r\n/*Output:\r\n  01-AA-B1-DC-10-DD\r\n  01AAB1DC10DD\r\n */</code></pre>"
          },
          {
            "Parse Strings Using String.Split": "<p>\r\n\tThe&nbsp;<span>&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.split\" target=\"_blank\">String.Split</a>&nbsp;method creates an array of substrings by splitting the input string based on one or more delimiters. It is often the easiest way to separate a string on word boundaries. It is also used to split strings on other specific characters or strings.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tThe C# examples in this article run in the&nbsp;Try.NET&nbsp;inline code runner and playground. Select the&nbsp;<span>Run</span>&nbsp;button to run an example in an interactive window. Once you execute the code, you can modify it and run the modified code by selecting&nbsp;<span>Run</span>&nbsp;again. The modified code either runs in the interactive window or, if compilation fails, the interactive window displays all C# compiler error messages.</p>\r\n</div>\r\n<p>\r\n\tThe following code splits a common phrase into an array of strings for each word.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<pre>\r\n<code><span>string</span> phrase = <span>&quot;The quick brown fox jumps over the lazy dog.&quot;</span>;\r\n<span>string</span>[] words = phrase.Split(<span>&#39; &#39;</span>);\r\n\r\n<span>foreach</span> (<span>var</span> word <span>in</span> words)\r\n{\r\n    System.Console.WriteLine(<span>$&quot;&lt;<span>{word}</span>&gt;&quot;</span>);\r\n}\r\n</code></pre>\r\n<p>\r\n\tEvery instance of a separator character produces a value in the returned array. Consecutive separator characters produce the empty string as a value in the returned array. You can see this in the following example, which uses space as a separator:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> phrase = <span>&quot;The quick brown    fox     jumps over the lazy dog.&quot;</span>;\r\n<span>string</span>[] words = phrase.Split(<span>&#39; &#39;</span>);\r\n\r\n<span>foreach</span> (<span>var</span> word <span>in</span> words)\r\n{\r\n    System.Console.WriteLine(<span>$&quot;&lt;<span>{word}</span>&gt;&quot;</span>);\r\n}\r\n</code></pre>\r\n<p>\r\n\tThis behavior makes it easier for formats like comma separated values (CSV) files representing tabular data. Consecutive commas represent a blank column.</p>\r\n<p>\r\n\tYou can pass an optional&nbsp;<span>&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.stringsplitoptions#System_StringSplitOptions_RemoveEmptyEntries\" target=\"_blank\">StringSplitOptions.RemoveEmptyEntries</a>&nbsp;parameter to exclude any empty strings in the returned array. For more complicated processing of the returned collection, you can use&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/index\" target=\"_blank\">LINQ</a>&nbsp;to manipulate the result sequence.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<p>\r\n\t<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.split\" target=\"_blank\">String.Split</a>&nbsp;can use multiple separator characters. The following example uses spaces, commas, periods, colons, and tabs, all passed in an array containing these separating characters, to&nbsp;Split. The loop at the bottom of the code displays each of the words in the returned array.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>char</span>[] delimiterChars = { <span>&#39; &#39;</span>, <span>&#39;,&#39;</span>, <span>&#39;.&#39;</span>, <span>&#39;:&#39;</span>, <span>&#39;\\t&#39;</span> };\r\n\r\n<span>string</span> text = <span>&quot;one\\ttwo three:four,five six seven&quot;</span>;\r\nSystem.Console.WriteLine(<span>$&quot;Original text: &#39;<span>{text}</span>&#39;&quot;</span>);\r\n\r\n<span>string</span>[] words = text.Split(delimiterChars);\r\nSystem.Console.WriteLine(<span>$&quot;<span>{words.Length}</span> words in text:&quot;</span>);\r\n\r\n<span>foreach</span> (<span>var</span> word <span>in</span> words)\r\n{\r\n    System.Console.WriteLine(<span>$&quot;&lt;<span>{word}</span>&gt;&quot;</span>);\r\n}\r\n</code></pre>\r\n<p>\r\n\tConsecutive instances of any separator produce the empty string in the output array:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>char</span>[] delimiterChars = { <span>&#39; &#39;</span>, <span>&#39;,&#39;</span>, <span>&#39;.&#39;</span>, <span>&#39;:&#39;</span>, <span>&#39;\\t&#39;</span> };\r\n\r\n<span>string</span> text = <span>&quot;one\\ttwo :,five six seven&quot;</span>;\r\nSystem.Console.WriteLine(<span>$&quot;Original text: &#39;<span>{text}</span>&#39;&quot;</span>);\r\n\r\n<span>string</span>[] words = text.Split(delimiterChars);\r\nSystem.Console.WriteLine(<span>$&quot;<span>{words.Length}</span> words in text:&quot;</span>);\r\n\r\n<span>foreach</span> (<span>var</span> word <span>in</span> words)\r\n{\r\n    System.Console.WriteLine(<span>$&quot;&lt;<span>{word}</span>&gt;&quot;</span>);\r\n}&nbsp;</code></pre>\r\n<p>\r\n\t<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.split\" target=\"_blank\">String.Split</a>&nbsp;can take an array of strings (character sequences that act as separators for parsing the target string, instead of single characters).</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>        <span>string</span>[] separatingChars = { <span>&quot;&lt;&lt;&quot;</span>, <span>&quot;...&quot;</span> };  \r\n\r\n        <span>string</span> text = <span>&quot;one&lt;&lt;two......three&lt;four&quot;</span>;  \r\n        System.Console.WriteLine(<span>&quot;Original text: &#39;{0}&#39;&quot;</span>, text);  \r\n\r\n        <span>string</span>[] words = text.Split(separatingChars, System.StringSplitOptions.RemoveEmptyEntries );  \r\n        System.Console.WriteLine(<span>&quot;{0} substrings in text:&quot;</span>, words.Length);  \r\n\r\n        <span>foreach</span> (<span>var</span> word <span>in</span> words)\r\n        {\r\n            System.Console.WriteLine(word);\r\n        }\r\n</code></pre>\r\n<p>\r\n\t<span>You can try these samples by looking at the code in our&nbsp;</span><a href=\"https://github.com/dotnet/samples/tree/master/snippets/csharp/how-to/strings\" target=\"_blank\">GitHub repository</a><span>. Or you can download the samples&nbsp;</span><a href=\"https://github.com/dotnet/samples/raw/master/snippets/csharp/how-to/strings.zip\" target=\"_blank\">as a zip file</a><span>.</span></p>"
          },
          {
            "Concatenate Multiple Strings": "<p>\r\n\t<em>Concatenation</em>&nbsp;is the process of appending one string to the end of another string. You concatenate strings by using the&nbsp;<code>+</code>&nbsp;operator. For string literals and string constants, concatenation occurs at compile time; no run-time concatenation occurs. For string variables, concatenation occurs only at run time.</p>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;</p>\r\n\t<p>\r\n\t\tThe C# examples in this article run in the<span>&nbsp;</span><a href=\"https://try.dot.net/\" target=\"_blank\">Try.NET</a>&nbsp;inline code runner and playground. Select the&nbsp;Run&nbsp;button to run an example in an interactive window. Once you execute the code, you can modify it and run the modified code by selecting&nbsp;Run&nbsp;again. The modified code either runs in the interactive window or, if compilation fails, the interactive window displays all C# compiler error messages.</p>\r\n\t<p>\r\n\t\t&nbsp;</p>\r\n</div>\r\n<p>\r\n\tThe following example uses concatenation to split a long string literal into smaller strings in order to improve readability in the source code. These parts are concatenated into a single string at compile time. There is no run-time performance cost regardless of the number of strings involved.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Concatenation of literals is performed at compile time, not run time.</span>\r\n<span>string</span> text = <span>&quot;Historically, the world of data and the world of objects &quot;</span> +\r\n<span>&quot;have not been well integrated. Programmers work in C# or Visual Basic &quot;</span> +\r\n<span>&quot;and also in SQL or XQuery. On the one side are concepts such as classes, &quot;</span> +\r\n<span>&quot;objects, fields, inheritance, and .NET Framework APIs. On the other side &quot;</span> +\r\n<span>&quot;are tables, columns, rows, nodes, and separate languages for dealing with &quot;</span> +\r\n<span>&quot;them. Data types often require translation between the two worlds; there are &quot;</span> +\r\n<span>&quot;different standard functions. Because the object world has no notion of query, a &quot;</span> +\r\n<span>&quot;query can only be represented as a string without compile-time type checking or &quot;</span> +\r\n<span>&quot;IntelliSense support in the IDE. Transferring data from SQL tables or XML trees to &quot;</span> +\r\n<span>&quot;objects in memory is often tedious and error-prone.&quot;</span>;\r\n\r\nSystem.Console.WriteLine(text);\r\n</code></pre>\r\n<p>\r\n\tTo concatenate string variables, you can use the&nbsp;<code>+</code>&nbsp;or&nbsp;<code>+=</code>&nbsp;operators,&nbsp;string interpolation&nbsp;or the&nbsp;String.Format,&nbsp;String.Concat,&nbsp;String.Join&nbsp;or&nbsp;StringBuilder.Append&nbsp;methods. The&nbsp;<code>+</code>&nbsp;operator is easy to use and makes for intuitive code. Even if you use several&nbsp;<code>+</code>&nbsp;operators in one statement, the string content is copied only once. The following code shows examples of using the&nbsp;<code>+</code>&nbsp;and&nbsp;<code>+=</code>&nbsp;operators to concatenate strings:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> userName = <span>&quot;&lt;Type your name here&gt;&quot;</span>;\r\n<span>string</span> dateString = DateTime.Today.ToShortDateString();\r\n\r\n<span>// Use the + and += operators for one-time concatenations.</span>\r\n<span>string</span> str = <span>&quot;Hello &quot;</span> + userName + <span>&quot;. Today is &quot;</span> + dateString + <span>&quot;.&quot;</span>;\r\nSystem.Console.WriteLine(str);\r\n\r\nstr += <span>&quot; How are you today?&quot;</span>;\r\nSystem.Console.WriteLine(str);\r\n</code></pre>\r\n<p>\r\n\tIn some expressions, it&#39;s easier to concatenate strings using string interpolation, as the following code shows:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> userName = <span>&quot;&lt;Type your name here&gt;&quot;</span>;\r\n<span>string</span> date = DateTime.Today.ToShortDateString();\r\n\r\n<span>// Use string interpolation to concatenate strings.</span>\r\n<span>string</span> str = <span>$&quot;Hello <span>{userName}</span>. Today is <span>{date}</span>.&quot;</span>;\r\nSystem.Console.WriteLine(str);\r\n\r\nstr = <span>$&quot;<span>{str}</span> How are you today?&quot;</span>;\r\nSystem.Console.WriteLine(str);\r\n</code></pre>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tIn string concatenation operations, the C# compiler treats a null string the same as an empty string.</p>\r\n</div>\r\n<p>\r\n\tOther method to concatenate strings is&nbsp;String.Format. This method works well when you are building a string from a small number of component strings.</p>\r\n<p>\r\n\tIn other cases you may be combining strings in a loop, where you don&#39;t know how many source strings you are combining, and the actual number of source strings may be quite large. The&nbsp;StringBuilder&nbsp;class was designed for these scenarios. The following code uses the&nbsp;Append&nbsp;method of the&nbsp;StringBuilder&nbsp;class to concatenate strings.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Use StringBuilder for concatenation in tight loops.</span>\r\n<span>var</span> sb = <span>new</span> System.Text.StringBuilder();\r\n<span>for</span> (<span>int</span> i = <span>0</span>; i &lt; <span>20</span>; i++)\r\n{\r\n    sb.AppendLine(i.ToString());\r\n}\r\nSystem.Console.WriteLine(sb.ToString());\r\n</code></pre>\r\n<p>\r\n\tYou can read more about the&nbsp;<span>&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.text.stringbuilder#StringAndSB\" target=\"_blank\">reasons to choose string concatenation or the&nbsp;<code>StringBuilder</code>&nbsp;class</a>.</p>\r\n<p>\r\n\tAnother option to join strings from a collection is to use&nbsp;String.Concat&nbsp;method. Use&nbsp;String.Join&nbsp;method if source strings should be separated by a delimeter. The following code combines an array of words using both methods:</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span>[] words = { <span>&quot;The&quot;</span>, <span>&quot;quick&quot;</span>, <span>&quot;brown&quot;</span>, <span>&quot;fox&quot;</span>, <span>&quot;jumps&quot;</span>, <span>&quot;over&quot;</span>, <span>&quot;the&quot;</span>, <span>&quot;lazy&quot;</span>, <span>&quot;dog.&quot;</span> };\r\n\r\n<span>var</span> unreadablePhrase = <span>string</span>.Concat(words);\r\nSystem.Console.WriteLine(unreadablePhrase);\r\n\r\n<span>var</span> readablePhrase = <span>string</span>.Join(<span>&quot; &quot;</span>, words);\r\nSystem.Console.WriteLine(readablePhrase);\r\n</code></pre>\r\n<p>\r\n\tAt last, you can use&nbsp;<span>&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/index\" target=\"_blank\">LINQ</a>&nbsp;and the<span>&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.aggregate\" target=\"_blank\">Enumerable.Aggregate</a>&nbsp;method to join strings from a collection. This method combines the source strings using a lambda expression. The lambda expression does the work to add each string to the existing accumulation. The following example combines an array of words by adding a space between each word in the array:</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span>[] words = { <span>&quot;The&quot;</span>, <span>&quot;quick&quot;</span>, <span>&quot;brown&quot;</span>, <span>&quot;fox&quot;</span>, <span>&quot;jumps&quot;</span>, <span>&quot;over&quot;</span>, <span>&quot;the&quot;</span>, <span>&quot;lazy&quot;</span>, <span>&quot;dog.&quot;</span> };\r\n\r\n<span>var</span> phrase = words.Aggregate((partialPhrase, word) =&gt;<span>$&quot;<span>{partialPhrase}</span> <span>{word}</span>&quot;</span>);\r\nSystem.Console.WriteLine(phrase);</code></pre>"
          },
          {
            "Search strings": "<p>\r\n\tYou can use two main strategies to search for text in strings. Methods of the&nbsp;<a href=\"http://semantic-portal.net/language-reference-types-referencetypes-string\" target=\"_blank\">String</a>&nbsp;class search for specific text. Regular expressions search for patterns in text.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tThe C# examples in this article run in the&nbsp;Try.NET&nbsp;inline code runner and playground. Select the&nbsp;<span>Run</span>&nbsp;button to run an example in an interactive window. Once you execute the code, you can modify it and run the modified code by selecting&nbsp;<span>Run</span>&nbsp;again. The modified code either runs in the interactive window or, if compilation fails, the interactive window displays all C# compiler error messages.</p>\r\n</div>\r\n<p>\r\n\t<span>The&nbsp;</span><a href=\"http://semantic-portal.net/language-reference-types-referencetypes-string\" target=\"_blank\">String</a>&nbsp;type, which is an alias for the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string\" target=\"_blank\">System.String</a>&nbsp;class, provides a number of useful methods for searching the contents of a string. Among them are&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.contains\" target=\"_blank\">Contains</a>,&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.startswith\" target=\"_blank\">StartsWith</a>,&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.endswith\" target=\"_blank\">EndsWith</a>,&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.indexof\" target=\"_blank\">IndexOf</a>,&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.lastindexof\" target=\"_blank\">LastIndexOf</a>. The&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex\" target=\"_blank\">System.Text.RegularExpressions.Regex</a>&nbsp;class provides a rich vocabulary to search for patterns in text. In this article, you learn these techniques and how to choose the best method for your needs.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<h2>\r\n\tDoes a string contain text?</h2>\r\n<p>\r\n\t<span>The&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.contains\" target=\"_blank\">String.Contains</a><span>,&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.startswith\" target=\"_blank\">String.StartsWith</a><span>&nbsp;and&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.endswith\" target=\"_blank\">String.EndsWith</a>&nbsp;methods search a string for specific text. The following example shows each of these methods and a variation that uses a case insensitive search:</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> factMessage = <span>&quot;Extension methods have all the capabilities of regular static methods.&quot;</span>;\r\n\r\n<span>// Write the string and include the quotation marks.</span>\r\nConsole.WriteLine(<span>$&quot;\\&quot;<span>{factMessage}</span>\\&quot;&quot;</span>);\r\n\r\n<span>// Simple comparisons are always case sensitive!</span>\r\n<span>bool</span> containsSearchResult = factMessage.Contains(<span>&quot;extension&quot;</span>);\r\nConsole.WriteLine(<span>$&quot;Starts with \\&quot;extension\\&quot;? <span>{containsSearchResult}</span>&quot;</span>);\r\n\r\n<span>// For user input and strings that will be displayed to the end user, </span>\r\n<span>// use the StringComparison parameter on methods that have it to specify how to match strings.</span>\r\n<span>bool</span> ignoreCaseSearchResult = factMessage.StartsWith(<span>&quot;extension&quot;</span>, System.StringComparison.CurrentCultureIgnoreCase);\r\nConsole.WriteLine(<span>$&quot;Starts with \\&quot;extension\\&quot;? <span>{ignoreCaseSearchResult}</span> (ignoring case)&quot;</span>);\r\n\r\n<span>bool</span> endsWithSearchResult = factMessage.EndsWith(<span>&quot;.&quot;</span>, System.StringComparison.CurrentCultureIgnoreCase);\r\nConsole.WriteLine(<span>$&quot;Ends with &#39;.&#39;? <span>{endsWithSearchResult}</span>&quot;</span>);\r\n</code></pre>\r\n<p>\r\n\tThe preceding example demonstrates an important point for using these methods. Searches are&nbsp;<span>case-sensitive</span>&nbsp;by default. You use the&nbsp;StringComparison.CurrentCultureIgnoreCase&nbsp;enum value to specify a case insensitive search.</p>\r\n<h2>\r\n\tWhere does the sought text occur in a string?</h2>\r\n<p>\r\n\t<span>The&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.indexof\" target=\"_blank\">IndexOf</a><span>&nbsp;and&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.lastindexof\" target=\"_blank\">LastIndexOf</a>&nbsp;methods also search for text in strings. These methods return the location of the text being sought. If the text isn&#39;t found, they return&nbsp;<code>-1</code>. The following example shows a search for the first and last occurrence of the word &quot;methods&quot; and displays the text in between.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> factMessage = <span>&quot;Extension methods have all the capabilities of regular static methods.&quot;</span>;\r\n\r\n<span>// Write the string and include the quotation marks.</span>\r\nConsole.WriteLine(<span>$&quot;\\&quot;<span>{factMessage}</span>\\&quot;&quot;</span>);\r\n\r\n<span>// This search returns the substring between two strings, so </span>\r\n<span>// the first index is moved to the character just after the first string.</span>\r\n<span>int</span> first = factMessage.IndexOf(<span>&quot;methods&quot;</span>) + <span>&quot;methods&quot;</span>.Length;\r\n<span>int</span> last = factMessage.LastIndexOf(<span>&quot;methods&quot;</span>);\r\n<span>string</span> str2 = factMessage.Substring(first, last - first);\r\nConsole.WriteLine(<span>$&quot;Substring between \\&quot;methods\\&quot; and \\&quot;methods\\&quot;: &#39;<span>{str2}</span>&#39;&quot;</span>);\r\n</code></pre>\r\n<h2>\r\n\tFinding specific text using regular expressions</h2>\r\n<p>\r\n\tThe&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex\" target=\"_blank\">System.Text.RegularExpressions.Regex</a>&nbsp;class can be used to search strings. These searches can range in complexity from simple to complicated text patterns.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<p>\r\n\tThe following code example searches for the word &quot;the&quot; or &quot;their&quot; in a sentence, ignoring case. The static method&nbsp;Regex.IsMatch&nbsp;performs the search. You give it the string to search and a search pattern. In this case, a third argument specifies case-insensitive search. For more information, see&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regexoptions\" target=\"_blank\">System.Text.RegularExpressions.RegexOptions</a>.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<p>\r\n\tThe search pattern describes the text you search for. The following table describes each element of the search pattern. (The table below uses the single&nbsp;<code>\\</code>&nbsp;which must be escaped as&nbsp;<code>\\\\</code>&nbsp;in a C# string).</p>\r\n<div>\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tpattern</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tMeaning</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tthe</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tmatch the text &quot;the&quot;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t(eir)?</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tmatch 0 or 1 occurence of &quot;eir&quot;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t\\s</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tmatch a white-space character</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span>[] sentences =\r\n{\r\n    <span>&quot;Put the water over there.&quot;</span>,\r\n    <span>&quot;They&#39;re quite thirsty.&quot;</span>,\r\n    <span>&quot;Their water bottles broke.&quot;</span>\r\n};\r\n\r\n<span>string</span> sPattern = <span>&quot;the(ir)?\\\\s&quot;</span>;\r\n\r\n<span>foreach</span> (<span>string</span> s <span>in</span> sentences)\r\n{\r\n    Console.Write(<span>$&quot;<span>{s,<span>24</span>}</span>&quot;</span>);\r\n\r\n    <span>if</span> (System.Text.RegularExpressions.Regex.IsMatch(s, sPattern, System.Text.RegularExpressions.RegexOptions.IgnoreCase))\r\n    {\r\n        Console.WriteLine(<span>$&quot;  (match for &#39;<span>{sPattern}</span>&#39; found)&quot;</span>);\r\n    }\r\n    <span>else</span>\r\n    {\r\n        Console.WriteLine();\r\n    }\r\n}\r\n</code></pre>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Tip</p>\r\n\t<p>\r\n\t\tThe&nbsp;<code>string</code>&nbsp;methods are usually better choices when you are searching for an exact string. Regular expressions are better when you are searching for some pattern is a source string.</p>\r\n</div>\r\n<h2>\r\n\tDoes a string follow a pattern?</h2>\r\n<p>\r\n\tThe following code uses regular expressions to validate the format of each string in an array. The validation requires that each string have the form of a telephone number in which three groups of digits are separated by dashes, the first two groups contain three digits, and the third group contains four digits. The search pattern uses the regular expression&nbsp;<code>^\\\\d{3}-\\\\d{3}-\\\\d{4}$</code>. For more information, see<span>&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference\" target=\"_blank\">Regular Expression Language - Quick Reference</a>.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<div>\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tpattern</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tMeaning</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t^</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tmatches the beginning of the string</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t\\d{3}</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tmatches exactly 3 digit characters</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t-</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tmatches the &#39;-&#39; character</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t\\d{3}</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tmatches exactly 3 digit characters</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t-</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tmatches the &#39;-&#39; character</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t\\d{4}</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tmatches exactly 4 digit characters</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t$</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tmatches the end of the string</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span>[] numbers =\r\n{\r\n    <span>&quot;123-555-0190&quot;</span>,\r\n    <span>&quot;444-234-22450&quot;</span>,\r\n    <span>&quot;690-555-0178&quot;</span>,\r\n    <span>&quot;146-893-232&quot;</span>,\r\n    <span>&quot;146-555-0122&quot;</span>,\r\n    <span>&quot;4007-555-0111&quot;</span>,\r\n    <span>&quot;407-555-0111&quot;</span>,\r\n    <span>&quot;407-2-5555&quot;</span>,\r\n    <span>&quot;407-555-8974&quot;</span>,\r\n    <span>&quot;407-2ab-5555&quot;</span>,\r\n    <span>&quot;690-555-8148&quot;</span>,\r\n    <span>&quot;146-893-232-&quot;</span>\r\n};\r\n\r\n<span>string</span> sPattern = <span>&quot;^\\\\d{3}-\\\\d{3}-\\\\d{4}$&quot;</span>;\r\n\r\n<span>foreach</span> (<span>string</span> s <span>in</span> numbers)\r\n{\r\n    Console.Write(<span>$&quot;<span>{s,<span>14</span>}</span>&quot;</span>);\r\n\r\n    <span>if</span> (System.Text.RegularExpressions.Regex.IsMatch(s, sPattern))\r\n    {\r\n        Console.WriteLine(<span>&quot; - valid&quot;</span>);\r\n    }\r\n    <span>else</span>\r\n    {\r\n        Console.WriteLine(<span>&quot; - invalid&quot;</span>);\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tThis single search pattern matches many valid strings. Regular expressions are better to search for or validate against a pattern, rather than a single text string.</p>"
          },
          {
            "Modify string contents": "<p>\r\n\tThis article demonstrates several techniques to produce a&nbsp;<code>string</code>&nbsp;by modifying an existing&nbsp;<code>string</code>. All the techniques demonstrated return the result of the modifications as a new&nbsp;<code>string</code>&nbsp;object. To clearly demonstrate this, the examples all store the result in a new variable. You can then examine both the original&nbsp;<code>string</code>&nbsp;and the&nbsp;<code>string</code>&nbsp;resulting from the modification when you run each example.</p>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tThe C# examples in this article run in the&nbsp;Try.NET&nbsp;inline code runner and playground. Select the&nbsp;<span>Run</span>&nbsp;button to run an example in an interactive window. Once you execute the code, you can modify it and run the modified code by selecting&nbsp;<span>Run</span>&nbsp;again. The modified code either runs in the interactive window or, if compilation fails, the interactive window displays all C# compiler error messages.</p>\r\n</div>\r\n<p>\r\n\tThere are several techniques demonstrated in this article. You can replace existing text. You can search for patterns and replace matching text with other text. You can treat a string as a sequence of characters. You can also use convenience methods that remove white space. You should choose the techniques that most closely match your scenario.</p>\r\n<h2>\r\n\tReplace text</h2>\r\n<p>\r\n\tThe following code creates a new string by replacing existing text with a substitute.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> source = <span>&quot;The mountains are behind the clouds today.&quot;</span>;\r\n\r\n<span>// Replace one substring with another with String.Replace.</span>\r\n<span>// Only exact matches are supported.</span>\r\n<span>var</span> replacement = source.Replace(<span>&quot;mountains&quot;</span>, <span>&quot;peaks&quot;</span>);\r\nConsole.WriteLine(<span>$&quot;The source string is &lt;<span>{source}</span>&gt;&quot;</span>);\r\nConsole.WriteLine(<span>$&quot;The updated string is &lt;<span>{replacement}</span>&gt;&quot;</span>);\r\n</code></pre>\r\n<p>\r\n\tThe preceding code demonstrates this&nbsp;<em>immutable</em>&nbsp;property of strings. You can see in the preceding example that the original string,&nbsp;<code>source</code>, is not modified. The&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.replace\" target=\"_blank\">String.Replace</a>&nbsp;method creates a new&nbsp;<code>string</code>&nbsp;containing the modifications.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<p>\r\n\tThe&nbsp;Replace&nbsp;method can replace either strings or single characters. In both cases, every occurrence of the sought text is replaced. The following example replaces all &#39; &#39; characters with &#39;_&#39;:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> source = <span>&quot;The mountains are behind the clouds today.&quot;</span>;\r\n\r\n<span>// Replace all occurrences of one char with another.</span>\r\n<span>var</span> replacement = source.Replace(<span>&#39; &#39;</span>, <span>&#39;_&#39;</span>);\r\nConsole.WriteLine(source);\r\nConsole.WriteLine(replacement);\r\n</code></pre>\r\n<p>\r\n\tThe source string is unchanged, and a new string is returned with the replacement.</p>\r\n<h2>\r\n\tTrim white space</h2>\r\n<p>\r\n\tYou can use the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.trim\" target=\"_blank\">String.Trim</a><span>,&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.trimstart\" target=\"_blank\">String.TrimStart</a><span>, and&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.trimend\" target=\"_blank\">String.TrimEnd</a>&nbsp;methods to remove any leading or trailing white space. The following code shows an example of each. The source string does not change; these methods return a new string with the modified contents.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Remove trailing and leading white space.</span>\r\n<span>string</span> source = <span>&quot;    I&#39;m wider than I need to be.      &quot;</span>;\r\n<span>// Store the results in a new string variable.</span>\r\n<span>var</span> trimmedResult = source.Trim();\r\n<span>var</span> trimLeading = source.TrimStart();\r\n<span>var</span> trimTrailing = source.TrimEnd();\r\nConsole.WriteLine(<span>$&quot;&lt;<span>{source}</span>&gt;&quot;</span>);\r\nConsole.WriteLine(<span>$&quot;&lt;<span>{trimmedResult}</span>&gt;&quot;</span>);\r\nConsole.WriteLine(<span>$&quot;&lt;<span>{trimLeading}</span>&gt;&quot;</span>);\r\nConsole.WriteLine(<span>$&quot;&lt;<span>{trimTrailing}</span>&gt;&quot;</span>);\r\n</code></pre>\r\n<h2>\r\n\tRemove text</h2>\r\n<p>\r\n\tYou can remove text from a string using the&nbsp;String.Remove&nbsp;method. This method removes a number of characters starting at a specific index. The following example shows how to use&nbsp;String.IndexOffollowed by&nbsp;Remove&nbsp;to remove text from a string:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> source = <span>&quot;Many mountains are behind many clouds today.&quot;</span>;\r\n<span>// Remove a substring from the middle of the string.</span>\r\n<span>string</span> toRemove = <span>&quot;many &quot;</span>;\r\n<span>string</span> result = <span>string</span>.Empty;\r\n<span>int</span> i = source.IndexOf(toRemove);\r\n<span>if</span> (i &gt;= <span>0</span>)\r\n{\r\n    result= source.Remove(i, toRemove.Length);\r\n}\r\nConsole.WriteLine(source);\r\nConsole.WriteLine(result);\r\n</code></pre>\r\n<h2>\r\n\tReplace matching patterns</h2>\r\n<p>\r\n\tYou can use&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expressions\" target=\"_blank\">regular expressions</a>&nbsp;to replace text matching patterns with new text, possibly defined by a pattern. The following example uses the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex\" target=\"_blank\">System.Text.RegularExpressions.Regex</a>&nbsp;class to find a pattern in a source string and replace it with proper capitalization. The&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.replace#System_Text_RegularExpressions_Regex_Replace_System_String_System_String_System_Text_RegularExpressions_MatchEvaluator_System_Text_RegularExpressions_RegexOptions_\" target=\"_blank\">Regex.Replace(String, String, MatchEvaluator, RegexOptions)</a>&nbsp;method takes a function that provides the logic of the replacement as one of its arguments. In this example, that function,&nbsp;<code>LocalReplaceMatchCase</code>&nbsp;is a&nbsp;<span>local function</span>declared inside the sample method.&nbsp;<code>LocalReplaceMatchCase</code>&nbsp;uses the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.text.stringbuilder\" target=\"_blank\">System.Text.StringBuilder</a>&nbsp;class to build the replacement string with proper capitalization.</p>\r\n<p>\r\n\tRegular expressions are most useful for searching and replacing text that follows a pattern, rather than known text. See&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/how-to/search-strings\" target=\"_blank\">How to: search strings</a>&nbsp;for more details. The search pattern, &quot;the\\s&quot; searches for the word &quot;the&quot; followed by a white-space character. That part of the pattern ensures that it doesn&#39;t match &quot;there&quot; in the source string. For more information on regular expression language elements, see&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference\" target=\"_blank\">Regular Expression Language - Quick Reference</a>.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> source = <span>&quot;The mountains are still there behind the clouds today.&quot;</span>;\r\n\r\n<span>// Use Regex.Replace for more flexibility. </span>\r\n<span>// Replace &quot;the&quot; or &quot;The&quot; with &quot;many&quot; or &quot;Many&quot;.</span>\r\n<span>// using System.Text.RegularExpressions</span>\r\n<span>string</span> replaceWith = <span>&quot;many &quot;</span>;\r\nsource = System.Text.RegularExpressions.Regex.Replace(source, <span>&quot;the\\\\s&quot;</span>, LocalReplaceMatchCase, \r\n    System.Text.RegularExpressions.RegexOptions.IgnoreCase);\r\nConsole.WriteLine(source);\r\n\r\n<span><span>string</span> <span>LocalReplaceMatchCase</span>(<span>System.Text.RegularExpressions.Match matchExpression</span>)\r\n</span>{\r\n    <span>// Test whether the match is capitalized</span>\r\n    <span>if</span> (Char.IsUpper(matchExpression.Value[<span>0</span>]))\r\n    {\r\n        <span>// Capitalize the replacement string</span>\r\n        System.Text.StringBuilder replacementBuilder = <span>new</span> System.Text.StringBuilder(replaceWith);\r\n        replacementBuilder[<span>0</span>] = Char.ToUpper(replacementBuilder[<span>0</span>]);\r\n        <span>return</span> replacementBuilder.ToString();\r\n    }\r\n    <span>else</span>\r\n    {\r\n        <span>return</span> replaceWith;\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tThe&nbsp;<span>&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.text.stringbuilder.tostring\" target=\"_blank\">StringBuilder.ToString</a><span>&nbsp;method returns an immutable string with the contents in the&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.text.stringbuilder\" target=\"_blank\">StringBuilder</a><span>&nbsp;</span>object.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<h2>\r\n\tModifying individual characters</h2>\r\n<p>\r\n\tYou can produce a character array from a string, modify the contents of the array, and then create a new string from the modified contents of the array.</p>\r\n<p>\r\n\tThe following example shows how to replace a set of characters in a string. First, it uses the&nbsp;ToCharArray()&nbsp;method to create an array of characters. It uses the&nbsp;IndexOf&nbsp;method to find the starting index of the word &quot;fox.&quot; The next three characters are replaced with a different word. Finally, a new string is constructed from the updated character array.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> phrase = <span>&quot;The quick brown fox jumps over the fence&quot;</span>;\r\nConsole.WriteLine(phrase);\r\n\r\n<span>char</span>[] phraseAsChars = phrase.ToCharArray();\r\n<span>int</span> animalIndex = phrase.IndexOf(<span>&quot;fox&quot;</span>);\r\n<span>if</span> (animalIndex != <span>-1</span>)\r\n{\r\n    phraseAsChars[animalIndex++] = <span>&#39;c&#39;</span>;\r\n    phraseAsChars[animalIndex++] = <span>&#39;a&#39;</span>;\r\n    phraseAsChars[animalIndex] = <span>&#39;t&#39;</span>;\r\n}\r\n\r\n<span>string</span> updatedPhrase = <span>new</span> <span>string</span>(phraseAsChars);\r\nConsole.WriteLine(updatedPhrase);\r\n</code></pre>\r\n<h2>\r\n\tUnsafe modifications to string</h2>\r\n<p>\r\n\tUsing&nbsp;<span>unsafe</span>&nbsp;code, you can modify a string &quot;in place&quot; after it has been created. Unsafe code bypasses many of the features of .NET designed to minimize certain types of bugs in code. You need to use unsafe code to modify a string in place because the string class is designed as an&nbsp;<span>immutable</span>&nbsp;type. Once it has been created, its value does not change. Unsafe code circumvents this property by accessing and modifying the memory used by a&nbsp;<code>string</code>&nbsp;without using normal&nbsp;<code>string</code>&nbsp;methods. The following example is provided for those rare situations where you want to modify a string in-place using unsafe code. The example shows how to use the&nbsp;<code>fixed</code>&nbsp;keyword. The&nbsp;<code>fixed</code>&nbsp;keyword prevents the garbage collector (GC) from moving the string object in memory while code accesses the memory using the unsafe pointer. It also demonstrates one possible side effect of unsafe operations on strings that results from the way that the C# compiler stores (interns) strings internally. In general, you shouldn&#39;t use this technique unless it is absolutely necessary. You can learn more in the articles on&nbsp;<a href=\"http://semantic-portal.net/language-reference-modifiers-unsafe\" target=\"_blank\">unsafe</a>&nbsp;and&nbsp;fixed.&nbsp;The API reference for&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.string.intern\" target=\"_blank\">Intern</a>&nbsp;includes information on string interning.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>unsafe</span>\r\n{\r\n    <span>// Compiler will store (intern) </span>\r\n    <span>// these strings in same location.</span>\r\n    <span>string</span> helloOne = <span>&quot;Hello&quot;</span>;\r\n    <span>string</span> helloTwo = <span>&quot;Hello&quot;</span>;\r\n\r\n    <span>// Change one string using unsafe code.</span>\r\n    <span>fixed</span> (<span>char</span>* p = helloOne)\r\n    {\r\n        p[<span>0</span>] = <span>&#39;C&#39;</span>;\r\n    }\r\n\r\n    <span>//  Both strings have changed.</span>\r\n    Console.WriteLine(helloOne);\r\n    Console.WriteLine(helloTwo);\r\n}\r\nYou can try these samples by looking at the code in our&nbsp;<a href=\"https://github.com/dotnet/samples/tree/master/snippets/csharp/how-to/strings\" target=\"_blank\">GitHub repository</a><span>. Or you can download the samples&nbsp;</span><a href=\"https://github.com/dotnet/samples/raw/master/snippets/csharp/how-to/strings.zip\" target=\"_blank\">as a zip file</a><span>.</span></code></pre>"
          },
          {
            "How to compare strings": "<p>\r\n\tYou compare strings to answer one of two questions: &quot;Are these two strings equal?&quot; or &quot;In what order should these strings be placed when sorting them?&quot;</p>\r\n<p>\r\n\tThose two questions are complicated by factors that affect string comparisons:</p>\r\n<ul>\r\n\t<li>\r\n\t\tYou can choose an ordinal or linguistic comparison.</li>\r\n\t<li>\r\n\t\tYou can choose if case matters.</li>\r\n\t<li>\r\n\t\tYou can choose culture specific comparisons.</li>\r\n\t<li>\r\n\t\tLinguistic comparisons are culture and platform dependent.</li>\r\n</ul>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;</p>\r\n\t<p>\r\n\t\tThe C# examples in this article run in the<span>&nbsp;</span><a href=\"https://try.dot.net/\" target=\"_blank\">Try.NET</a>&nbsp;inline code runner and playground. Select the&nbsp;Run&nbsp;button to run an example in an interactive window. Once you execute the code, you can modify it and run the modified code by selecting&nbsp;Run&nbsp;again. The modified code either runs in the interactive window or, if compilation fails, the interactive window displays all C# compiler error messages.</p>\r\n\t<p>\r\n\t\t&nbsp;</p>\r\n</div>\r\n<p>\r\n\tWhen you compare strings, you define an order among them. Comparisons are used to sort a sequence of strings. Once the sequence is in a known order, it is easier to search, both for software and for humans. Other comparisons may check if strings are the same. These sameness checks are similar to equality, but some differences, such as case differences, may be ignored.</p>\r\n<h2>\r\n\tDefault ordinal comparisons</h2>\r\n<p>\r\n\tThe most common operations,&nbsp;String.CompareTo&nbsp;and&nbsp;String.Equals&nbsp;or&nbsp;String.Equality&nbsp;use an ordinal comparison, a case-sensitive comparison, and use the current culture. The results are shown in the following example.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> root = <span>@&quot;C:\\users&quot;</span>;\r\n<span>string</span> root2 = <span>@&quot;C:\\Users&quot;</span>;\r\n\r\n<span>bool</span> result = root.Equals(root2);\r\n<span>int</span> comparison = root.CompareTo(root2);\r\nConsole.WriteLine(<span>$&quot;Ordinal comparison: &lt;<span>{root}</span>&gt; and &lt;<span>{root2}</span>&gt; are <span>{(result ? <span>&quot;equal.&quot;</span> : <span>&quot;not equal.&quot;</span>)}</span>&quot;</span>);\r\n<span>if</span> (comparison &lt; <span>0</span>)\r\n    Console.WriteLine(<span>$&quot;&lt;<span>{root}</span>&gt; is less than &lt;<span>{root2}</span>&gt;&quot;</span>);\r\n<span>else</span> <span>if</span> (comparison &gt; <span>0</span>)\r\n    Console.WriteLine(<span>$&quot;&lt;<span>{root}</span>&gt; is greater than &lt;<span>{root2}</span>&gt;&quot;</span>);\r\n<span>else</span>\r\n    Console.WriteLine(<span>$&quot;&lt;<span>{root}</span>&gt; and &lt;<span>{root2}</span>&gt; are equivalent in order&quot;</span>);\r\n\r\nresult = root.Equals(root2, StringComparison.Ordinal);\r\nConsole.WriteLine(<span>$&quot;Ordinal comparison: &lt;<span>{root}</span>&gt; and &lt;<span>{root2}</span>&gt; are <span>{(result ? <span>&quot;equal.&quot;</span> : <span>&quot;not equal.&quot;</span>)}</span>&quot;</span>);\r\n\r\nConsole.WriteLine(<span>$&quot;Using == says that &lt;<span>{root}</span>&gt; and &lt;<span>{root2}</span>&gt; are <span>{(root == root2 ? <span>&quot;equal&quot;</span> : <span>&quot;not equal&quot;</span>)}</span>&quot;</span>);               \r\n</code></pre>\r\n<p>\r\n\tOrdinal comparisons do not take linguistic rules into account when comparing strings. They will compare the strings character by character. Case-sensitive comparisons use capitalization in their comparisons. The most important point about these default comparison methods is that because they use the current culture, the results depend on the locale and language settings of the machine where they run. These comparisons are unsuitable for comparisons where order should be consistent across machines or locations.</p>\r\n<h2>\r\n\tCase-insensitive ordinal comparisons</h2>\r\n<p>\r\n\tThe&nbsp;String.Equals&nbsp;method enables you to specify a&nbsp;StringComparison&nbsp;value ofStringComparison.OrdinalIgnoreCase&nbsp;to specify a case-insensitive comparison. There is also a staticCompare&nbsp;method that includes a boolean argument to specify case-insensitive comparisons. These are shown in the following code:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> root = <span>@&quot;C:\\users&quot;</span>;\r\n<span>string</span> root2 = <span>@&quot;C:\\Users&quot;</span>;\r\n\r\n<span>bool</span> result = root.Equals(root2, StringComparison.OrdinalIgnoreCase);\r\n<span>bool</span> areEqual = String.Equals(root, root2, StringComparison.OrdinalIgnoreCase);\r\n<span>int</span> comparison = String.Compare(root, root2, ignoreCase: <span>true</span>);\r\n\r\nConsole.WriteLine(<span>$&quot;Ordinal ignore case: &lt;<span>{root}</span>&gt; and &lt;<span>{root2}</span>&gt; are <span>{(result ? <span>&quot;equal.&quot;</span> : <span>&quot;not equal.&quot;</span>)}</span>&quot;</span>);\r\nConsole.WriteLine(<span>$&quot;Ordinal static ignore case: &lt;<span>{root}</span>&gt; and &lt;<span>{root2}</span>&gt; are <span>{(areEqual ? <span>&quot;equal.&quot;</span> : <span>&quot;not equal.&quot;</span>)}</span>&quot;</span>);\r\n<span>if</span> (comparison &lt; <span>0</span>)\r\n    Console.WriteLine(<span>$&quot;&lt;<span>{root}</span>&gt; is less than &lt;<span>{root2}</span>&gt;&quot;</span>);\r\n<span>else</span> <span>if</span> (comparison &gt; <span>0</span>)\r\n    Console.WriteLine(<span>$&quot;&lt;<span>{root}</span>&gt; is greater than &lt;<span>{root2}</span>&gt;&quot;</span>);\r\n<span>else</span>\r\n    Console.WriteLine(<span>$&quot;&lt;<span>{root}</span>&gt; and &lt;<span>{root2}</span>&gt; are equivalent in order&quot;</span>);\r\n</code></pre>\r\n<h2>\r\n\tLinguistic comparisons</h2>\r\n<p>\r\n\tStrings can also be ordered using linguistic rules for the current culture. This is sometimes referred to as &quot;word sort order.&quot; When you perform a linguistic comparison, some nonalphanumeric Unicode characters might have special weights assigned. For example, the hyphen &quot;-&quot; may have a very small weight assigned to it so that &quot;co-op&quot; and &quot;coop&quot; appear next to each other in sort order. In addition, some Unicode characters may be equivalent to a sequence of alphanumeric characters. The following example uses the phrase &quot;They dance in the street.&quot; in German with the &quot;ss&quot; and &#39;&szlig;&#39;. Linguistically (in Windows), &quot;ss&quot; is equal to the German Essetz: &#39;&szlig;&#39; character in both &quot;en-US&quot; and &quot;de-DE&quot; cultures.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> first = <span>&quot;Sie tanzen auf der Stra&szlig;e.&quot;</span>;\r\n<span>string</span> second = <span>&quot;Sie tanzen auf der Strasse.&quot;</span>;\r\n\r\nConsole.WriteLine(<span>$&quot;First sentence is &lt;<span>{first}</span>&gt;&quot;</span>);\r\nConsole.WriteLine(<span>$&quot;Second sentence is &lt;<span>{second}</span>&gt;&quot;</span>);\r\n\r\n<span>bool</span> equal = String.Equals(first, second, StringComparison.InvariantCulture);\r\nConsole.WriteLine(<span>$&quot;The two strings <span>{(equal == <span>true</span> ? <span>&quot;are&quot;</span> : <span>&quot;are not&quot;</span>)}</span> equal.&quot;</span>);\r\nshowComparison(first, second);\r\n\r\n<span>string</span> word = <span>&quot;coop&quot;</span>;\r\n<span>string</span> words = <span>&quot;co-op&quot;</span>;\r\n<span>string</span> other = <span>&quot;cop&quot;</span>;\r\n\r\nshowComparison(word, words);\r\nshowComparison(word, other);\r\nshowComparison(words, other);\r\n<span><span>void</span> <span>showComparison</span>(<span><span>string</span> one, <span>string</span> two</span>)\r\n</span>{\r\n    <span>int</span> compareLinguistic = String.Compare(one, two, StringComparison.InvariantCulture);\r\n    <span>int</span> compareOrdinal = String.Compare(one, two, StringComparison.Ordinal);\r\n    <span>if</span> (compareLinguistic &lt; <span>0</span>)\r\n        Console.WriteLine(<span>$&quot;&lt;<span>{one}</span>&gt; is less than &lt;<span>{two}</span>&gt; using invariant culture&quot;</span>);\r\n    <span>else</span> <span>if</span> (compareLinguistic &gt; <span>0</span>)\r\n        Console.WriteLine(<span>$&quot;&lt;<span>{one}</span>&gt; is greater than &lt;<span>{two}</span>&gt; using invariant culture&quot;</span>);\r\n    <span>else</span>\r\n        Console.WriteLine(<span>$&quot;&lt;<span>{one}</span>&gt; and &lt;<span>{two}</span>&gt; are equivalent in order using invariant culture&quot;</span>);\r\n    <span>if</span> (compareOrdinal &lt; <span>0</span>)\r\n        Console.WriteLine(<span>$&quot;&lt;<span>{one}</span>&gt; is less than &lt;<span>{two}</span>&gt; using ordinal comparison&quot;</span>);\r\n    <span>else</span> <span>if</span> (compareOrdinal &gt; <span>0</span>)\r\n        Console.WriteLine(<span>$&quot;&lt;<span>{one}</span>&gt; is greater than &lt;<span>{two}</span>&gt; using ordinal comparison&quot;</span>);\r\n    <span>else</span>\r\n        Console.WriteLine(<span>$&quot;&lt;<span>{one}</span>&gt; and &lt;<span>{two}</span>&gt; are equivalent in order using ordinal comparison&quot;</span>);\r\n}\r\n</code></pre>\r\n<p>\r\n\tThis sample demonstrates the operating system dependent nature of linguistic comparisons. The host for the interactive window is a Linux host. The linguistic and ordinal comparisons produce the same results. If you ran this same sample on a Windows host, you would see the following output:</p>\r\n<div>\r\n\t<span>console</span></div>\r\n<pre>\r\n<code>&lt;coop&gt; is less than &lt;co-op&gt; using invariant culture\r\n&lt;coop&gt; is greater than &lt;co-op&gt; using ordinal comparison\r\n&lt;coop&gt; is less than &lt;cop&gt; using invariant culture\r\n&lt;coop&gt; is less than &lt;cop&gt; using ordinal comparison\r\n&lt;co-op&gt; is less than &lt;cop&gt; using invariant culture\r\n&lt;co-op&gt; is less than &lt;cop&gt; using ordinal comparison\r\n</code></pre>\r\n<p>\r\n\tOn Windows, the sort order of &quot;cop&quot;, &quot;coop&quot;, and &quot;co-op&quot; change when you change from a linguistic comparison to an ordinal comparison. The two German sentences also compare differently using the different comparison types.</p>\r\n<h2>\r\n\tComparisons using specific cultures</h2>\r\n<p>\r\n\tThis sample stores&nbsp;CultureInfo&nbsp;for the current culture. The original culture can be set and retrieved on the current thread object. The comparisons are performed using the&nbsp;CurrentCulture&nbsp;value to ensure a culture-specific comparison.</p>\r\n<p>\r\n\tThe culture used affects linguistic comparisons. The following example shows the results of comparing the two German sentences using the &quot;en-US&quot; culture and the &quot;de-DE&quot; culture:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> first = <span>&quot;Sie tanzen auf der Stra&szlig;e.&quot;</span>;\r\n<span>string</span> second = <span>&quot;Sie tanzen auf der Strasse.&quot;</span>;\r\n\r\nConsole.WriteLine(<span>$&quot;First sentence is &lt;<span>{first}</span>&gt;&quot;</span>);\r\nConsole.WriteLine(<span>$&quot;Second sentence is &lt;<span>{second}</span>&gt;&quot;</span>);\r\n\r\n<span>var</span> en = <span>new</span> System.Globalization.CultureInfo(<span>&quot;en-US&quot;</span>);\r\n\r\n<span>// For culture-sensitive comparisons, use the String.Compare </span>\r\n<span>// overload that takes a StringComparison value.</span>\r\n<span>int</span> i = String.Compare(first, second, en, System.Globalization.CompareOptions.IgnoreNonSpace);\r\nConsole.WriteLine(<span>$&quot;Comparing in <span>{en.Name}</span> returns <span>{i}</span>.&quot;</span>);\r\n\r\n<span>var</span> de = <span>new</span> System.Globalization.CultureInfo(<span>&quot;de-DE&quot;</span>);\r\ni = String.Compare(first, second, de, System.Globalization.CompareOptions.IgnoreNonSpace);\r\nConsole.WriteLine(<span>$&quot;Comparing in <span>{de.Name}</span> returns <span>{i}</span>.&quot;</span>);\r\n\r\n<span>bool</span> b = String.Equals(first, second, StringComparison.CurrentCulture);\r\nConsole.WriteLine(<span>$&quot;The two strings <span>{(b == <span>true</span> ? <span>&quot;are&quot;</span> : <span>&quot;are not&quot;</span>)}</span> equal.&quot;</span>);\r\n\r\n<span>string</span> word = <span>&quot;coop&quot;</span>;\r\n<span>string</span> words = <span>&quot;co-op&quot;</span>;\r\n<span>string</span> other = <span>&quot;cop&quot;</span>;\r\n\r\nshowComparison(word, words, en);\r\nshowComparison(word, other, en);\r\nshowComparison(words, other, en);\r\n<span><span>void</span> <span>showComparison</span>(<span><span>string</span> one, <span>string</span> two, System.Globalization.CultureInfo culture</span>)\r\n</span>{\r\n    <span>int</span> compareLinguistic = String.Compare(one, two, en, System.Globalization.CompareOptions.IgnoreNonSpace);\r\n    <span>int</span> compareOrdinal = String.Compare(one, two, StringComparison.Ordinal);\r\n    <span>if</span> (compareLinguistic &lt; <span>0</span>)\r\n        Console.WriteLine(<span>$&quot;&lt;<span>{one}</span>&gt; is less than &lt;<span>{two}</span>&gt; using en-US culture&quot;</span>);\r\n    <span>else</span> <span>if</span> (compareLinguistic &gt; <span>0</span>)\r\n        Console.WriteLine(<span>$&quot;&lt;<span>{one}</span>&gt; is greater than &lt;<span>{two}</span>&gt; using en-US culture&quot;</span>);\r\n    <span>else</span>\r\n        Console.WriteLine(<span>$&quot;&lt;<span>{one}</span>&gt; and &lt;<span>{two}</span>&gt; are equivalent in order using en-US culture&quot;</span>);\r\n    <span>if</span> (compareOrdinal &lt; <span>0</span>)\r\n        Console.WriteLine(<span>$&quot;&lt;<span>{one}</span>&gt; is less than &lt;<span>{two}</span>&gt; using ordinal comparison&quot;</span>);\r\n    <span>else</span> <span>if</span> (compareOrdinal &gt; <span>0</span>)\r\n        Console.WriteLine(<span>$&quot;&lt;<span>{one}</span>&gt; is greater than &lt;<span>{two}</span>&gt; using ordinal comparison&quot;</span>);\r\n    <span>else</span>\r\n        Console.WriteLine(<span>$&quot;&lt;<span>{one}</span>&gt; and &lt;<span>{two}</span>&gt; are equivalent in order using ordinal comparison&quot;</span>);\r\n}\r\n</code></pre>\r\n<p>\r\n\tCulture-sensitive comparisons are typically used to compare and sort strings input by users with other strings input by users. The characters and sorting conventions of these strings might vary depending on the locale of the user&#39;s computer. Even strings that contain identical characters might sort differently depending on the culture of the current thread. In addition, try this sample code locally on a Windows machine, and you will the following results:</p>\r\n<div>\r\n\t<span>console</span></div>\r\n<pre>\r\n<code>&lt;coop&gt; is less than &lt;co-op&gt; using en-US culture\r\n&lt;coop&gt; is greater than &lt;co-op&gt; using ordinal comparison\r\n&lt;coop&gt; is less than &lt;cop&gt; using en-US culture\r\n&lt;coop&gt; is less than &lt;cop&gt; using ordinal comparison\r\n&lt;co-op&gt; is less than &lt;cop&gt; using en-US culture\r\n&lt;co-op&gt; is less than &lt;cop&gt; using ordinal comparison\r\n</code></pre>\r\n<p>\r\n\tLinguistic comparisons are dependent on the current culture, and are OS dependent. You must take that into account when you work with string comparisons.</p>\r\n<h2>\r\n\tLinguistic sorting and searching strings in arrays</h2>\r\n<p>\r\n\tThe following examples show how to sort and search for strings in an array using a linguistic comparison dependent on the current culture. You use the static&nbsp;Array&nbsp;methods that take a&nbsp;System.StringComparer&nbsp;parameter.</p>\r\n<p>\r\n\tThis example shows how to sort an array of strings using the current culture:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span>[] lines = <span>new</span> <span>string</span>[]\r\n{\r\n    <span>@&quot;c:\\public\\textfile.txt&quot;</span>,\r\n    <span>@&quot;c:\\public\\textFile.TXT&quot;</span>,\r\n    <span>@&quot;c:\\public\\Text.txt&quot;</span>,\r\n    <span>@&quot;c:\\public\\testfile2.txt&quot;</span>\r\n};\r\n\r\nConsole.WriteLine(<span>&quot;Non-sorted order:&quot;</span>);\r\n<span>foreach</span> (<span>string</span> s <span>in</span> lines)\r\n{\r\n    Console.WriteLine(<span>$&quot;   <span>{s}</span>&quot;</span>);\r\n}\r\n\r\nConsole.WriteLine(<span>&quot;\\n\\rSorted order:&quot;</span>);\r\n\r\n<span>// Specify Ordinal to demonstrate the different behavior.</span>\r\nArray.Sort(lines, StringComparer.CurrentCulture);\r\n\r\n<span>foreach</span> (<span>string</span> s <span>in</span> lines)\r\n{\r\n    Console.WriteLine(<span>$&quot;   <span>{s}</span>&quot;</span>);\r\n}\r\n</code></pre>\r\n<p>\r\n\tOnce the array is sorted, you can search for entries using a binary search. A binary search starts in the middle of the collection to determine which half of the collection would contain the sought string. Each subsequent comparison subdivides the remaining part of the collection in half. The array is sorted using&nbsp;StringComparer.CurrentCulture. The local function&nbsp;<code>ShowWhere</code>&nbsp;displays information about where the string was found. If the string was not found, the returned value indicates where it would be if it were found.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span>[] lines = <span>new</span> <span>string</span>[]\r\n{\r\n    <span>@&quot;c:\\public\\textfile.txt&quot;</span>,\r\n    <span>@&quot;c:\\public\\textFile.TXT&quot;</span>,\r\n    <span>@&quot;c:\\public\\Text.txt&quot;</span>,\r\n    <span>@&quot;c:\\public\\testfile2.txt&quot;</span>\r\n};\r\nArray.Sort(lines, StringComparer.CurrentCulture);\r\n\r\n<span>string</span> searchString = <span>@&quot;c:\\public\\TEXTFILE.TXT&quot;</span>;\r\nConsole.WriteLine(<span>$&quot;Binary search for &lt;<span>{searchString}</span>&gt;&quot;</span>);\r\n<span>int</span> result = Array.BinarySearch(lines, searchString, StringComparer.CurrentCulture);\r\nShowWhere&lt;<span>string</span>&gt;(lines, result);\r\n\r\nConsole.WriteLine(<span>$&quot;<span>{(result &gt; <span>0</span> ? <span>&quot;Found&quot;</span> : <span>&quot;Did not find&quot;</span>)}</span> <span>{searchString}</span>&quot;</span>);\r\n\r\n<span>void</span> ShowWhere&lt;T&gt;(T[] array, <span>int</span> index)\r\n{\r\n    <span>if</span> (index &lt; <span>0</span>)\r\n    {\r\n        index = ~index;\r\n\r\n        Console.Write(<span>&quot;Not found. Sorts between: &quot;</span>);\r\n\r\n        <span>if</span> (index == <span>0</span>)\r\n            Console.Write(<span>&quot;beginning of sequence and &quot;</span>);\r\n        <span>else</span>\r\n            Console.Write(<span>$&quot;<span>{array[index - <span>1</span>]}</span> and &quot;</span>);\r\n\r\n        <span>if</span> (index == array.Length)\r\n            Console.WriteLine(<span>&quot;end of sequence.&quot;</span>);\r\n        <span>else</span>\r\n            Console.WriteLine(<span>$&quot;<span>{array[index]}</span>.&quot;</span>);\r\n    }\r\n    <span>else</span>\r\n    {\r\n        Console.WriteLine(<span>$&quot;Found at index <span>{index}</span>.&quot;</span>);\r\n    }\r\n}\r\n</code></pre>\r\n<h2>\r\n\tOrdinal sorting and searching in collections</h2>\r\n<p>\r\n\tThe following code uses the&nbsp;System.Collections.Generic.List&lt;T&gt;&nbsp;collection class to store strings. The strings are sorted using the&nbsp;List&lt;T&gt;.Sort&nbsp;method. This method needs a delegate that compares and orders two strings. The&nbsp;String.CompareTo&nbsp;method provides that comparison function. Run the sample and observe the order. This sort operation uses an ordinal case sensitive sort. You would use the static&nbsp;String.Compare&nbsp;methods to specify different comparison rules.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>List&lt;<span>string</span>&gt; lines = <span>new</span> List&lt;<span>string</span>&gt;\r\n{\r\n    <span>@&quot;c:\\public\\textfile.txt&quot;</span>,\r\n    <span>@&quot;c:\\public\\textFile.TXT&quot;</span>,\r\n    <span>@&quot;c:\\public\\Text.txt&quot;</span>,\r\n    <span>@&quot;c:\\public\\testfile2.txt&quot;</span>\r\n};\r\n\r\nConsole.WriteLine(<span>&quot;Non-sorted order:&quot;</span>);\r\n<span>foreach</span> (<span>string</span> s <span>in</span> lines)\r\n{\r\n    Console.WriteLine(<span>$&quot;   <span>{s}</span>&quot;</span>);\r\n}\r\n\r\nConsole.WriteLine(<span>&quot;\\n\\rSorted order:&quot;</span>);\r\n\r\nlines.Sort((left, right) =&gt; left.CompareTo(right)); \r\n<span>foreach</span> (<span>string</span> s <span>in</span> lines)\r\n{\r\n    Console.WriteLine(<span>$&quot;   <span>{s}</span>&quot;</span>);\r\n}\r\n</code></pre>\r\n<p>\r\n\tOnce sorted, the list of strings can be searched using a binary search. The following sample shows how to search the sorted listed using the same comparison function. The local function&nbsp;<code>ShowWhere</code>shows where the sought text is or would be:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>List&lt;<span>string</span>&gt; lines = <span>new</span> List&lt;<span>string</span>&gt;\r\n{\r\n    <span>@&quot;c:\\public\\textfile.txt&quot;</span>,\r\n    <span>@&quot;c:\\public\\textFile.TXT&quot;</span>,\r\n    <span>@&quot;c:\\public\\Text.txt&quot;</span>,\r\n    <span>@&quot;c:\\public\\testfile2.txt&quot;</span>\r\n};\r\nlines.Sort((left, right) =&gt; left.CompareTo(right));\r\n\r\n<span>string</span> searchString = <span>@&quot;c:\\public\\TEXTFILE.TXT&quot;</span>;\r\nConsole.WriteLine(<span>$&quot;Binary search for &lt;<span>{searchString}</span>&gt;&quot;</span>);\r\n<span>int</span> result = lines.BinarySearch(searchString);\r\nShowWhere&lt;<span>string</span>&gt;(lines, result);\r\n\r\nConsole.WriteLine(<span>$&quot;<span>{(result &gt; <span>0</span> ? <span>&quot;Found&quot;</span> : <span>&quot;Did not find&quot;</span>)}</span> <span>{searchString}</span>&quot;</span>);\r\n\r\n<span>void</span> ShowWhere&lt;T&gt;(IList&lt;T&gt; collection, <span>int</span> index)\r\n{\r\n    <span>if</span> (index &lt; <span>0</span>)\r\n    {\r\n        index = ~index;\r\n\r\n        Console.Write(<span>&quot;Not found. Sorts between: &quot;</span>);\r\n\r\n        <span>if</span> (index == <span>0</span>)\r\n            Console.Write(<span>&quot;beginning of sequence and &quot;</span>);\r\n        <span>else</span>\r\n            Console.Write(<span>$&quot;<span>{collection[index - <span>1</span>]}</span> and &quot;</span>);\r\n\r\n        <span>if</span> (index == collection.Count)\r\n            Console.WriteLine(<span>&quot;end of sequence.&quot;</span>);\r\n        <span>else</span>\r\n            Console.WriteLine(<span>$&quot;<span>{collection[index]}</span>.&quot;</span>);\r\n    }\r\n    <span>else</span>\r\n    {\r\n        Console.WriteLine(<span>$&quot;Found at index <span>{index}</span>.&quot;</span>);\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tAlways make sure to use the same type of comparison for sorting and searching. Using different comparison types for sorting and searching produces unexpected results.</p>\r\n<p>\r\n\tCollection classes such as&nbsp;System.Collections.Hashtable,&nbsp;System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;, and&nbsp;System.Collections.Generic.List&lt;T&gt;&nbsp;have constructors that take a&nbsp;System.StringComparer&nbsp;parameter when the type of the elements or keys is&nbsp;<code>string</code>. In general, you should use these constructors whenever possible, and specify either&nbsp;StringComparer.Ordinal&nbsp;or&nbsp;StringComparer.OrdinalIgnoreCase.</p>\r\n<h2>\r\n\tReference equality and string interning</h2>\r\n<p>\r\n\tNone of the samples have used&nbsp;ReferenceEquals. This method determines if two strings are the same object. This can lead to inconsistent results in string comparisons. The following example demonstrates the&nbsp;<em>string interning</em>&nbsp;feature of C#. When a program declares two or more identical string variables, the compiler stores them all in the same location. By calling the&nbsp;ReferenceEquals&nbsp;method, you can see that the two strings actually refer to the same object in memory. Use the&nbsp;String.Copymethod to avoid interning. After the copy has been made, the two strings have different storage locations, even though they have the same value. Run the following sample to show that strings&nbsp;<code>a</code>and&nbsp;<code>b</code>&nbsp;are&nbsp;<em>interned</em>&nbsp;meaning they share the same storage. The strings&nbsp;<code>a</code>&nbsp;and&nbsp;<code>c</code>&nbsp;are not.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> a = <span>&quot;The computer ate my source code.&quot;</span>;\r\n<span>string</span> b = <span>&quot;The computer ate my source code.&quot;</span>;\r\n\r\n<span>if</span> (String.ReferenceEquals(a, b))\r\n    Console.WriteLine(<span>&quot;a and b are interned.&quot;</span>);\r\n<span>else</span>\r\n    Console.WriteLine(<span>&quot;a and b are not interned.&quot;</span>);\r\n\r\n<span>string</span> c = String.Copy(a);\r\n\r\n<span>if</span> (String.ReferenceEquals(a, c))\r\n    Console.WriteLine(<span>&quot;a and c are interned.&quot;</span>);\r\n<span>else</span>\r\n    Console.WriteLine(<span>&quot;a and c are not interned.&quot;</span>);\r\n</code></pre>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tWhen you test for equality of strings, you should use the methods that explicitly specify what kind of comparison you intend to perform. Your code is much more maintainable and readable. Use the overloads of the methods of the&nbsp;System.String&nbsp;and&nbsp;System.Array&nbsp;classes that take a&nbsp;StringComparison&nbsp;enumeration parameter. You specify which type of comparison to perform. Avoid using the&nbsp;<code>==</code>&nbsp;and&nbsp;<code>!=</code>&nbsp;operators when you test for equality. The&nbsp;String.CompareToinstance methods always perform an ordinal case-sensitive comparison. They are primarily suited for ordering strings alphabetically.</p>\r\n</div>"
          },
          {
            "Safely cast by using pattern matching is and as operators": "<p>\r\n\tBecause objects are polymorphic, it&#39;s possible for a variable of a base class type to hold a derived&nbsp;type. To access the derived type&#39;s instance members,<span>&nbsp;it&#39;s necessary to&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions\" target=\"_blank\">cast</a><span>&nbsp;the value back to the derived type. However, a cast creates the risk of throwing an&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/api/system.invalidcastexception\" target=\"_blank\">InvalidCastException</a><span>. C# provides&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/pattern-matching\" target=\"_blank\">pattern matching</a><span>&nbsp;statements that perform a cast conditionally only when it will succeed. C# also provides the&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/is\" target=\"_blank\">is</a><span>&nbsp;and&nbsp;</span><a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/as\" target=\"_blank\">as</a><span>&nbsp;operators to test if a value is of a certain type.</span>&nbsp;Note:</p>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;</p>\r\n\t<p>\r\n\t\tThe C# examples in this article run in the&nbsp;Try.NET&nbsp;inline code runner and playground. Select the&nbsp;<span>Run</span>&nbsp;button to run an example in an interactive window. Once you execute the code, you can modify it and run the modified code by selecting&nbsp;<span>Run</span>&nbsp;again. The modified code either runs in the interactive window or, if compilation fails, the interactive window displays all C# compiler error messages.</p>\r\n</div>\r\n<p>\r\n\tThe following code demonstrates the pattern matching&nbsp;<code>is</code>&nbsp;statement. It contains methods that test a method argument to determine if it is one of a possible set of derived types:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>Animal</span>\r\n{\r\n    <span><span>public</span> <span>void</span> <span>Eat</span>() </span>{ Console.WriteLine(<span>&quot;Eating.&quot;</span>); }\r\n    <span><span>public</span> <span>override</span> <span>string</span> <span>ToString</span>()\r\n    </span>{\r\n        <span>return</span> <span>&quot;I am an animal.&quot;</span>;\r\n    }\r\n}\r\n<span>class</span> <span>Mammal</span> : <span>Animal</span> { }\r\n<span>class</span> <span>Giraffe</span> : <span>Mammal</span> { }\r\n\r\n<span>class</span> <span>SuperNova</span> { }\r\n\r\n<span>class</span> <span>Program</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)\r\n    </span>{\r\n        Giraffe g = <span>new</span> Giraffe();\r\n        FeedMammals(g);\r\n\r\n        TestForMammals(g);\r\n\r\n        <span>// Use the as operator to test</span>\r\n        <span>// an incompatible type.</span>\r\n        SuperNova sn = <span>new</span> SuperNova();\r\n        TestForMammals(sn);\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>FeedMammals</span>(<span>Animal a</span>)\r\n    </span>{\r\n        <span>// Use the is operator to verify the type.</span>\r\n        <span>// before performing a cast.</span>\r\n        <span>if</span> (a <span>is</span> Mammal m)\r\n        {\r\n            m.Eat();\r\n        }\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>TestForMammals</span>(<span><span>object</span> o</span>)\r\n    </span>{\r\n        <span>// Use the as operator and test for null</span>\r\n        <span>// before referencing the variable.</span>\r\n        <span>if</span> (o <span>is</span> Mammal m)\r\n        {\r\n            Console.WriteLine(m.ToString());\r\n        }\r\n        <span>else</span>\r\n        {\r\n            <span>// variable &#39;m&#39; is not in scope here, and can&#39;t be used.</span>\r\n            Console.WriteLine(<span>$&quot;<span>{o.GetType().Name}</span> is not a Mammal&quot;</span>);\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tThe preceding sample demonstrates a few features of pattern matching syntax. The&nbsp;<code>if (a is Mammal m)</code>&nbsp;and&nbsp;<code>if (o is Mammal m)</code>&nbsp;statements combine the test with an initialization assignment. TThe assignment occurs only when the test succeeds. The variable&nbsp;<code>m</code>&nbsp;is only in scope in the embedded&nbsp;<code>if</code>&nbsp;statement where it has been assigned. You cannot access&nbsp;<code>m</code>&nbsp;later in the same method. Try it in the interactive window.</p>\r\n<p>\r\n\tYou can also use the same syntax for testing if a&nbsp;nullable type&nbsp;has a value, as shown in the following sample code:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>Program</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)\r\n    </span>{\r\n        <span>// Use the as operator with a value type.</span>\r\n        <span>// Note the implicit conversion to int? in </span>\r\n        <span>// the method body.</span>\r\n        <span>int</span> i = <span>5</span>;\r\n        PatternMatchingNullable(i);\r\n\r\n        <span>int</span>? j = <span>null</span>;\r\n        PatternMatchingNullable(j);\r\n\r\n        <span>double</span> d = <span>9.78654</span>;\r\n        PatternMatchingNullable(d);\r\n\r\n        PatternMatchingSwitch(i);\r\n        PatternMatchingSwitch(j);\r\n        PatternMatchingSwitch(d);\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>PatternMatchingNullable</span>(<span>System.ValueType val</span>)\r\n    </span>{\r\n        <span>if</span> (val <span>is</span> <span>int</span> j) <span>// Nullable types are not allowed in patterns</span>\r\n        {\r\n            Console.WriteLine(j);\r\n        }\r\n        <span>else</span> <span>if</span> (val <span>is</span> <span>null</span>) <span>// If val is a nullable type with no value, this expression is true</span>\r\n        {\r\n            Console.WriteLine(<span>&quot;val is a nullable type with the null value&quot;</span>);\r\n        }\r\n        <span>else</span>\r\n        {\r\n            Console.WriteLine(<span>&quot;Could not convert &quot;</span> + val.ToString());\r\n        }\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>PatternMatchingSwitch</span>(<span>System.ValueType val</span>)\r\n    </span>{\r\n        <span>switch</span> (val)\r\n        {\r\n            <span>case</span> <span>int</span> number:\r\n                Console.WriteLine(number);\r\n                <span>break</span>;\r\n            <span>case</span> <span>long</span> number:\r\n                Console.WriteLine(number);\r\n                <span>break</span>;\r\n            <span>case</span> <span>decimal</span> number:\r\n                Console.WriteLine(number);\r\n                <span>break</span>;\r\n            <span>case</span> <span>float</span> number:\r\n                Console.WriteLine(number);\r\n                <span>break</span>;\r\n            <span>case</span> <span>double</span> number:\r\n                Console.WriteLine(number);\r\n                <span>break</span>;\r\n            <span>case</span> <span>null</span>:\r\n                Console.WriteLine(<span>&quot;val is a nullable type with the null value&quot;</span>);\r\n                <span>break</span>;\r\n            <span>default</span>:\r\n                Console.WriteLine(<span>&quot;Could not convert &quot;</span> + val.ToString());\r\n                <span>break</span>;\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tThe preceding sample demonstrates other features of pattern matching to use with conversions. You can test a variable for the null pattern by checking specifically for the&nbsp;<code>null</code>&nbsp;value. When the runtime value of the variable is&nbsp;<code>null</code>, an&nbsp;<code>is</code>&nbsp;statement checking for a type always returns&nbsp;<code>false</code>. The pattern matching&nbsp;<code>is</code>&nbsp;statement doesn&#39;t allow a nullable value type, such as&nbsp;<code>int?</code>&nbsp;or&nbsp;<code>Nullable&lt;int&gt;</code>, but you can test for any other value type.</p>\r\n<p>\r\n\tThe preceding sample also shows how you use the pattern matching&nbsp;<code>is</code>&nbsp;expression in a&nbsp;<code>switch</code>statement where the variable may be one of many different types.</p>\r\n<p>\r\n\tIf you want to test if a variable is a given type, but not assign it to a new variable, you can use the&nbsp;<code>is</code>and&nbsp;<code>as</code>&nbsp;operators for reference types and nullable types. The following code shows how to use the&nbsp;<code>is</code>&nbsp;and&nbsp;<code>as</code>&nbsp;statements that were part of the C# language before pattern matching was introduced to test if a variable is of a given type:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>Animal</span>\r\n{\r\n    <span><span>public</span> <span>void</span> <span>Eat</span>() </span>{ Console.WriteLine(<span>&quot;Eating.&quot;</span>); }\r\n    <span><span>public</span> <span>override</span> <span>string</span> <span>ToString</span>()\r\n    </span>{\r\n        <span>return</span> <span>&quot;I am an animal.&quot;</span>;\r\n    }\r\n}\r\n<span>class</span> <span>Mammal</span> : <span>Animal</span> { }\r\n<span>class</span> <span>Giraffe</span> : <span>Mammal</span> { }\r\n\r\n<span>class</span> <span>SuperNova</span> { }\r\n\r\n\r\n<span>class</span> <span>Program</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)\r\n    </span>{\r\n        <span>// Use the is operator to verify the type.</span>\r\n        <span>// before performing a cast.</span>\r\n        Giraffe g = <span>new</span> Giraffe();\r\n        UseIsOperator(g);\r\n\r\n        <span>// Use the as operator and test for null</span>\r\n        <span>// before referencing the variable.</span>\r\n        UseAsOperator(g);\r\n\r\n        <span>// Use the as operator to test</span>\r\n        <span>// an incompatible type.</span>\r\n        SuperNova sn = <span>new</span> SuperNova();\r\n        UseAsOperator(sn);\r\n\r\n        <span>// Use the as operator with a value type.</span>\r\n        <span>// Note the implicit conversion to int? in </span>\r\n        <span>// the method body.</span>\r\n        <span>int</span> i = <span>5</span>;\r\n        UseAsWithNullable(i);\r\n\r\n        <span>double</span> d = <span>9.78654</span>;\r\n        UseAsWithNullable(d);\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>UseIsOperator</span>(<span>Animal a</span>)\r\n    </span>{\r\n        <span>if</span> (a <span>is</span> Mammal)\r\n        {\r\n            Mammal m = (Mammal)a;\r\n            m.Eat();\r\n        }\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>UsePatternMatchingIs</span>(<span>Animal a</span>)\r\n    </span>{\r\n        <span>if</span> (a <span>is</span> Mammal m)\r\n        {\r\n            m.Eat();\r\n        }\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>UseAsOperator</span>(<span><span>object</span> o</span>)\r\n    </span>{\r\n        Mammal m = o <span>as</span> Mammal;\r\n        <span>if</span> (m != <span>null</span>)\r\n        {\r\n            Console.WriteLine(m.ToString());\r\n        }\r\n        <span>else</span>\r\n        {\r\n            Console.WriteLine(<span>$&quot;<span>{o.GetType().Name}</span> is not a Mammal&quot;</span>);\r\n        }\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>UseAsWithNullable</span>(<span>System.ValueType val</span>)\r\n    </span>{\r\n        <span>int</span>? j = val <span>as</span> <span>int</span>?;\r\n        <span>if</span> (j != <span>null</span>)\r\n        {\r\n            Console.WriteLine(j);\r\n        }\r\n        <span>else</span>\r\n        {\r\n            Console.WriteLine(<span>&quot;Could not convert &quot;</span> + val.ToString());\r\n        }\r\n    }\r\n}\r\n\r\n\r\n</code></pre>\r\n<p>\r\n\tAs you can see by comparing this code with the pattern matching code, the pattern matching syntax provides more robust features by combining the test and the assignment in a single statement. Use the pattern matching syntax whenever possible.</p>\r\n<p>\r\n\t<span>You can try these samples by looking at the code in our&nbsp;</span><a href=\"https://github.com/dotnet/samples/tree/master/snippets/csharp/how-to/safelycast\" target=\"_blank\">GitHub repository</a><span>. Or you can download the samples&nbsp;</span><a href=\"https://github.com/dotnet/samples/raw/master/snippets/csharp/how-to/safelycast.zip\" target=\"_blank\">as a zip file</a><span>.</span></p>"
          },
          {
            "Select the C# language version": "<p>\r\n\tThe C# compiler defaults to the latest major version of the language that has been released. You may choose to compile any project using a new point release of the language. Choosing a newer version of the language enables your project to make use of the latest language features. In other scenarios, you may need to validate that a project compiles cleanly when using an older version of the language.</p>\r\n<p>\r\n\tThis capability decouples the decision to install new versions of the SDK and tools in your development environment from the decision to incorporate new language features in a project. You can install the latest SDK and tools on your build machine. Each project can be configured to use a specific version of the language for its build.</p>\r\n<p>\r\n\tThere are several ways to set the language version:</p>\r\n<ul>\r\n\t<li>\r\n\t\tRely on a&nbsp;Visual Studio quick action.</li>\r\n\t<li>\r\n\t\tSet the language version in the&nbsp;Visual Studio UI.</li>\r\n\t<li>\r\n\t\tManually edit your&nbsp;<span>.csproj</span>&nbsp;file.</li>\r\n\t<li>\r\n\t\tSet the language version&nbsp;for multiple projects in a subdirectory.</li>\r\n\t<li>\r\n\t\tConfigure the&nbsp;<code>-langversion</code>&nbsp;compiler option.</li>\r\n</ul>\r\n<h2>\r\n\tVisual Studio quick action</h2>\r\n<p>\r\n\tVisual Studio helps you determine the language version you need. If you use a language feature that is not available for the currently configured version, Visual Studio shows a potential fix to update the language version for the project.</p>\r\n<h2>\r\n\tSet the language version in Visual Studio</h2>\r\n<p>\r\n\tYou can set the version in Visual Studio. Right-click on the project node in Solution Explorer and select&nbsp;<span>Properties</span>. Select the&nbsp;<span>Build</span>&nbsp;tab and select the&nbsp;<span>Advanced</span>&nbsp;button. In the dropdown, select the version. The following image shows the &quot;latest&quot; setting:</p>\r\n<p>\r\n\t<img alt=\"Screenshot of advanced build settings where you can specify the language version\" data-linktype=\"relative-path\" src=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/media/configure-language-version/advanced-build-settings.png\" style=\"border: 0px; box-sizing: inherit; max-width: 100%; height: auto; display: inline-block;\" /></p>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tIf you use the Visual Studio IDE to update your csproj files, the IDE creates separate nodes for each build configuration. You&#39;ll typically set the value the same in all build configurations, but you need to set it explicitly for each build configuration, or select &quot;All Configurations&quot; when you modify this setting. You&#39;ll see the following in your csproj file:</p>\r\n\t<div>\r\n\t\t<span>XML</span></div>\r\n\t<pre>\r\n\t<code><span>&lt;<span>PropertyGroup</span> <span>Condition</span>=<span>&quot;&#39;$(Configuration)|$(Platform)&#39;==&#39;Release|AnyCPU&#39;&quot;</span>&gt;</span>\r\n <span>&lt;<span>LangVersion</span>&gt;</span>latest<span>&lt;/<span>LangVersion</span>&gt;</span>\r\n<span>&lt;/<span>PropertyGroup</span>&gt;</span>\r\n\r\n<span>&lt;<span>PropertyGroup</span> <span>Condition</span>=<span>&quot;&#39;$(Configuration)|$(Platform)&#39;==&#39;Debug|AnyCPU&#39;&quot;</span>&gt;</span>\r\n <span>&lt;<span>LangVersion</span>&gt;</span>latest<span>&lt;/<span>LangVersion</span>&gt;</span>\r\n<span>&lt;/<span>PropertyGroup</span>&gt;</span>\r\n</code></pre>\r\n</div>\r\n<h2>\r\n\tEdit the csproj file</h2>\r\n<p>\r\n\tYou can set the language version in your&nbsp;<span>.csproj</span>&nbsp;file. Add an element like the following:</p>\r\n<div>\r\n\t<span>XML</span></div>\r\n<pre>\r\n<code><span>&lt;<span>PropertyGroup</span>&gt;</span>\r\n   <span>&lt;<span>LangVersion</span>&gt;</span>latest<span>&lt;/<span>LangVersion</span>&gt;</span>\r\n<span>&lt;/<span>PropertyGroup</span>&gt;</span>\r\n</code></pre>\r\n<p>\r\n\tThe value&nbsp;<code>latest</code>&nbsp;uses the latest minor version of the C# language. Valid values are:</p>\r\n<div>\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tValue&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tMeaning</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tdefault</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe compiler accepts all valid language syntax from the latest major version that it can support.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tISO-1</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe compiler accepts only syntax that is included in ISO/IEC 23270:2003 C# (1.0/1.2)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tISO-2</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe compiler accepts only syntax that is included in ISO/IEC 23270:2006 C# (2.0)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t3</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe compiler accepts only syntax that is included in C# 3.0 or lower.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t4</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe compiler accepts only syntax that is included in C# 4.0 or lower.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t5</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe compiler accepts only syntax that is included in C# 5.0 or lower.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t6</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe compiler accepts only syntax that is included in C# 6.0 or lower.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t7</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe compiler accepts only syntax that is included in C# 7.0 or lower.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t7.1</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe compiler accepts only syntax that is included in C# 7.1 or lower.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t7.2</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe compiler accepts only syntax that is included in C# 7.2 or lower.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t7.3</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe compiler accepts only syntax that is included in C# 7.3 or lower.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tlatest</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe compiler accepts all valid language syntax that it can support.</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<p>\r\n\tThe special strings&nbsp;<code>default</code>&nbsp;and&nbsp;<code>latest</code>&nbsp;resolve to the latest major (C# 7.0) and minor (C# 7.3) language versions installed on the build machine, respectively.</p>\r\n<h2>\r\n\tConfigure multiple projects</h2>\r\n<p>\r\n\tYou can create a&nbsp;<span>Directory.build.props</span>&nbsp;file that contains the&nbsp;<code>&lt;LangVersion&gt;</code>&nbsp;element to configure multiple directories. You typically do that in your solution directory. Add the following to a&nbsp;<span>Directory.build.props</span>&nbsp;file in your solution directory:</p>\r\n<div>\r\n\t<span>XML</span></div>\r\n<pre>\r\n<code><span>&lt;<span>Project</span>&gt;</span>\r\n <span>&lt;<span>PropertyGroup</span>&gt;</span>\r\n   <span>&lt;<span>LangVersion</span>&gt;</span>7.3<span>&lt;/<span>LangVersion</span>&gt;</span>\r\n <span>&lt;/<span>PropertyGroup</span>&gt;</span>\r\n<span>&lt;/<span>Project</span>&gt;</span>\r\n</code></pre>\r\n<p>\r\n\tNow, builds in every subdirectory of the directory containing that file will use C# version 7.3 syntax. For more information, see the article on&nbsp;Customize your build.</p>\r\n<h2>\r\n\tSet the langversion compiler option</h2>\r\n<p>\r\n\tYou can use the&nbsp;<code>-langversion</code>&nbsp;command-line option. For more information, see the article on the&nbsp;-langversion&nbsp;compiler option. You can see a list of the valid values by typing&nbsp;<code>csc -langversion:?</code>.</p>"
          },
          {
            "C# Keywords": "<p>\r\n\tKeywords are predefined, reserved identifiers that have special meanings to the compiler. They cannot be used as identifiers in your program unless they include&nbsp;<code>@</code>&nbsp;as a prefix. For example,&nbsp;<code>@if</code>&nbsp;is a valid identifier, but&nbsp;<code>if</code>&nbsp;is not because&nbsp;<code>if</code>&nbsp;is a keyword.</p>\r\n<p>\r\n\tThe first table in this topic lists keywords that are reserved identifiers in any part of a C# program. The second table in this topic lists the contextual keywords in C#. Contextual keywords have special meaning only in a limited program context and can be used as identifiers outside that context. Generally, as new keywords are added to the C# language, they are added as contextual keywords in order to avoid breaking programs written in earlier versions.</p>\r\n<div>\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\t&nbsp;</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\t&nbsp;</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tabstract</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tas</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tbase</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tbool</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tbreak</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tbyte</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tcase</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tcatch</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tchar</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tchecked</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tclass</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tconst</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tcontinue</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tdecimal</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tdefault</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tdelegate</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tdo</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tdouble</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\telse</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tenum</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tevent</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\texplicit</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\textern</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tfalse</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tfinally</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tfixed</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tfloat</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tfor</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tforeach</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tgoto</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tif</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\timplicit</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tin</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tint</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tinterface</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tinternal</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tis</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tlock</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tlong</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tnamespace</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tnew</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tnull</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tobject</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\toperator</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tout</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\toverride</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tparams</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tprivate</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tprotected</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tpublic</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\treadonly</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tref</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\treturn</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tsbyte</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tsealed</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tshort</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tsizeof</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tstackalloc</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tstatic</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tstring</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tstruct</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tswitch</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tthis</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tthrow</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\ttrue</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\ttry</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\ttypeof</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tuint</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tulong</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tunchecked</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tunsafe</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tushort</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tusing</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tusing static</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tvirtual</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tvoid</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tvolatile</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\twhile</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<h2>\r\n\tContextual Keywords</h2>\r\n<p>\r\n\tA contextual keyword is used to provide a specific meaning in the code, but it is not a reserved word in C#. Some contextual keywords, such as&nbsp;<code>partial</code>&nbsp;and&nbsp;<code>where</code>, have special meanings in two or more contexts.</p>\r\n<div>\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\t&nbsp;</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tadd</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\talias</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tascending</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tasync</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tawait</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tby</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tdescending</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tdynamic</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tequals</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tfrom</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tget</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tglobal</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tgroup</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tinto</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tjoin</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tlet</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tnameof</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\ton</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\torderby</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tpartial (type)</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tpartial (method)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tremove</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tselect</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tset</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tvalue</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tvar</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\twhen (filter condition)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\twhere (generic type constraint)</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\twhere (query clause)</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tyield</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>"
          },
          {
            "Class": "<p>\r\n\tClasses are declared using the keyword&nbsp;<code>class</code>, as shown in the following example:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>TestClass</span>\r\n{\r\n    <span>// Methods, properties, fields, events, delegates</span>\r\n    <span>// and nested classes go here.</span>\r\n}\r\n</code></pre>\r\n<h2>\r\n\tRemarks</h2>\r\n<p>\r\n\tOnly single inheritance is allowed in C#. In other words, a class can inherit implementation from one base class only. However, a class can implement more than one interface. The following table shows examples of class inheritance and interface implementation:</p>\r\n<div>\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tInheritance</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tExample</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tNone</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>class ClassA { }</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tSingle</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>class DerivedClass: BaseClass { }</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tNone, implements two interfaces</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>class ImplClass: IFace1, IFace2 { }</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tSingle, implements one interface</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>class ImplDerivedClass: BaseClass, IFace1 { }</code></td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<p>\r\n\tClasses that you declare directly within a namespace, not nested within other classes, can be either&nbsp;public&nbsp;or&nbsp;internal. Classes are&nbsp;<code>internal</code>&nbsp;by default.</p>\r\n<p>\r\n\tClass members, including nested classes, can be&nbsp;public,&nbsp;protected internal,&nbsp;protected,&nbsp;internal,&nbsp;private, or&nbsp;private protected. Members are&nbsp;<code>private</code>&nbsp;by default.</p>\r\n<p>\r\n\tFor more information, see&nbsp;Access Modifiers.</p>\r\n<p>\r\n\tYou can declare generic classes that have type parameters. For more information, see&nbsp;Generic Classes.</p>\r\n<p>\r\n\tA class can contain declarations of the following members:</p>\r\n<ul>\r\n\t<li>\r\n\t\tConstructors</li>\r\n\t<li>\r\n\t\tConstants</li>\r\n\t<li>\r\n\t\tFields</li>\r\n\t<li>\r\n\t\tFinalizers</li>\r\n\t<li>\r\n\t\tMethods</li>\r\n\t<li>\r\n\t\tProperties</li>\r\n\t<li>\r\n\t\tIndexers</li>\r\n\t<li>\r\n\t\tOperators</li>\r\n\t<li>\r\n\t\tEvents</li>\r\n\t<li>\r\n\t\tDelegates</li>\r\n\t<li>\r\n\t\tClasses</li>\r\n\t<li>\r\n\t\tInterfaces</li>\r\n\t<li>\r\n\t\tStructs</li>\r\n\t<li>\r\n\t\tEnumerations</li>\r\n</ul>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example demonstrates declaring class fields, constructors, and methods. It also demonstrates object instantiation and printing instance data. In this example, two classes are declared. The first class,&nbsp;<code>Child</code>, contains two private fields (<code>name</code>&nbsp;and&nbsp;<code>age</code>), two public constructors and one public method. The second class,&nbsp;<code>StringTest</code>, is used to contain&nbsp;<code>Main</code>.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>Child</span>\r\n{\r\n    <span>private</span> <span>int</span> age;\r\n    <span>private</span> <span>string</span> name;\r\n\r\n    <span>// Default constructor:</span>\r\n    <span><span>public</span> <span>Child</span>()\r\n    </span>{\r\n        name = <span>&quot;N/A&quot;</span>;\r\n    }\r\n\r\n    <span>// Constructor:</span>\r\n    <span><span>public</span> <span>Child</span>(<span><span>string</span> name, <span>int</span> age</span>)\r\n    </span>{\r\n        <span>this</span>.name = name;\r\n        <span>this</span>.age = age;\r\n    }\r\n\r\n    <span>// Printing method:</span>\r\n    <span><span>public</span> <span>void</span> <span>PrintChild</span>()\r\n    </span>{\r\n        Console.WriteLine(<span>&quot;{0}, {1} years old.&quot;</span>, name, age);\r\n    }\r\n}\r\n\r\n<span>class</span> <span>StringTest</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>// Create objects by using the new operator:</span>\r\n        Child child1 = <span>new</span> Child(<span>&quot;Craig&quot;</span>, <span>11</span>);\r\n        Child child2 = <span>new</span> Child(<span>&quot;Sally&quot;</span>, <span>10</span>);\r\n\r\n        <span>// Create an object using the default constructor:</span>\r\n        Child child3 = <span>new</span> Child();\r\n\r\n        <span>// Display results:</span>\r\n        Console.Write(<span>&quot;Child #1: &quot;</span>);\r\n        child1.PrintChild();\r\n        Console.Write(<span>&quot;Child #2: &quot;</span>);\r\n        child2.PrintChild();\r\n        Console.Write(<span>&quot;Child #3: &quot;</span>);\r\n        child3.PrintChild();\r\n    }\r\n}\r\n<span>/* Output:\r\n    Child #1: Craig, 11 years old.\r\n    Child #2: Sally, 10 years old.\r\n    Child #3: N/A, 0 years old.\r\n*/</span>\r\n</code></pre>\r\n<h2>\r\n\tComments</h2>\r\n<p>\r\n\tNotice that in the previous example the private fields (<code>name</code>&nbsp;and&nbsp;<code>age</code>) can only be accessed through the public method of the&nbsp;<code>Child</code>&nbsp;class. For example, you cannot print the child&#39;s name, from the&nbsp;<code>Main</code>method, using a statement like this:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>Console.Write(child1.name);   <span>// Error</span>\r\n</code></pre>\r\n<p>\r\n\tAccessing private members of&nbsp;<code>Child</code>&nbsp;from&nbsp;<code>Main</code>&nbsp;would only be possible if&nbsp;<code>Main</code>&nbsp;were a member of the class.</p>\r\n<p>\r\n\tTypes declared inside a class without an access modifier default to&nbsp;<code>private</code>, so the data members in this example would still be&nbsp;<code>private</code>&nbsp;if the keyword were removed.</p>\r\n<p>\r\n\tFinally, notice that for the object created using the default constructor (<code>child3</code>), the age field was initialized to zero by default.</p>"
          },
          {
            "Delegate": "<p>\r\n\tThe declaration of a delegate type is similar to a method signature. It has a return value and any number of parameters of any type:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>public</span> <span>delegate</span> <span>void</span> <span>TestDelegate</span>(<span><span>string</span> message</span>)</span>;\r\n<span><span>public</span> <span>delegate</span> <span>int</span> <span>TestDelegate</span>(<span>MyType m, <span>long</span> num</span>)</span>;\r\n</code></pre>\r\n<p>\r\n\tA&nbsp;<code>delegate</code>&nbsp;is a reference type that can be used to encapsulate a named or an anonymous method. Delegates are similar to function pointers in C++; however, delegates are type-safe and secure. For applications of delegates, see&nbsp;Delegates&nbsp;and&nbsp;Generic Delegates.</p>\r\n<h2>\r\n\tRemarks</h2>\r\n<p>\r\n\tDelegates are the basis for&nbsp;Events.</p>\r\n<p>\r\n\tA delegate can be instantiated by associating it either with a named or anonymous method. For more information, see&nbsp;Named Methods&nbsp;and&nbsp;Anonymous Methods.</p>\r\n<p>\r\n\tThe delegate must be instantiated with a method or lambda expression that has a compatible return type and input parameters. For more information on the degree of variance that is allowed in the method signature, see&nbsp;Variance in Delegates. For use with anonymous methods, the delegate and the code to be associated with it are declared together. Both ways of instantiating delegates are discussed in this section.</p>\r\n<h2>\r\n\tExample</h2>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Declare delegate -- defines required signature:</span>\r\n<span><span>delegate</span> <span>double</span> <span>MathAction</span>(<span><span>double</span> num</span>)</span>;\r\n\r\n<span>class</span> <span>DelegateTest</span>\r\n{\r\n    <span>// Regular method that matches signature:</span>\r\n    <span><span>static</span> <span>double</span> <span>Double</span>(<span><span>double</span> input</span>)\r\n    </span>{\r\n        <span>return</span> input * <span>2</span>;\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>// Instantiate delegate with named method:</span>\r\n        MathAction ma = Double;\r\n\r\n        <span>// Invoke delegate ma:</span>\r\n        <span>double</span> multByTwo = ma(<span>4.5</span>);\r\n        Console.WriteLine(<span>&quot;multByTwo: {0}&quot;</span>, multByTwo);\r\n\r\n        <span>// Instantiate delegate with anonymous method:</span>\r\n        MathAction ma2 = <span>delegate</span>(<span>double</span> input)\r\n        {\r\n            <span>return</span> input * input;\r\n        };\r\n\r\n        <span>double</span> square = ma2(<span>5</span>);\r\n        Console.WriteLine(<span>&quot;square: {0}&quot;</span>, square);\r\n\r\n        <span>// Instantiate delegate with lambda expression</span>\r\n        MathAction ma3 = s =&gt; s * s * s;\r\n        <span>double</span> cube = ma3(<span>4.375</span>);\r\n\r\n        Console.WriteLine(<span>&quot;cube: {0}&quot;</span>, cube);\r\n    }\r\n    <span>// Output:</span>\r\n    <span>// multByTwo: 9</span>\r\n    <span>// square: 25</span>\r\n    <span>// cube: 83.740234375</span>\r\n}</code></pre>"
          },
          {
            "Dynamic": "<p>\r\n\tThe&nbsp;<code>dynamic</code>&nbsp;type enables the operations in which it occurs to bypass compile-time type checking. Instead, these operations are resolved at run time. The&nbsp;<code>dynamic</code>&nbsp;type simplifies access to COM APIs such as the Office Automation APIs, and also to dynamic APIs such as IronPython libraries, and to the HTML Document Object Model (DOM).</p>\r\n<p>\r\n\tType&nbsp;<code>dynamic</code>&nbsp;behaves like type&nbsp;<code>object</code>&nbsp;in most circumstances. However, operations that contain expressions of type&nbsp;<code>dynamic</code>&nbsp;are not resolved or type checked by the compiler. The compiler packages together information about the operation, and that information is later used to evaluate the operation at run time. As part of the process, variables of type&nbsp;<code>dynamic</code>&nbsp;are compiled into variables of type&nbsp;<code>object</code>. Therefore, type&nbsp;<code>dynamic</code>&nbsp;exists only at compile time, not at run time.</p>\r\n<p>\r\n\tThe following example contrasts a variable of type&nbsp;<code>dynamic</code>&nbsp;to a variable of type&nbsp;<code>object</code>. To verify the type of each variable at compile time, place the mouse pointer over&nbsp;<code>dyn</code>&nbsp;or&nbsp;<code>obj</code>&nbsp;in the&nbsp;<code>WriteLine</code>&nbsp;statements. IntelliSense shows&nbsp;<span>dynamic</span>&nbsp;for&nbsp;<code>dyn</code>&nbsp;and&nbsp;<span>object</span>&nbsp;for&nbsp;<code>obj</code>.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>Program</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)\r\n    </span>{\r\n        <span>dynamic</span> dyn = <span>1</span>;\r\n        <span>object</span> obj = <span>1</span>;\r\n\r\n        <span>// Rest the mouse pointer over dyn and obj to see their</span>\r\n        <span>// types at compile time.</span>\r\n        System.Console.WriteLine(dyn.GetType());\r\n        System.Console.WriteLine(obj.GetType());\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tThe&nbsp;<code>WriteLine</code>&nbsp;statements display the run-time types of&nbsp;<code>dyn</code>&nbsp;and&nbsp;<code>obj</code>. At that point, both have the same type, integer. The following output is produced:</p>\r\n<p>\r\n\t<code>System.Int32</code></p>\r\n<p>\r\n\t<code>System.Int32</code></p>\r\n<p>\r\n\tTo see the difference between&nbsp;<code>dyn</code>&nbsp;and&nbsp;<code>obj</code>&nbsp;at compile time, add the following two lines between the declarations and the&nbsp;<code>WriteLine</code>&nbsp;statements in the previous example.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>dyn = dyn + <span>3</span>;\r\nobj = obj + <span>3</span>;\r\n</code></pre>\r\n<p>\r\n\tA compiler error is reported for the attempted addition of an integer and an object in expression&nbsp;<code>obj + 3</code>. However, no error is reported for&nbsp;<code>dyn + 3</code>. The expression that contains&nbsp;<code>dyn</code>&nbsp;is not checked at compile time because the type of&nbsp;<code>dyn</code>&nbsp;is&nbsp;<code>dynamic</code>.</p>\r\n<h2>\r\n\tContext</h2>\r\n<p>\r\n\tThe&nbsp;<code>dynamic</code>&nbsp;keyword can appear directly or as a component of a constructed type in the following situations:</p>\r\n<ul>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tIn declarations, as the type of a property, field, indexer, parameter, return value, local variable, or type constraint. The following class definition uses&nbsp;<code>dynamic</code>&nbsp;in several different declarations.</p>\r\n\t\t<div>\r\n\t\t\t&nbsp;</div>\r\n\t\t<pre>\r\n\t\t<code><span>class</span> <span>ExampleClass</span>\r\n{\r\n    <span>// A dynamic field.</span>\r\n    <span>static</span> <span>dynamic</span> field;\r\n\r\n    <span>// A dynamic property.</span>\r\n    <span>dynamic</span> prop { <span>get</span>; <span>set</span>; }\r\n\r\n    <span>// A dynamic return type and a dynamic parameter type.</span>\r\n    <span><span>public</span> <span>dynamic</span> <span>exampleMethod</span>(<span><span>dynamic</span> d</span>)\r\n    </span>{\r\n        <span>// A dynamic local variable.</span>\r\n        <span>dynamic</span> local = <span>&quot;Local variable&quot;</span>;\r\n        <span>int</span> two = <span>2</span>;\r\n\r\n        <span>if</span> (d <span>is</span> <span>int</span>)\r\n        {\r\n            <span>return</span> local;\r\n        }\r\n        <span>else</span>\r\n        {\r\n            <span>return</span> two;\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tIn explicit type conversions, as the target type of a conversion.</p>\r\n\t\t<div>\r\n\t\t\t&nbsp;</div>\r\n\t\t<pre>\r\n\t\t<code><span><span>static</span> <span>void</span> <span>convertToDynamic</span>()\r\n</span>{\r\n    <span>dynamic</span> d;\r\n    <span>int</span> i = <span>20</span>;\r\n    d = (<span>dynamic</span>)i;\r\n    Console.WriteLine(d);\r\n\r\n    <span>string</span> s = <span>&quot;Example string.&quot;</span>;\r\n    d = (<span>dynamic</span>)s;\r\n    Console.WriteLine(d);\r\n\r\n    DateTime dt = DateTime.Today;\r\n    d = (<span>dynamic</span>)dt;\r\n    Console.WriteLine(d);\r\n\r\n}\r\n<span>// Results:</span>\r\n<span>// 20</span>\r\n<span>// Example string.</span>\r\n<span>// 7/25/2018 12:00:00 AM</span>\r\n</code></pre>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tIn any context where types serve as values, such as on the right side of an&nbsp;<code>is</code>&nbsp;operator or an&nbsp;<code>as</code>&nbsp;operator, or as the argument to&nbsp;<code>typeof</code>&nbsp;as part of a constructed type. For example,&nbsp;<code>dynamic</code>&nbsp;can be used in the following expressions.</p>\r\n\t\t<div>\r\n\t\t\t&nbsp;</div>\r\n\t\t<pre>\r\n\t\t<code><span>int</span> i = <span>8</span>;\r\n<span>dynamic</span> d;\r\n<span>// With the is operator.</span>\r\n<span>// The dynamic type behaves like object. The following</span>\r\n<span>// expression returns true unless someVar has the value null.</span>\r\n<span>if</span> (someVar <span>is</span> <span>dynamic</span>) { }\r\n\r\n<span>// With the as operator.</span>\r\nd = i <span>as</span> <span>dynamic</span>;\r\n\r\n<span>// With typeof, as part of a constructed type.</span>\r\nConsole.WriteLine(<span>typeof</span>(List&lt;<span>dynamic</span>&gt;));\r\n\r\n<span>// The following statement causes a compiler error.</span>\r\n<span>//Console.WriteLine(typeof(dynamic));</span>\r\n</code></pre>\r\n\t</li>\r\n</ul>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example uses&nbsp;<code>dynamic</code>&nbsp;in several declarations. The&nbsp;<code>Main</code>&nbsp;method also contrasts compile-time type checking with run-time type checking.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System;\r\n\r\n<span>namespace</span> <span>DynamicExamples</span>\r\n{\r\n    <span>class</span> <span>Program</span>\r\n    {\r\n        <span><span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)\r\n        </span>{\r\n            ExampleClass ec = <span>new</span> ExampleClass();\r\n            Console.WriteLine(ec.exampleMethod(<span>10</span>));\r\n            Console.WriteLine(ec.exampleMethod(<span>&quot;value&quot;</span>));\r\n\r\n            <span>// The following line causes a compiler error because exampleMethod</span>\r\n            <span>// takes only one argument.</span>\r\n            <span>//Console.WriteLine(ec.exampleMethod(10, 4));</span>\r\n\r\n            <span>dynamic</span> dynamic_ec = <span>new</span> ExampleClass();\r\n            Console.WriteLine(dynamic_ec.exampleMethod(<span>10</span>));\r\n\r\n            <span>// Because dynamic_ec is dynamic, the following call to exampleMethod</span>\r\n            <span>// with two arguments does not produce an error at compile time.</span>\r\n            <span>// However, itdoes cause a run-time error. </span>\r\n            <span>//Console.WriteLine(dynamic_ec.exampleMethod(10, 4));</span>\r\n        }\r\n    }\r\n\r\n    <span>class</span> <span>ExampleClass</span>\r\n    {\r\n        <span>static</span> <span>dynamic</span> field;\r\n        <span>dynamic</span> prop { <span>get</span>; <span>set</span>; }\r\n\r\n        <span><span>public</span> <span>dynamic</span> <span>exampleMethod</span>(<span><span>dynamic</span> d</span>)\r\n        </span>{\r\n            <span>dynamic</span> local = <span>&quot;Local variable&quot;</span>;\r\n            <span>int</span> two = <span>2</span>;\r\n\r\n            <span>if</span> (d <span>is</span> <span>int</span>)\r\n            {\r\n                <span>return</span> local;\r\n            }\r\n            <span>else</span>\r\n            {\r\n                <span>return</span> two;\r\n            }\r\n        }\r\n    }\r\n}\r\n<span>// Results:</span>\r\n<span>// Local variable</span>\r\n<span>// 2</span>\r\n<span>// Local variable</span></code></pre>"
          },
          {
            "Interface": "<p>\r\n\tAn interface contains only the signatures of&nbsp;methods,&nbsp;properties,&nbsp;events&nbsp;or&nbsp;indexers. A class or struct that implements the interface must implement the members of the interface that are specified in the interface definition. In the following example, class&nbsp;<code>ImplementationClass</code>&nbsp;must implement a method named&nbsp;<code>SampleMethod</code>&nbsp;that has no parameters and returns&nbsp;<code>void</code>.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<h2>\r\n\tExample</h2>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>interface</span> <span>ISampleInterface</span>\r\n{\r\n    <span><span>void</span> <span>SampleMethod</span>()</span>;\r\n}\r\n\r\n<span>class</span> <span>ImplementationClass</span> : <span>ISampleInterface</span>\r\n{\r\n    <span>// Explicit interface member implementation: </span>\r\n    <span>void</span> ISampleInterface.SampleMethod()\r\n    {\r\n        <span>// Method implementation.</span>\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>// Declare an interface instance.</span>\r\n        ISampleInterface obj = <span>new</span> ImplementationClass();\r\n\r\n        <span>// Call the member.</span>\r\n        obj.SampleMethod();\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tAn interface can be a member of a namespace or a class and can contain signatures of the following members:</p>\r\n<ul>\r\n\t<li>\r\n\t\tMethods</li>\r\n\t<li>\r\n\t\tProperties</li>\r\n\t<li>\r\n\t\tIndexers</li>\r\n\t<li>\r\n\t\tEvents</li>\r\n</ul>\r\n<p>\r\n\tAn interface can inherit from one or more base interfaces.</p>\r\n<p>\r\n\tWhen a base type list contains a base class and interfaces, the base class must come first in the list.</p>\r\n<p>\r\n\tA class that implements an interface can explicitly implement members of that interface. An explicitly implemented member cannot be accessed through a class instance, but only through an instance of the interface.</p>\r\n<p>\r\n\tExample</p>\r\n<p>\r\n\tThe following example demonstrates interface implementation. In this example, the interface contains the property declaration and the class contains the implementation. Any instance of a class that implements&nbsp;<code>IPoint</code>&nbsp;has integer properties&nbsp;<code>x</code>&nbsp;and&nbsp;<code>y</code>.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>interface</span> <span>IPoint</span>\r\n{\r\n   <span>// Property signatures:</span>\r\n   <span>int</span> x\r\n   {\r\n      <span>get</span>;\r\n      <span>set</span>;\r\n   }\r\n\r\n   <span>int</span> y\r\n   {\r\n      <span>get</span>;\r\n      <span>set</span>;\r\n   }\r\n}\r\n\r\n<span>class</span> <span>Point</span> : <span>IPoint</span>\r\n{\r\n   <span>// Fields:</span>\r\n   <span>private</span> <span>int</span> _x;\r\n   <span>private</span> <span>int</span> _y;\r\n\r\n   <span>// Constructor:</span>\r\n   <span><span>public</span> <span>Point</span>(<span><span>int</span> x, <span>int</span> y</span>)\r\n   </span>{\r\n      _x = x;\r\n      _y = y;\r\n   }\r\n\r\n   <span>// Property implementation:</span>\r\n   <span>public</span> <span>int</span> x\r\n   {\r\n      <span>get</span>\r\n      {\r\n         <span>return</span> _x;\r\n      }\r\n\r\n      <span>set</span>\r\n      {\r\n         _x = <span>value</span>;\r\n      }\r\n   }\r\n\r\n   <span>public</span> <span>int</span> y\r\n   {\r\n      <span>get</span>\r\n      {\r\n         <span>return</span> _y;\r\n      }\r\n      <span>set</span>\r\n      {\r\n         _y = <span>value</span>;\r\n      }\r\n   }\r\n}\r\n\r\n<span>class</span> <span>MainClass</span>\r\n{\r\n   <span><span>static</span> <span>void</span> <span>PrintPoint</span>(<span>IPoint p</span>)\r\n   </span>{\r\n      Console.WriteLine(<span>&quot;x={0}, y={1}&quot;</span>, p.x, p.y);\r\n   }\r\n\r\n   <span><span>static</span> <span>void</span> <span>Main</span>()\r\n   </span>{\r\n      IPoint p = <span>new</span> Point(<span>2</span>, <span>3</span>);\r\n      Console.Write(<span>&quot;My Point: &quot;</span>);\r\n      PrintPoint(p);\r\n   }\r\n}\r\n<span>// Output: My Point: x=2, y=3</span></code></pre>"
          },
          {
            "Object": "<p>\r\n\tThe&nbsp;<code>object</code>&nbsp;type is an alias for&nbsp;Object&nbsp;in .NET. In the unified type system of C#, all types, predefined and user-defined, reference types and value types, inherit directly or indirectly from&nbsp;Object. You can assign values of any type to variables of type&nbsp;<code>object</code>. When a variable of a value type is converted to object, it is said to be&nbsp;<em>boxed</em>. When a variable of type object is converted to a value type, it is said to be&nbsp;<em>unboxed</em>.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following sample shows how variables of type&nbsp;<code>object</code>&nbsp;can accept values of any data type and how variables of type&nbsp;<code>object</code>&nbsp;can use methods on&nbsp;Object&nbsp;from the .NET Framework.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>ObjectTest</span>\r\n{\r\n   <span>public</span> <span>int</span> i = <span>10</span>;\r\n}\r\n\r\n<span>class</span> <span>MainClass2</span>\r\n{\r\n   <span><span>static</span> <span>void</span> <span>Main</span>()\r\n   </span>{\r\n      <span>object</span> a;\r\n      a = <span>1</span>;   <span>// an example of boxing</span>\r\n      Console.WriteLine(a);\r\n      Console.WriteLine(a.GetType());\r\n      Console.WriteLine(a.ToString());\r\n\r\n      a = <span>new</span> ObjectTest();\r\n      ObjectTest classRef;\r\n      classRef = (ObjectTest)a;\r\n      Console.WriteLine(classRef.i);\r\n   }\r\n}\r\n<span>/* Output\r\n    1\r\n    System.Int32\r\n    1\r\n * 10\r\n*/</span></code></pre>"
          },
          {
            "String": "<p>\r\n\tThe&nbsp;<code>string</code>&nbsp;type represents a sequence of zero or more Unicode characters.&nbsp;<code>string</code>&nbsp;is an alias for&nbsp;String&nbsp;in .NET.</p>\r\n<p>\r\n\tAlthough&nbsp;<code>string</code>&nbsp;is a reference type, the equality operators (<code>==</code>&nbsp;and&nbsp;<code>!=</code>) are defined to compare the values of&nbsp;<code>string</code>&nbsp;objects, not references. This makes testing for string equality more intuitive. For example:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> a = <span>&quot;hello&quot;</span>;\r\n<span>string</span> b = <span>&quot;h&quot;</span>;\r\n<span>// Append to contents of &#39;b&#39;</span>\r\nb += <span>&quot;ello&quot;</span>;\r\nConsole.WriteLine(a == b);\r\nConsole.WriteLine((<span>object</span>)a == (<span>object</span>)b);\r\n</code></pre>\r\n<p>\r\n\tThis displays &quot;True&quot; and then &quot;False&quot; because the content of the strings are equivalent, but&nbsp;<code>a</code>&nbsp;and&nbsp;<code>b</code>do not refer to the same string instance.</p>\r\n<p>\r\n\tThe + operator concatenates strings:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> a = <span>&quot;good &quot;</span> + <span>&quot;morning&quot;</span>;\r\n</code></pre>\r\n<p>\r\n\tThis creates a string object that contains &quot;good morning&quot;.</p>\r\n<p>\r\n\tStrings are&nbsp;<em>immutable</em>--the contents of a string object cannot be changed after the object is created, although the syntax makes it appear as if you can do this. For example, when you write this code, the compiler actually creates a new string object to hold the new sequence of characters, and that new object is assigned to b. The string &quot;h&quot; is then eligible for garbage collection.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> b = <span>&quot;h&quot;</span>;\r\nb += <span>&quot;ello&quot;</span>;\r\n</code></pre>\r\n<p>\r\n\tThe [] operator can be used for readonly access to individual characters of a&nbsp;<code>string</code>:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> str = <span>&quot;test&quot;</span>;\r\n<span>char</span> x = str[<span>2</span>];  <span>// x = &#39;s&#39;;</span>\r\n</code></pre>\r\n<p>\r\n\tString literals are of type&nbsp;<code>string</code>&nbsp;and can be written in two forms, quoted and @-quoted. Quoted string literals are enclosed in double quotation marks (&quot;):</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>&quot;good morning&quot;</span>  <span>// a string literal</span>\r\n</code></pre>\r\n<p>\r\n\tString literals can contain any character literal. Escape sequences are included. The following example uses escape sequence&nbsp;<code>\\\\</code>&nbsp;for backslash,&nbsp;<code>\\u0066</code>&nbsp;for the letter f, and&nbsp;<code>\\n</code>&nbsp;for newline.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> a = <span>&quot;\\\\\\u0066\\n&quot;</span>;\r\nConsole.WriteLine(a);\r\n</code></pre>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tThe escape code&nbsp;<code>\\udddd</code>&nbsp;(where&nbsp;<code>dddd</code>&nbsp;is a four-digit number) represents the Unicode character U+<code>dddd</code>. Eight-digit Unicode escape codes are also recognized:&nbsp;<code>\\Udddddddd</code>.</p>\r\n</div>\r\n<p>\r\n\tVerbatim string literals start with&nbsp;<code>@</code>&nbsp;and are also enclosed in double quotation marks. For example:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>@&quot;good morning&quot;</span>  <span>// a string literal</span>\r\n</code></pre>\r\n<p>\r\n\tThe advantage of verbatim strings is that escape sequences are&nbsp;<em>not</em>&nbsp;processed, which makes it easy to write, for example, a fully qualified file name:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>@&quot;c:\\Docs\\Source\\a.txt&quot;</span>  <span>// rather than &quot;c:\\\\Docs\\\\Source\\\\a.txt&quot;</span>\r\n</code></pre>\r\n<p>\r\n\tTo include a double quotation mark in an @-quoted string, double it:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>@&quot;&quot;&quot;Ahoy!&quot;&quot; cried the captain.&quot;</span> <span>// &quot;Ahoy!&quot; cried the captain.</span>\r\n</code></pre>\r\n<p>\r\n\t&nbsp;</p>\r\n<h2>\r\n\tExample</h2>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>SimpleStringTest</span> \r\n{\r\n   <span><span>static</span> <span>void</span> <span>Main</span>()\r\n   </span>{\r\n      <span>string</span> a = <span>&quot;\\u0068ello &quot;</span>;\r\n      <span>string</span> b = <span>&quot;world&quot;</span>;\r\n      Console.WriteLine( a + b );\r\n      Console.WriteLine( a + b == <span>&quot;Hello World&quot;</span> ); <span>// == performs a case-sensitive comparison</span>\r\n   }\r\n}\r\n<span>/* Output:\r\n    hello world\r\n    False\r\n */</span></code></pre>"
          },
          {
            "Void": "<p>\r\n\tWhen used as the return type for a method,&nbsp;<code>void</code>&nbsp;specifies that the method doesn&#39;t return a value.</p>\r\n<p>\r\n\t<code>void</code>&nbsp;isn&#39;t allowed in the parameter list of a method. A method that takes no parameters and returns no value is declared as follows:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>public</span> <span>void</span> <span>SampleMethod</span>()\r\n</span>{\r\n    <span>// Body of the method.</span>\r\n}\r\n</code></pre>\r\n<p>\r\n\t<code>void</code>&nbsp;is also used in an unsafe context to declare a pointer to an unknown type.</p>\r\n<p>\r\n\t<code>void</code>&nbsp;is an alias for the .NET Framework&nbsp;System.Void&nbsp;type.</p>"
          },
          {
            "Var": "<p>\r\n\tBeginning in Visual C# 3.0, variables that are declared at method scope can have an implicit &quot;type&quot;&nbsp;<code>var</code>. An implicitly typed local variable is strongly typed just as if you had declared the type yourself, but the compiler determines the type. The following two declarations of&nbsp;<code>i</code>&nbsp;are functionally equivalent:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>var</span> i = <span>10</span>; <span>// Implicitly typed. </span>\r\n<span>int</span> i = <span>10</span>; <span>// Explicitly typed. </span>\r\n</code></pre>\r\n<p>\r\n\t&nbsp;</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example shows two query expressions. In the first expression, the use of&nbsp;<code>var</code>&nbsp;is permitted but is not required, because the type of the query result can be stated explicitly as an&nbsp;<code>IEnumerable&lt;string&gt;</code>. However, in the second expression,&nbsp;<code>var</code>&nbsp;allows the result to be a collection of anonymous types, and the name of that type is not accessible except to the compiler itself. Use of&nbsp;<code>var</code>&nbsp;eliminates the requirement to create a new class for the result. Note that in Example #2, the&nbsp;<code>foreach</code>&nbsp;iteration variable&nbsp;<code>item</code>&nbsp;must also be implicitly typed.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Example #1: var is optional because</span>\r\n<span>// the select clause specifies a string</span>\r\n<span>string</span>[] words = { <span>&quot;apple&quot;</span>, <span>&quot;strawberry&quot;</span>, <span>&quot;grape&quot;</span>, <span>&quot;peach&quot;</span>, <span>&quot;banana&quot;</span> };\r\n<span>var</span> wordQuery = <span>from</span> word <span>in</span> words\r\n                <span>where</span> word[<span>0</span>] == <span>&#39;g&#39;</span>\r\n                <span>select</span> word;\r\n\r\n<span>// Because each element in the sequence is a string, </span>\r\n<span>// not an anonymous type, var is optional here also.</span>\r\n<span>foreach</span> (<span>string</span> s <span>in</span> wordQuery)\r\n{\r\n    Console.WriteLine(s);\r\n}\r\n\r\n<span>// Example #2: var is required when</span>\r\n<span>// the select clause specifies an anonymous type</span>\r\n<span>var</span> custQuery = <span>from</span> cust <span>in</span> customers\r\n                <span>where</span> cust.City == <span>&quot;Phoenix&quot;</span>\r\n                <span>select</span> <span>new</span> { cust.Name, cust.Phone };\r\n\r\n<span>// var must be used because each item </span>\r\n<span>// in the sequence is an anonymous type</span>\r\n<span>foreach</span> (<span>var</span> item <span>in</span> custQuery)\r\n{\r\n    Console.WriteLine(<span>&quot;Name={0}, Phone={1}&quot;</span>, item.Name, item.Phone);\r\n}</code></pre>"
          },
          {
            "Built-in types table": "<p>\r\n\tThe following table shows the keywords for built-in C# types, which are aliases of predefined types in the&nbsp;System&nbsp;namespace.</p>\r\n<div>\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tC# type</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .NET type</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tbool</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.Boolean</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tbyte</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.Byte</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tsbyte</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.SByte</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tchar</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.Char</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tdecimal</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.Decimal</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tdouble</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.Double</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tfloat</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.Single</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tint</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.Int32</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tuint</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.UInt32</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tlong</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.Int64</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tulong</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.UInt64</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tobject</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.Object</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tshort</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.Int16</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tushort</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.UInt16</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tstring</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.String</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<h2>\r\n\tRemarks</h2>\r\n<p>\r\n\tAll of the types in the table, except&nbsp;<code>object</code>&nbsp;and&nbsp;<code>string</code>, are referred to as simple types.</p>\r\n<p>\r\n\tThe C# type keywords and their aliases are interchangeable. For example, you can declare an integer variable by using either of the following declarations:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>int</span> x = <span>123</span>;\r\nSystem.Int32 y = <span>123</span>;\r\n</code></pre>\r\n<p>\r\n\tUse the&nbsp;typeof&nbsp;operator to get the&nbsp;System.Type&nbsp;instance that represents the specified type:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>Type stringType = <span>typeof</span>(<span>string</span>);\r\nConsole.WriteLine(stringType.FullName);\r\n\r\nType doubleType = <span>typeof</span>(System.Double);\r\nConsole.WriteLine(doubleType.FullName);\r\n\r\n<span>// Output:</span>\r\n<span>// System.String</span>\r\n<span>// System.Double</span></code></pre>"
          },
          {
            "Integral types table": "<p>\r\n\tThe following table shows the sizes and ranges of the integral types, which constitute a subset of simple types.</p>\r\n<div>\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tType</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tRange</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tSize</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tsbyte</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -128 to 127</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Signed 8-bit integer</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tbyte</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 to 255</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Unsigned 8-bit integer</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tchar</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; U+0000 to U+ffff</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Unicode 16-bit character</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tshort</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-32,768 to 32,767</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Signed 16-bit integer</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tushort</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 to 65,535</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Unsigned 16-bit integer</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tint</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;-2,147,483,648 to 2,147,483,647</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Signed 32-bit integer</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tuint</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 to 4,294,967,295</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Unsigned 32-bit integer</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tlong</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Signed 64-bit integer</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tulong</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 to 18,446,744,073,709,551,615</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Unsigned 64-bit integer</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<h2>\r\n\tRemarks</h2>\r\n<p>\r\n\tIf the value represented by an integer literal exceeds&nbsp;UInt64.MaxValue, a compiler error&nbsp;CS1021occurs.</p>\r\n<p>\r\n\tUse the&nbsp;System.Numerics.BigInteger&nbsp;class to represent an arbitrarily large signed integer.</p>"
          },
          {
            "Floating-point types table": "<h1>\r\n\t&nbsp;</h1>\r\n<p>\r\n\tThe following table shows the precision and approximate ranges for the floating-point types.</p>\r\n<div>\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\t<h1>\r\n\t\t\t\t\t\tType</h1>\r\n\t\t\t\t</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tApproximate range</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tPrecision</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tfloat</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&plusmn;1.5 x 10<span>&minus;45</span>&nbsp;to &plusmn;3.4 x 10<span>38</span></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; ~6-9 digits</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tdouble</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&plusmn;5.0 &times; 10<span>&minus;324</span>&nbsp;to &plusmn;1.7 &times; 10<span>308</span></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; ~15-17 digits</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tdecimal</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&plusmn;1.0 x 10<span>-28</span>&nbsp;to &plusmn;7.9228 x 10<span>28</span></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 28-29 digits</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>"
          },
          {
            "Value types table": "<p>\r\n\tThe following table shows the C# value types.</p>\r\n<div>\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tValue type</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tCategory</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tType suffix</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tbool</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; Boolean</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tbyte</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; Unsigned, numeric,&nbsp;integral</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tchar</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; Unsigned, numeric,&nbsp;integral</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tdecimal</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; Numeric,&nbsp;floating-point</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; M or m</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tdouble</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; Numeric,&nbsp;floating-point</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; D or d</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tenum</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; Enumeration</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tfloat</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; Numeric,&nbsp;floating-point</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;F or f</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tint</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; Signed, numeric,&nbsp;integral</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tlong&nbsp;</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; Signed, numeric,&nbsp;integral</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L or l</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tsbyte</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; Signed, numeric,&nbsp;integral</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tshort</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; Signed, numeric,&nbsp;integral</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tstruct</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; User-defined structure</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tuint</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; Unsigned, numeric,&nbsp;integral</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; U or u</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tulong</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; Unsigned, numeric,&nbsp;integral</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; UL, Ul, uL, ul, LU, Lu, lU, or lu</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tushort</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; Unsigned, numeric,&nbsp;integral</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<h2>\r\n\tRemarks</h2>\r\n<p>\r\n\tYou use a type suffix to specify a type of a numerical literal. For example:</p>\r\n<pre>\r\n<code><span>decimal</span> a = <span>0.1</span>M;\r\n</code></pre>\r\n<p>\r\n\tIf an&nbsp;integer numerical literal&nbsp;has no suffix, it has the first of the following types in which its value can be represented:&nbsp;<code>int</code>,&nbsp;<code>uint</code>,&nbsp;<code>long</code>,&nbsp;<code>ulong</code>.</p>\r\n<p>\r\n\tIf a&nbsp;real numerical literal&nbsp;has no suffix, it&#39;s of type&nbsp;<code>double</code>.</p>"
          },
          {
            "Default values table": "<p>\r\n\tThe following table shows the default values of&nbsp;value types.</p>\r\n<div>\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tValue type</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tDefault value</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tbool</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>&nbsp; &nbsp;false</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tbyte</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp;0</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tchar</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp;&#39;\\0&#39;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tdecimal</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp;0M</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tdouble</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp;0.0D</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<p>\r\n\t\t\t\t\t\tenum</p>\r\n\t\t\t\t</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<p>\r\n\t\t\t\t\t\tThe value produced by the expression&nbsp;<code>(E)0</code>, where&nbsp;<code>E</code>&nbsp;is the enum identifier.</p>\r\n\t\t\t\t</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tfloat</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; 0.0F</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tint</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; 0</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tlong</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; 0L</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tsbyte</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; 0</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tshort</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; 0</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tstruct</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe value produced by setting all value-type fields to their default values and all reference-type fields to&nbsp;<code>null</code>.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tuint</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; 0</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tulong</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; 0</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tushort</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; 0</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<h2>\r\n\tRemarks</h2>\r\n<p>\r\n\tYou cannot use uninitialized variables in C#. You can initialize a variable with the default value of its type. You also can use the default value of a type to specify the default value of a method&#39;s&nbsp;optional argument.</p>\r\n<p>\r\n\tUse the&nbsp;default value expression&nbsp;to produce the default value of a type, as the following example shows:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>int</span> a = <span>default</span>(<span>int</span>);\r\n</code></pre>\r\n<p>\r\n\tBeginning with C# 7.1, you can use the&nbsp;<code>default</code>&nbsp;literal&nbsp;to initialize a variable with the default value of its type:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>int</span> a = <span>default</span>;\r\n</code></pre>\r\n<p>\r\n\tYou also can use the default constructor or the implicit default constructor to produce the default value of a value type, as the following example shows. For more information about constructors, see the&nbsp;Constructors&nbsp;article.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>int</span> a = <span>new</span> <span>int</span>();\r\n</code></pre>\r\n<p>\r\n\tThe default value of any&nbsp;reference type&nbsp;is&nbsp;<code>null</code>. The default value of a&nbsp;nullable type&nbsp;is an instance for which the&nbsp;HasValue&nbsp;property is&nbsp;<code>false</code>&nbsp;and the&nbsp;Value&nbsp;property is undefined.</p>"
          },
          {
            "Implicit numeric conversions table": "<p>\r\n\tThe following table shows the predefined implicit conversions between .NET numeric types.</p>\r\n<div>\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tFrom</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tTo</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tsbyte</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>short</code>,&nbsp;<code>int</code>,&nbsp;<code>long</code>,&nbsp;<code>float</code>,&nbsp;<code>double</code>, or&nbsp;<code>decimal</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tbyte</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>short</code>,&nbsp;<code>ushort</code>,&nbsp;<code>int</code>,&nbsp;<code>uint</code>,&nbsp;<code>long</code>,&nbsp;<code>ulong</code>,&nbsp;<code>float</code>,&nbsp;<code>double</code>, or&nbsp;<code>decimal</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tshort</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>int</code>,&nbsp;<code>long</code>,&nbsp;<code>float</code>,&nbsp;<code>double</code>, or&nbsp;<code>decimal</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tushort</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>int</code>,&nbsp;<code>uint</code>,&nbsp;<code>long</code>,&nbsp;<code>ulong</code>,&nbsp;<code>float</code>,&nbsp;<code>double</code>, or&nbsp;<code>decimal</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tint</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>long</code>,&nbsp;<code>float</code>,&nbsp;<code>double</code>, or&nbsp;<code>decimal</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tuint</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>long</code>,&nbsp;<code>ulong</code>,&nbsp;<code>float</code>,&nbsp;<code>double</code>, or&nbsp;<code>decimal</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tlong</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>float</code>,&nbsp;<code>double</code>, or&nbsp;<code>decimal</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tchar</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>ushort</code>,&nbsp;<code>int</code>,&nbsp;<code>uint</code>,&nbsp;<code>long</code>,&nbsp;<code>ulong</code>,&nbsp;<code>float</code>,&nbsp;<code>double</code>, or&nbsp;<code>decimal</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tfloat</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>double</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tulong</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>float</code>,&nbsp;<code>double</code>, or&nbsp;<code>decimal</code></td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<h2>\r\n\tRemarks</h2>\r\n<ul>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tAny&nbsp;integral type&nbsp;is implicitly convertible to any&nbsp;floating-point type.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tPrecision but not magnitude might be lost in the conversions from&nbsp;<code>int</code>,&nbsp;<code>uint</code>,&nbsp;<code>long</code>, or&nbsp;<code>ulong</code>&nbsp;to&nbsp;<code>float</code>&nbsp;and from&nbsp;<code>long</code>&nbsp;or&nbsp;<code>ulong</code>&nbsp;to&nbsp;<code>double</code>.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tThere are no implicit conversions to the&nbsp;<code>char</code>&nbsp;type.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tThere are no implicit conversions between the&nbsp;<code>float</code>&nbsp;and&nbsp;<code>double</code>&nbsp;types and the&nbsp;<code>decimal</code>&nbsp;type.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tA value of a constant expression of type&nbsp;<code>int</code>&nbsp;(for example, a value represented by an integral literal) can be converted to&nbsp;<code>sbyte</code>,&nbsp;<code>byte</code>,&nbsp;<code>short</code>,&nbsp;<code>ushort</code>,&nbsp;<code>uint</code>, or&nbsp;<code>ulong</code>, provided it&#39;s within the range of the destination type:</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<pre>\r\n\t\t</pre>\r\n\t\t<p>\r\n\t\t\t&nbsp;</p>\r\n\t\t<pre>\r\n\t\t<code><span>byte</span> a = <span>13</span>;    <span>// Compiles</span>\r\n<span>byte</span> b = <span>300</span>;   <span>// CS0031: Constant value &#39;300&#39; cannot be converted to a &#39;byte&#39;</span></code></pre>\r\n\t</li>\r\n</ul>"
          },
          {
            "Explicit numeric conversions table": "<p>\r\n\tThe following table shows the predefined explicit conversions between .NET numeric types for which there is no&nbsp;implicit conversion.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<div>\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tFrom</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\t&nbsp;To</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tsbyte&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>byte</code>,&nbsp;<code>ushort</code>,&nbsp;<code>uint</code>,&nbsp;<code>ulong</code>, or&nbsp;<code>char</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tbyte</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>sbyte</code>&nbsp;or&nbsp;<code>char</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tshort</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>sbyte</code>,&nbsp;<code>byte</code>,&nbsp;<code>ushort</code>,&nbsp;<code>uint</code>,&nbsp;<code>ulong</code>, or&nbsp;<code>char</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tushort</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>sbyte</code>,&nbsp;<code>byte</code>,&nbsp;<code>short</code>, or&nbsp;<code>char</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tint</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>sbyte</code>,&nbsp;<code>byte</code>,&nbsp;<code>short</code>,&nbsp;<code>ushort</code>,&nbsp;<code>uint</code>,&nbsp;<code>ulong</code>,or&nbsp;<code>char</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tuint</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>sbyte</code>,&nbsp;<code>byte</code>,&nbsp;<code>short</code>,&nbsp;<code>ushort</code>,&nbsp;<code>int</code>, or&nbsp;<code>char</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tlong</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>sbyte</code>,&nbsp;<code>byte</code>,&nbsp;<code>short</code>,&nbsp;<code>ushort</code>,&nbsp;<code>int</code>,&nbsp;<code>uint</code>,&nbsp;<code>ulong</code>, or&nbsp;<code>char</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tulong</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>sbyte</code>,&nbsp;<code>byte</code>,&nbsp;<code>short</code>,&nbsp;<code>ushort</code>,&nbsp;<code>int</code>,&nbsp;<code>uint</code>,&nbsp;<code>long</code>, or&nbsp;<code>char</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tchar</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>sbyte</code>,&nbsp;<code>byte</code>, or&nbsp;<code>short</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tfloat</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>sbyte</code>,&nbsp;<code>byte</code>,&nbsp;<code>short</code>,&nbsp;<code>ushort</code>,&nbsp;<code>int</code>,&nbsp;<code>uint</code>,&nbsp;<code>long</code>,&nbsp;<code>ulong</code>,&nbsp;<code>char</code>,or&nbsp;<code>decimal</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tdouble</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>sbyte</code>,&nbsp;<code>byte</code>,&nbsp;<code>short</code>,&nbsp;<code>ushort</code>,&nbsp;<code>int</code>,&nbsp;<code>uint</code>,&nbsp;<code>long</code>,&nbsp;<code>ulong</code>,&nbsp;<code>char</code>,&nbsp;<code>float</code>,or&nbsp;<code>decimal</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tdecimal&nbsp;</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>sbyte</code>,&nbsp;<code>byte</code>,&nbsp;<code>short</code>,&nbsp;<code>ushort</code>,&nbsp;<code>int</code>,&nbsp;<code>uint</code>,&nbsp;<code>long</code>,&nbsp;<code>ulong</code>,&nbsp;<code>char</code>,&nbsp;<code>float</code>, or&nbsp;<code>double</code></td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<h2>\r\n\tRemarks</h2>\r\n<br />\r\n<div style=\"margin-left:18.0pt;\">\r\n\t<ul>\r\n\t\t<li>\r\n\t\t\tThe explicit numeric conversion may cause loss of precision or result in throwing an exception, typically an&nbsp;OverflowException.&nbsp;&nbsp;</li>\r\n\t\t<li>\r\n\t\t\tWhen you convert a value of an integral type to another integral type, the result depends on the overflow&nbsp;checking context. In a checked context, the conversion succeeds if the source value is within the range of the destination type. Otherwise, an&nbsp;OverflowException&nbsp;is thrown. In an unchecked context, the conversion always succeeds, and proceeds as follows:</li>\r\n\t\t<li>\r\n\t\t\tIf the source type is larger than the destination type, then the source value is truncated by discarding its &quot;extra&quot; most significant bits. The result is then treated as a value of the destination type.</li>\r\n\t\t<li>\r\n\t\t\tIf the source type is smaller than the destination type, then the source value is either sign-extended or zero-extended so that it is the same size as the destination type. Sign-extension is used if the source type is signed; zero-extension is used if the source type is unsigned. The result is then treated as a value of the destination type.</li>\r\n\t\t<li>\r\n\t\t\tIf the source type is the same size as the destination type, then the source value is treated as a value of the destination type.</li>\r\n\t\t<li>\r\n\t\t\tWhen you convert a&nbsp;decimal&nbsp;value to an integral type, this value is rounded towards zero to the nearest integral value. If the resulting integral value is outside the range of the destination type, an&nbsp;OverflowException&nbsp;is thrown.</li>\r\n\t\t<li>\r\n\t\t\tWhen you convert a&nbsp;double&nbsp;or&nbsp;float&nbsp;value to an integral type, this value is rounded towards zero to the nearest integral value. If the resulting integral value is outside the range of the destination type, the result depends on the overflow&nbsp;checking context. In a checked context, an&nbsp;OverflowException&nbsp;is thrown, while in an unchecked context, the result is an unspecified value of the destination type.</li>\r\n\t\t<li>\r\n\t\t\tWhen you convert&nbsp;double&nbsp;to&nbsp;float, the&nbsp;double&nbsp;value is rounded to the nearest&nbsp;float&nbsp;value. If the&nbsp;double&nbsp;value is too small or too large to fit into the destination type, the result will be zero or infinity.</li>\r\n\t\t<li>\r\n\t\t\tWhen you convert&nbsp;float&nbsp;or&nbsp;double&nbsp;to&nbsp;decimal, the source value is converted to&nbsp;decimalrepresentation and rounded to the nearest number after the 28th decimal place if required. Depending on the value of the source value, one of the following results may occur:</li>\r\n\t\t<li>\r\n\t\t\tIf the source value is too small to be represented as a&nbsp;decimal, the result becomes zero.</li>\r\n\t\t<li>\r\n\t\t\tIf the source value is NaN (not a number), infinity, or too large to be represented as a&nbsp;decimal, an&nbsp;OverflowException&nbsp;is thrown.</li>\r\n\t\t<li>\r\n\t\t\tWhen you convert&nbsp;decimal&nbsp;to&nbsp;float&nbsp;or&nbsp;double, the&nbsp;decimal&nbsp;value is rounded to the nearest&nbsp;double&nbsp;or&nbsp;float&nbsp;value.</li>\r\n\t</ul>\r\n</div>"
          },
          {
            "Formatting numeric results table": "<p>\r\n\tThe following table shows supported format specifiers for formatting numeric results. The formatted result in the last column corresponds to the &quot;en-US&quot;&nbsp;CultureInfo.</p>\r\n<div>\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tFormat specifier&nbsp;&nbsp;</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp;Description&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\t&nbsp;Examples</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\t&nbsp; Result</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tC or c</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; Currency</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>string s = $&quot;{2.5:C}&quot;;</code><br />\r\n\t\t\t\t\t<br />\r\n\t\t\t\t\t<code>string s = $&quot;{-2.5:C}&quot;;</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp;$2.50<br />\r\n\t\t\t\t\t<br />\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; ($2.50)</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tD or d</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; Decimal</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>string s = $&quot;{25:D5}&quot;;</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; 00025</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tE or e</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; Exponential</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>string s = $&quot;{250000:E2}&quot;;</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp;2.50E+005</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tF or f</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; Fixed-point</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>string s = $&quot;{2.5:F2}&quot;;</code><br />\r\n\t\t\t\t\t<br />\r\n\t\t\t\t\t<code>string s = $&quot;{2.5:F0}&quot;;</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp;2.50<br />\r\n\t\t\t\t\t<br />\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tG or g</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; General</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>string s = $&quot;{2.5:G}&quot;;</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; 2.5</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tN or n</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; Numeric</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>string s = $&quot;{2500000:N}&quot;;</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; 2,500,000.00</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tP or p</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; Percent</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>string s = $&quot;{0.25:P}&quot;;</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; 25.00%</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tR or r</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; Round-trip</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>string s = $&quot;{2.5:R}&quot;;</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.5</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tX or x</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; Hexadecimal</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>string s = $&quot;{250:X}&quot;;</code><br />\r\n\t\t\t\t\t<br />\r\n\t\t\t\t\t<code>string s = $&quot;{0xffff:X}&quot;;</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FA<br />\r\n\t\t\t\t\t<br />\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FFFF</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<h2>\r\n\tRemarks</h2>\r\n<p>\r\n\tYou use a format specifier to create a format string. The format string is of the following form:&nbsp;<code>Axx</code>, where</p>\r\n<ul>\r\n\t<li>\r\n\t\t<code>A</code>&nbsp;is the format specifier, which controls the type of formatting applied to the numeric value.</li>\r\n\t<li>\r\n\t\t<code>xx</code>&nbsp;is the precision specifier, which affects the number of digits in the formatted output. The value of the precision specifier ranges from 0 to 99.</li>\r\n</ul>\r\n<p>\r\n\tThe decimal (&quot;D&quot; or &quot;d&quot;) and hexadecimal (&quot;X&quot; or &quot;x&quot;) format specifiers are supported only for integral types. The round-trip (&quot;R&quot; or &quot;r&quot;) format specifier is supported only for&nbsp;Single,&nbsp;Double, and&nbsp;BigIntegertypes.</p>\r\n<p>\r\n\tStandard numeric format strings are supported by:</p>\r\n<ul>\r\n\t<li>\r\n\t\tSome overloads of the&nbsp;<code>ToString</code>&nbsp;method of all numeric types. For example, you can supply a numeric format string to the&nbsp;Int32.ToString(String)&nbsp;and&nbsp;Int32.ToString(String, IFormatProvider)methods.</li>\r\n\t<li>\r\n\t\tThe .NET&nbsp;composite formatting feature, which is supported by the&nbsp;String.Format&nbsp;method, for example.</li>\r\n\t<li>\r\n\t\tInterpolated strings.</li>\r\n</ul>"
          },
          {
            "Accessibility Levels": "<p>\r\n\tUse the access modifiers,&nbsp;<code>public</code>,&nbsp;<code>protected</code>,&nbsp;<code>internal</code>, or&nbsp;<code>private</code>, to specify one of the following declared accessibility levels for members.</p>\r\n<div>\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tDeclared accessibility&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tMeaning</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>public</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tAccess is not restricted.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>protected</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tAccess is limited to the containing class or types derived from the containing class.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>internal</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tAccess is limited to the current assembly.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>protected internal</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tAccess is limited to the current assembly or types derived from the containing class.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>private</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tAccess is limited to the containing type.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>private protected</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tAccess is limited to the containing class or types derived from the containing class within the current assembly. Available since C# 7.2.</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<p>\r\n\tOnly one access modifier is allowed for a member or type, except when you use the&nbsp;<code>protected internal</code>&nbsp;or&nbsp;<code>private protected</code>&nbsp;combinations.</p>\r\n<p>\r\n\tAccess modifiers are not allowed on namespaces. Namespaces have no access restrictions.</p>\r\n<p>\r\n\tDepending on the context in which a member declaration occurs, only certain declared accessibilities are permitted. If no access modifier is specified in a member declaration, a default accessibility is used.</p>\r\n<p>\r\n\tTop-level types, which are not nested in other types, can only have&nbsp;<code>internal</code>&nbsp;or&nbsp;<code>public</code>&nbsp;accessibility. The default accessibility for these types is&nbsp;<code>internal</code>.</p>\r\n<p>\r\n\tNested types, which are members of other types, can have declared accessibilities as indicated in the following table.</p>\r\n<div>\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tMembers of&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tDefault member accessibility&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\t&nbsp; &nbsp;Allowed declared accessibility of the member</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>enum</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>public</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tNone</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>class</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>private</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>public</code><br />\r\n\t\t\t\t\t<br />\r\n\t\t\t\t\t<code>protected</code><br />\r\n\t\t\t\t\t<br />\r\n\t\t\t\t\t<code>internal</code><br />\r\n\t\t\t\t\t<br />\r\n\t\t\t\t\t<code>private</code><br />\r\n\t\t\t\t\t<br />\r\n\t\t\t\t\t<code>protected internal</code>&nbsp;<br />\r\n\t\t\t\t\t<br />\r\n\t\t\t\t\t<code>private protected</code></td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>interface</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>public</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tNone</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>struct</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>private</code></td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<code>public</code><br />\r\n\t\t\t\t\t<br />\r\n\t\t\t\t\t<code>internal</code><br />\r\n\t\t\t\t\t<br />\r\n\t\t\t\t\t<code>private</code></td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<p>\r\n\tThe accessibility of a nested type depends on its&nbsp;accessibility domain, which is determined by both the declared accessibility of the member and the accessibility domain of the immediately containing type. However, the accessibility domain of a nested type cannot exceed that of the containing type.</p>"
          },
          {
            "Accessibility Domain": "<p>\r\n\tThe accessibility domain of a member specifies in which program sections a member can be referenced. If the member is nested within another type, its accessibility domain is determined by both the&nbsp;accessibility level&nbsp;of the member and the accessibility domain of the immediately containing type.</p>\r\n<p>\r\n\tThe accessibility domain of a top-level type is at least the program text of the project that it is declared in. That is, the domain includes all of the source files of this project. The accessibility domain of a nested type is at least the program text of the type in which it is declared. That is, the domain is the type body, which includes all nested types. The accessibility domain of a nested type never exceeds that of the containing type. These concepts are demonstrated in the following example.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThis example contains a top-level type,&nbsp;<code>T1</code>, and two nested classes,&nbsp;<code>M1</code>&nbsp;and&nbsp;<code>M2</code>. The classes contain fields that have different declared accessibilities. In the&nbsp;<code>Main</code>&nbsp;method, a comment follows each statement to indicate the accessibility domain of each member. Notice that the statements that try to reference the inaccessible members are commented out. If you want to see the compiler errors caused by referencing an inaccessible member, remove the comments one at a time.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>\r\n<span>namespace</span> <span>AccessibilityDomainNamespace</span>\r\n{\r\n    <span>public</span> <span>class</span> <span>T1</span>\r\n    {\r\n        <span>public</span> <span>static</span> <span>int</span> publicInt;\r\n        <span>internal</span> <span>static</span> <span>int</span> internalInt;\r\n        <span>private</span> <span>static</span> <span>int</span> privateInt = <span>0</span>;\r\n        <span><span>static</span> <span>T1</span>()\r\n        </span>{\r\n            <span>// T1 can access public or internal members</span>\r\n            <span>// in a public or private (or internal) nested class</span>\r\n            M1.publicInt = <span>1</span>;\r\n            M1.internalInt = <span>2</span>;\r\n            M2.publicInt = <span>3</span>;\r\n            M2.internalInt = <span>4</span>;\r\n\r\n            <span>// Cannot access the private member privateInt</span>\r\n            <span>// in either class:</span>\r\n            <span>// M1.privateInt = 2; //CS0122</span>\r\n        }\r\n\r\n        <span>public</span> <span>class</span> <span>M1</span>\r\n        {\r\n            <span>public</span> <span>static</span> <span>int</span> publicInt;\r\n            <span>internal</span> <span>static</span> <span>int</span> internalInt;\r\n            <span>private</span> <span>static</span> <span>int</span> privateInt = <span>0</span>;\r\n        }\r\n\r\n        <span>private</span> <span>class</span> <span>M2</span>\r\n        {\r\n            <span>public</span> <span>static</span> <span>int</span> publicInt = <span>0</span>;\r\n            <span>internal</span> <span>static</span> <span>int</span> internalInt = <span>0</span>;\r\n            <span>private</span> <span>static</span> <span>int</span> privateInt = <span>0</span>;\r\n        }\r\n    }\r\n\r\n    <span>class</span> <span>MainClass</span>\r\n    {\r\n        <span><span>static</span> <span>void</span> <span>Main</span>()\r\n        </span>{\r\n            <span>// Access is unlimited:</span>\r\n            T1.publicInt = <span>1</span>;\r\n\r\n            <span>// Accessible only in current assembly:</span>\r\n            T1.internalInt = <span>2</span>;\r\n\r\n            <span>// Error CS0122: inaccessible outside T1:</span>\r\n            <span>// T1.privateInt = 3;  </span>\r\n\r\n            <span>// Access is unlimited:</span>\r\n            T1.M1.publicInt = <span>1</span>;\r\n\r\n            <span>// Accessible only in current assembly:</span>\r\n            T1.M1.internalInt = <span>2</span>;\r\n\r\n            <span>// Error CS0122: inaccessible outside M1:</span>\r\n            <span>//    T1.M1.privateInt = 3; </span>\r\n\r\n            <span>// Error CS0122: inaccessible outside T1:</span>\r\n            <span>//    T1.M2.publicInt = 1;</span>\r\n\r\n            <span>// Error CS0122: inaccessible outside T1:</span>\r\n            <span>//    T1.M2.internalInt = 2;</span>\r\n\r\n            <span>// Error CS0122: inaccessible outside M2:</span>\r\n            <span>//    T1.M2.privateInt = 3;</span>\r\n\r\n            <span>// Keep the console open in debug mode.</span>\r\n            System.Console.WriteLine(<span>&quot;Press any key to exit.&quot;</span>);\r\n            System.Console.ReadKey();\r\n        }\r\n    }\r\n}</code></pre>"
          },
          {
            "Restrictions on using accessibility levels": "<p>\r\n\tWhen you specify a type in a declaration, check whether the accessibility level of the type is dependent on the accessibility level of a member or of another type. For example, the direct base class must be at least as accessible as the derived class. The following declarations cause a compiler error because the base class&nbsp;<code>BaseClass</code>&nbsp;is less accessible than&nbsp;<code>MyClass</code>:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>BaseClass</span> {...}\r\n<span>public</span> <span>class</span> <span>MyClass</span>: <span>BaseClass</span> {...} <span>// Error</span>\r\n</code></pre>\r\n<p>\r\n\tThe following table summarizes the restrictions on declared accessibility levels.</p>\r\n<div>\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tContext&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tRemarks</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tClasses</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe direct base class of a class type must be at least as accessible as the class type itself.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tInterfaces</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe explicit base interfaces of an interface type must be at least as accessible as the interface type itself.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tDelegates</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe return type and parameter types of a delegate type must be at least as accessible as the delegate type itself.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tConstants</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe type of a constant must be at least as accessible as the constant itself.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tFields</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe type of a field must be at least as accessible as the field itself.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tMethods</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe return type and parameter types of a method must be at least as accessible as the method itself.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tProperties</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe type of a property must be at least as accessible as the property itself.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tEvents</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe type of an event must be at least as accessible as the event itself.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tIndexers</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe type and parameter types of an indexer must be at least as accessible as the indexer itself.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tOperators</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe return type and parameter types of an operator must be at least as accessible as the operator itself.</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tConstructors</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe parameter types of a constructor must be at least as accessible as the constructor itself.</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example contains erroneous declarations of different types. The comment following each declaration indicates the expected compiler error.</p>\r\n<pre>\r\n<code><span>// Restrictions on Using Accessibility Levels</span>\r\n<span>// CS0052 expected as well as CS0053, CS0056, and CS0057</span>\r\n<span>// To make the program work, change access level of both class B</span>\r\n<span>// and MyPrivateMethod() to public.</span>\r\n\r\n<span>using</span> System;\r\n\r\n<span>// A delegate:</span>\r\n<span><span>delegate</span> <span>int</span> <span>MyDelegate</span>()</span>;\r\n\r\n<span>class</span> <span>B</span>\r\n{\r\n    <span>// A private method:</span>\r\n    <span><span>static</span> <span>int</span> <span>MyPrivateMethod</span>()\r\n    </span>{\r\n        <span>return</span> <span>0</span>;\r\n    }\r\n}\r\n\r\n<span>public</span> <span>class</span> <span>A</span>\r\n{\r\n    <span>// Error: The type B is less accessible than the field A.myField.</span>\r\n    <span>public</span> B myField = <span>new</span> B();\r\n\r\n    <span>// Error: The type B is less accessible</span>\r\n    <span>// than the constant A.myConst.</span>\r\n    <span>public</span> <span>readonly</span> B myConst = <span>new</span> B();\r\n\r\n    <span><span>public</span> B <span>MyMethod</span>()\r\n    </span>{\r\n        <span>// Error: The type B is less accessible </span>\r\n        <span>// than the method A.MyMethod.</span>\r\n        <span>return</span> <span>new</span> B();\r\n    }\r\n\r\n    <span>// Error: The type B is less accessible than the property A.MyProp</span>\r\n    <span>public</span> B MyProp\r\n    {\r\n        <span>set</span>\r\n        {\r\n        }\r\n    }\r\n\r\n    MyDelegate d = <span>new</span> MyDelegate(B.MyPrivateMethod);\r\n    <span>// Even when B is declared public, you still get the error: </span>\r\n    <span>// &quot;The parameter B.MyPrivateMethod is not accessible due to </span>\r\n    <span>// protection level.&quot;</span>\r\n\r\n    <span>public</span> <span>static</span> B <span>operator</span> +(A m1, B m2)\r\n    {\r\n        <span>// Error: The type B is less accessible</span>\r\n        <span>// than the operator A.operator +(A,B)</span>\r\n        <span>return</span> <span>new</span> B();\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        Console.Write(<span>&quot;Compiled successfully&quot;</span>);\r\n    }\r\n}</code></pre>"
          },
          {
            "internal": "<p>\r\n\tThe&nbsp;<code>internal</code>&nbsp;keyword is an&nbsp;access modifier&nbsp;for types and type members.</p>\r\n<blockquote>\r\n\t<p>\r\n\t\tThis page covers&nbsp;<code>internal</code>&nbsp;access. The&nbsp;<code>internal</code>&nbsp;keyword is also part of the&nbsp;<code>protected internal</code>&nbsp;access modifier.</p>\r\n</blockquote>\r\n<p>\r\n\tInternal types or members are accessible only within files in the same assembly, as in this example:</p>\r\n<pre>\r\n<code><span>public</span> <span>class</span> <span>BaseClass</span>   \r\n{  \r\n    <span>// Only accessible within the same assembly  </span>\r\n    <span>internal</span> <span>static</span> <span>int</span> x = <span>0</span>;  \r\n}  \r\n</code></pre>\r\n<p>\r\n\tFor a comparison of&nbsp;<code>internal</code>&nbsp;with the other access modifiers, see&nbsp;Accessibility Levels&nbsp;and&nbsp;Access Modifiers.</p>\r\n<p>\r\n\tFor more information about assemblies, see&nbsp;Assemblies and the Global Assembly Cache.</p>\r\n<p>\r\n\tA common use of internal access is in component-based development because it enables a group of components to cooperate in a private manner without being exposed to the rest of the application code. For example, a framework for building graphical user interfaces could provide&nbsp;<code>Control</code>&nbsp;and&nbsp;<code>Form</code>&nbsp;classes that cooperate by using members with internal access. Since these members are internal, they are not exposed to code that is using the framework.</p>\r\n<p>\r\n\tIt is an error to reference a type or a member with internal access outside the assembly within which it was defined.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThis example contains two files,&nbsp;<code>Assembly1.cs</code>&nbsp;and&nbsp;<code>Assembly1_a.cs</code>. The first file contains an internal base class,&nbsp;<code>BaseClass</code>. In the second file, an attempt to instantiate&nbsp;<code>BaseClass</code>&nbsp;will produce an error.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Assembly1.cs  </span>\r\n<span>// Compile with: /target:library  </span>\r\n<span>internal</span> <span>class</span> <span>BaseClass</span>   \r\n{  \r\n   <span>public</span> <span>static</span> <span>int</span> intM = <span>0</span>;  \r\n}  \r\n</code></pre>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Assembly1_a.cs  </span>\r\n<span>// Compile with: /reference:Assembly1.dll  </span>\r\n<span>class</span> <span>TestAccess</span>   \r\n{  \r\n   <span><span>static</span> <span>void</span> <span>Main</span>()   \r\n   </span>{  \r\n      BaseClass myBase = <span>new</span> BaseClass();   <span>// CS0122  </span>\r\n   }  \r\n}  \r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tIn this example, use the same files you used in example 1, and change the accessibility level of&nbsp;<code>BaseClass</code>&nbsp;to&nbsp;<code>public</code>. Also change the accessibility level of the member&nbsp;<code>IntM</code>&nbsp;to&nbsp;<code>internal</code>. In this case, you can instantiate the class, but you cannot access the internal member.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Assembly2.cs  </span>\r\n<span>// Compile with: /target:library  </span>\r\n<span>public</span> <span>class</span> <span>BaseClass</span>   \r\n{  \r\n   <span>internal</span> <span>static</span> <span>int</span> intM = <span>0</span>;  \r\n}  \r\n</code></pre>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Assembly2_a.cs  </span>\r\n<span>// Compile with: /reference:Assembly2.dll  </span>\r\n<span>public</span> <span>class</span> <span>TestAccess</span>   \r\n{  \r\n   <span><span>static</span> <span>void</span> <span>Main</span>()   \r\n   </span>{  \r\n      BaseClass myBase = <span>new</span> BaseClass();   <span>// Ok.  </span>\r\n      BaseClass.intM = <span>444</span>;    <span>// CS0117  </span>\r\n   }  \r\n}  </code></pre>"
          },
          {
            "private": "<p>\r\n\tThe&nbsp;<code>private</code>&nbsp;keyword is a member access modifier.</p>\r\n<blockquote>\r\n\t<p>\r\n\t\tThis page covers&nbsp;<code>private</code>&nbsp;access. The&nbsp;<code>private</code>&nbsp;keyword is also part of the&nbsp;<code>private protected</code>access modifier.</p>\r\n</blockquote>\r\n<p>\r\n\tPrivate access is the least permissive access level. Private members are accessible only within the body of the class or the struct in which they are declared, as in this example:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>Employee</span>\r\n{\r\n    <span>private</span> <span>int</span> i;\r\n    <span>double</span> d;   <span>// private access by default</span>\r\n}\r\n</code></pre>\r\n<p>\r\n\tNested types in the same body can also access those private members.</p>\r\n<p>\r\n\tIt is a compile-time error to reference a private member outside the class or the struct in which it is declared.</p>\r\n<p>\r\n\tFor a comparison of&nbsp;<code>private</code>&nbsp;with the other access modifiers, see&nbsp;Accessibility Levels&nbsp;and&nbsp;Access Modifiers.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tIn this example, the&nbsp;<code>Employee</code>&nbsp;class contains two private data members,&nbsp;<code>name</code>&nbsp;and&nbsp;<code>salary</code>. As private members, they cannot be accessed except by member methods. Public methods named&nbsp;<code>GetName</code>&nbsp;and&nbsp;<code>Salary</code>&nbsp;are added to allow controlled access to the private members. The&nbsp;<code>name</code>member is accessed by way of a public method, and the&nbsp;<code>salary</code>&nbsp;member is accessed by way of a public read-only property. (See&nbsp;Properties&nbsp;for more information.)</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>Employee2</span>\r\n{\r\n    <span>private</span> <span>string</span> name = <span>&quot;FirstName, LastName&quot;</span>;\r\n    <span>private</span> <span>double</span> salary = <span>100.0</span>;\r\n\r\n    <span><span>public</span> <span>string</span> <span>GetName</span>()\r\n    </span>{\r\n        <span>return</span> name;\r\n    }\r\n\r\n    <span>public</span> <span>double</span> Salary\r\n    {\r\n        <span>get</span> { <span>return</span> salary; }\r\n    }\r\n}\r\n\r\n<span>class</span> <span>PrivateTest</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        Employee2 e = <span>new</span> Employee2();\r\n\r\n        <span>// The data members are inaccessible (private), so</span>\r\n        <span>// they can&#39;t be accessed like this:</span>\r\n        <span>//    string n = e.name;</span>\r\n        <span>//    double s = e.salary;</span>\r\n\r\n        <span>// &#39;name&#39; is indirectly accessed via method:</span>\r\n        <span>string</span> n = e.GetName();\r\n\r\n        <span>// &#39;salary&#39; is indirectly accessed via property</span>\r\n        <span>double</span> s = e.Salary;\r\n    }\r\n}</code></pre>"
          },
          {
            "protected": "<p>\r\n\tThe&nbsp;<code>protected</code>&nbsp;keyword is a member access modifier.</p>\r\n<blockquote>\r\n\t<p>\r\n\t\tThis page covers&nbsp;<code>protected</code>&nbsp;access. The&nbsp;<code>protected</code>&nbsp;keyword is also part of the&nbsp;<code>protected internal</code>&nbsp;and&nbsp;<code>private protected</code>&nbsp;access modifiers.</p>\r\n</blockquote>\r\n<p>\r\n\tA protected member is accessible within its class and by derived class instances.</p>\r\n<p>\r\n\tFor a comparison of&nbsp;<code>protected</code>&nbsp;with the other access modifiers, see&nbsp;Accessibility Levels.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tA protected member of a base class is accessible in a derived class only if the access occurs through the derived class type. For example, consider the following code segment:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>A</span>\r\n{\r\n    <span>protected</span> <span>int</span> x = <span>123</span>;\r\n}\r\n\r\n<span>class</span> <span>B</span> : <span>A</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        A a = <span>new</span> A();\r\n        B b = <span>new</span> B();\r\n\r\n        <span>// Error CS1540, because x can only be accessed by</span>\r\n        <span>// classes derived from A.</span>\r\n        <span>// a.x = 10; </span>\r\n\r\n        <span>// OK, because this class derives from A.</span>\r\n        b.x = <span>10</span>;\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tThe statement&nbsp;<code>a.x = 10</code>&nbsp;generates an error because it is made within the static method Main, and not an instance of class B.</p>\r\n<p>\r\n\tStruct members cannot be protected because the struct cannot be inherited.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tIn this example, the class&nbsp;<code>DerivedPoint</code>&nbsp;is derived from&nbsp;<code>Point</code>. Therefore, you can access the protected members of the base class directly from the derived class.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>Point</span> \r\n{\r\n    <span>protected</span> <span>int</span> x; \r\n    <span>protected</span> <span>int</span> y;\r\n}\r\n\r\n<span>class</span> <span>DerivedPoint</span>: <span>Point</span> \r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>() \r\n    </span>{\r\n        DerivedPoint dpoint = <span>new</span> DerivedPoint();\r\n\r\n        <span>// Direct access to protected members:</span>\r\n        dpoint.x = <span>10</span>;\r\n        dpoint.y = <span>15</span>;\r\n        Console.WriteLine(<span>&quot;x = {0}, y = {1}&quot;</span>, dpoint.x, dpoint.y); \r\n    }\r\n}\r\n<span>// Output: x = 10, y = 15</span>\r\n</code></pre>\r\n<p>\r\n\tIf you change the access levels of&nbsp;<code>x</code>&nbsp;and&nbsp;<code>y</code>&nbsp;to&nbsp;private, the compiler will issue the error messages:</p>\r\n<p>\r\n\t<code>&#39;Point.y&#39; is inaccessible due to its protection level.</code></p>\r\n<p>\r\n\t<code>&#39;Point.x&#39; is inaccessible due to its protection level.</code></p>"
          },
          {
            "public": "<p>\r\n\tThe&nbsp;<code>public</code>&nbsp;keyword is an access modifier for types and type members. Public access is the most permissive access level. There are no restrictions on accessing public members, as in this example:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>SampleClass</span>\r\n{\r\n    <span>public</span> <span>int</span> x; <span>// No access restrictions.</span>\r\n}\r\n</code></pre>\r\n<p>\r\n\tSee&nbsp;Access Modifiers&nbsp;and&nbsp;Accessibility Levels&nbsp;for more information.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tIn the following example, two classes are declared,&nbsp;<code>PointTest</code>&nbsp;and&nbsp;<code>MainClass</code>. The public members&nbsp;<code>x</code>&nbsp;and&nbsp;<code>y</code>&nbsp;of&nbsp;<code>PointTest</code>&nbsp;are accessed directly from&nbsp;<code>MainClass</code>.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>PointTest</span>\r\n{\r\n    <span>public</span> <span>int</span> x; \r\n    <span>public</span> <span>int</span> y;\r\n}\r\n\r\n<span>class</span> <span>MainClass4</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>() \r\n    </span>{\r\n        PointTest p = <span>new</span> PointTest();\r\n        <span>// Direct access to public members:</span>\r\n        p.x = <span>10</span>;\r\n        p.y = <span>15</span>;\r\n        Console.WriteLine(<span>&quot;x = {0}, y = {1}&quot;</span>, p.x, p.y); \r\n    }\r\n}\r\n<span>// Output: x = 10, y = 15</span>\r\n</code></pre>\r\n<p>\r\n\tIf you change the&nbsp;<code>public</code>&nbsp;access level to&nbsp;private&nbsp;or&nbsp;protected, you will get the error message:</p>\r\n<p>\r\n\t&#39;PointTest.y&#39; is inaccessible due to its protection level.</p>"
          },
          {
            "protected internal": "<p>\r\n\tThe&nbsp;<code>protected internal</code>&nbsp;keyword combination is a member access modifier. A protected internal member is accessible from the current assembly or from types that are derived from the containing class. For a comparison of&nbsp;<code>protected internal</code>&nbsp;with the other access modifiers, see&nbsp;Accessibility Levels.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tA protected internal member of a base class is accessible from any type within its containing assembly. It is also accessible in a derived class located in another assembly only if the access occurs through a variable of the derived class type. For example, consider the following code segment:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Assembly1.cs</span>\r\n<span>// Compile with: /target:library</span>\r\n<span>public</span> <span>class</span> <span>BaseClass</span>\r\n{\r\n   <span>protected</span> <span>internal</span> <span>int</span> myValue = <span>0</span>;\r\n}\r\n\r\n<span>class</span> <span>TestAccess</span>\r\n{\r\n    <span><span>void</span> <span>Access</span>()\r\n    </span>{\r\n        BaseClass baseObject = <span>new</span> BaseClass();\r\n        baseObject.myValue = <span>5</span>;\r\n    }\r\n}\r\n</code></pre>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Assembly2.cs</span>\r\n<span>// Compile with: /reference:Assembly1.dll</span>\r\n<span>class</span> <span>DerivedClass</span> : <span>BaseClass</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        BaseClass baseObject = <span>new</span> BaseClass();\r\n        DerivedClass derivedObject = <span>new</span> DerivedClass();\r\n\r\n        <span>// Error CS1540, because myValue can only be accessed by</span>\r\n        <span>// classes derived from BaseClass.</span>\r\n        <span>// baseObject.myValue = 10;</span>\r\n\r\n        <span>// OK, because this class derives from BaseClass.</span>\r\n        derivedObject.myValue = <span>10</span>;\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tThis example contains two files,&nbsp;<code>Assembly1.cs</code>&nbsp;and&nbsp;<code>Assembly2.cs</code>. The first file contains a public base class,&nbsp;<code>BaseClass</code>, and another class,&nbsp;<code>TestAccess</code>.&nbsp;<code>BaseClass</code>&nbsp;owns a protected internal member,&nbsp;<code>myValue</code>, which is accessed by the&nbsp;<code>TestAccess</code>&nbsp;type. In the second file, an attempt to access&nbsp;<code>myValue</code>through an instance of&nbsp;<code>BaseClass</code>&nbsp;will produce an error, while an access to this member through an instance of a derived class,&nbsp;<code>DerivedClass</code>&nbsp;will succeed.</p>\r\n<p>\r\n\tStruct members cannot be&nbsp;<code>protected internal</code>&nbsp;because the struct cannot be inherited.</p>"
          },
          {
            "private protected": "<p>\r\n\tThe&nbsp;<code>private protected</code>&nbsp;keyword combination is a member access modifier. A private protected member is accessible by types derived from the containing class, but only within its containing assembly. For a comparison of&nbsp;<code>private protected</code>&nbsp;with the other access modifiers, see&nbsp;Accessibility Levels.</p>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tThe&nbsp;<code>private protected</code>&nbsp;access modifier is valid in C# version 7.2 and later.</p>\r\n</div>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tA private protected member of a base class is accessible from derived types in its containing assembly only if the static type of the variable is the derived class type. For example, consider the following code segment:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Assembly1.cs  </span>\r\n<span>// Compile with: /target:library  </span>\r\n<span>public</span> <span>class</span> <span>BaseClass</span>\r\n{\r\n    <span>private</span> <span>protected</span> <span>int</span> myValue = <span>0</span>;\r\n}\r\n\r\n<span>public</span> <span>class</span> <span>DerivedClass1</span> : <span>BaseClass</span>\r\n{\r\n    <span><span>void</span> <span>Access</span>()\r\n    </span>{\r\n        BaseClass baseObject = <span>new</span> BaseClass();\r\n\r\n        <span>// Error CS1540, because myValue can only be accessed by</span>\r\n        <span>// classes derived from BaseClass.</span>\r\n        <span>// baseObject.myValue = 5;  </span>\r\n\r\n        <span>// OK, accessed through the current derived class instance</span>\r\n        myValue = <span>5</span>;\r\n    }\r\n}\r\n</code></pre>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Assembly2.cs  </span>\r\n<span>// Compile with: /reference:Assembly1.dll  </span>\r\n<span>class</span> <span>DerivedClass2</span> : <span>BaseClass</span>\r\n{\r\n    <span><span>void</span> <span>Access</span>()\r\n    </span>{\r\n        <span>// Error CS0122, because myValue can only be</span>\r\n        <span>// accessed by types in Assembly1</span>\r\n        <span>// myValue = 10;</span>\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tThis example contains two files,&nbsp;<code>Assembly1.cs</code>&nbsp;and&nbsp;<code>Assembly2.cs</code>. The first file contains a public base class,&nbsp;<code>BaseClass</code>, and a type derived from it,&nbsp;<code>DerivedClass1</code>.&nbsp;<code>BaseClass</code>&nbsp;owns a private protected member,&nbsp;<code>myValue</code>, which&nbsp;<code>DerivedClass1</code>&nbsp;tries to access in two ways. The first attempt to access&nbsp;<code>myValue</code>&nbsp;through an instance of&nbsp;<code>BaseClass</code>&nbsp;will produce an error. However, the attempt to use it as an inherited member in&nbsp;<code>DerivedClass1</code>&nbsp;will succeed. In the second file, an attempt to access&nbsp;<code>myValue</code>as an inherited member of&nbsp;<code>DerivedClass2</code>&nbsp;will produce an error, as it is only accessible by derived types in Assembly1.</p>\r\n<p>\r\n\tStruct members cannot be&nbsp;<code>private protected</code>&nbsp;because the struct cannot be inherited.</p>"
          },
          {
            "abstract": "<p>\r\n\tThe&nbsp;<code>abstract</code>&nbsp;modifier indicates that the thing being modified has a missing or incomplete implementation. The abstract modifier can be used with classes, methods, properties, indexers, and events. Use the&nbsp;<code>abstract</code>&nbsp;modifier in a class declaration to indicate that a class is intended only to be a base class of other classes. Members marked as abstract, or included in an abstract class, must be implemented by classes that derive from the abstract class.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tIn this example, the class&nbsp;<code>Square</code>&nbsp;must provide an implementation of&nbsp;<code>Area</code>&nbsp;because it derives from&nbsp;<code>ShapesClass</code>:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>abstract</span> <span>class</span> <span>ShapesClass</span>\r\n{\r\n    <span><span>abstract</span> <span>public</span> <span>int</span> <span>Area</span>()</span>;\r\n}\r\n\r\n<span>class</span> <span>Square</span> : <span>ShapesClass</span>\r\n{\r\n    <span>int</span> side = <span>0</span>;\r\n\r\n    <span><span>public</span> <span>Square</span>(<span><span>int</span> n</span>)\r\n    </span>{\r\n        side = n;\r\n    }\r\n    <span>// Area method is required to avoid</span>\r\n    <span>// a compile-time error.</span>\r\n    <span><span>public</span> <span>override</span> <span>int</span> <span>Area</span>()\r\n    </span>{\r\n        <span>return</span> side * side;\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>Main</span>() \r\n    </span>{\r\n        Square sq = <span>new</span> Square(<span>12</span>);\r\n        Console.WriteLine(<span>&quot;Area of the square = {0}&quot;</span>, sq.Area());\r\n    }\r\n\r\n    <span>interface</span> <span>I</span>\r\n    {\r\n        <span><span>void</span> <span>M</span>()</span>;\r\n    }\r\n    <span>abstract</span> <span>class</span> <span>C</span> : <span>I</span>\r\n    {\r\n        <span><span>public</span> <span>abstract</span> <span>void</span> <span>M</span>()</span>;\r\n    }\r\n\r\n}\r\n<span>// Output: Area of the square = 144</span>\r\n</code></pre>\r\n<p>\r\n\tAbstract classes have the following features:</p>\r\n<ul>\r\n\t<li>\r\n\t\tAn abstract class cannot be instantiated.</li>\r\n\t<li>\r\n\t\tAn abstract class may contain abstract methods and accessors.</li>\r\n\t<li>\r\n\t\tIt is not possible to modify an abstract class with the&nbsp;sealed&nbsp;modifier because the two modifers have opposite meanings. The&nbsp;<code>sealed</code>&nbsp;modifier prevents a class from being inherited and the&nbsp;<code>abstract</code>&nbsp;modifier requires a class to be inherited.</li>\r\n\t<li>\r\n\t\tA non-abstract class derived from an abstract class must include actual implementations of all inherited abstract methods and accessors.</li>\r\n</ul>\r\n<p>\r\n\tUse the&nbsp;<code>abstract</code>&nbsp;modifier in a method or property declaration to indicate that the method or property does not contain implementation.</p>\r\n<p>\r\n\tAbstract methods have the following features:</p>\r\n<ul>\r\n\t<li>\r\n\t\tAn abstract method is implicitly a virtual method.</li>\r\n\t<li>\r\n\t\tAbstract method declarations are only permitted in abstract classes.</li>\r\n\t<li>\r\n\t\tBecause an abstract method declaration provides no actual implementation, there is no method body; the method declaration simply ends with a semicolon and there are no curly braces ({ }) following the signature. For example:</li>\r\n</ul>\r\n<p>\r\n\t&nbsp;&nbsp;<code>public abstract void MyMethod();&nbsp;&nbsp;</code></p>\r\n<p>\r\n\tThe implementation is provided by a method&nbsp;override, which is a member of a non-abstract class.</p>\r\n<ul>\r\n\t<li>\r\n\t\tIt is an error to use the&nbsp;static&nbsp;or&nbsp;virtual&nbsp;modifiers in an abstract method declaration.</li>\r\n</ul>\r\n<p>\r\n\tAbstract properties behave like abstract methods, except for the differences in declaration and invocation syntax.</p>\r\n<ul>\r\n\t<li>\r\n\t\tIt is an error to use the&nbsp;<code>abstract</code>&nbsp;modifier on a static property.</li>\r\n\t<li>\r\n\t\tAn abstract inherited property can be overridden in a derived class by including a property declaration that uses the&nbsp;override&nbsp;modifier.</li>\r\n</ul>\r\n<p>\r\n\tAn abstract class must provide implementation for all interface members.</p>\r\n<p>\r\n\tAn abstract class that implements an interface might map the interface methods onto abstract methods. For example:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>interface</span> <span>I</span>\r\n{\r\n    <span><span>void</span> <span>M</span>()</span>;\r\n}\r\n<span>abstract</span> <span>class</span> <span>C</span> : <span>I</span>\r\n{\r\n    <span><span>public</span> <span>abstract</span> <span>void</span> <span>M</span>()</span>;\r\n}\r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tIn this example, the class&nbsp;<code>DerivedClass</code>&nbsp;is derived from an abstract class&nbsp;<code>BaseClass</code>. The abstract class contains an abstract method,&nbsp;<code>AbstractMethod</code>, and two abstract properties,&nbsp;<code>X</code>&nbsp;and&nbsp;<code>Y</code>.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>abstract</span> <span>class</span> <span>BaseClass</span>   <span>// Abstract class</span>\r\n{\r\n    <span>protected</span> <span>int</span> _x = <span>100</span>;\r\n    <span>protected</span> <span>int</span> _y = <span>150</span>;\r\n    <span><span>public</span> <span>abstract</span> <span>void</span> <span>AbstractMethod</span>()</span>;   <span>// Abstract method</span>\r\n    <span>public</span> <span>abstract</span> <span>int</span> X    { <span>get</span>; }\r\n    <span>public</span> <span>abstract</span> <span>int</span> Y    { <span>get</span>; }\r\n}\r\n\r\n<span>class</span> <span>DerivedClass</span> : <span>BaseClass</span>\r\n{\r\n    <span><span>public</span> <span>override</span> <span>void</span> <span>AbstractMethod</span>()\r\n    </span>{\r\n        _x++;\r\n        _y++;\r\n    }\r\n\r\n    <span>public</span> <span>override</span> <span>int</span> X   <span>// overriding property</span>\r\n    {\r\n        <span>get</span>\r\n        {\r\n            <span>return</span> _x + <span>10</span>;\r\n        }\r\n    }\r\n\r\n    <span>public</span> <span>override</span> <span>int</span> Y   <span>// overriding property</span>\r\n    {\r\n        <span>get</span>\r\n        {\r\n            <span>return</span> _y + <span>10</span>;\r\n        }\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        DerivedClass o = <span>new</span> DerivedClass();\r\n        o.AbstractMethod();\r\n        Console.WriteLine(<span>&quot;x = {0}, y = {1}&quot;</span>, o.X, o.Y);\r\n    }\r\n}\r\n<span>// Output: x = 111, y = 161</span>\r\n</code></pre>\r\n<p>\r\n\tIn the preceding example, if you attempt to instantiate the abstract class by using a statement like this:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>BaseClass bc = <span>new</span> BaseClass();   <span>// Error  </span>\r\n</code></pre>\r\n<p>\r\n\tYou will get an error saying that the compiler cannot create an instance of the abstract class &#39;BaseClass&#39;.</p>"
          },
          {
            "async": "<p>\r\n\tUse the&nbsp;<code>async</code>&nbsp;modifier to specify that a method,&nbsp;lambda expression, or&nbsp;anonymous method&nbsp;is asynchronous. If you use this modifier on a method or expression, it&#39;s referred to as an&nbsp;<em>async method</em>. The following example defines an async method named&nbsp;<code>ExampleMethodAsync</code>:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>public</span> <span>async</span> Task&lt;<span>int</span>&gt; <span>ExampleMethodAsync</span>()  \r\n</span>{  \r\n    <span>// . . . .  </span>\r\n}  \r\n</code></pre>\r\n<p>\r\n\tIf you&#39;re new to asynchronous programming or do not understand how an async method uses the&nbsp;<code>await</code>&nbsp;keyword to do potentially long-running work without blocking the caller&rsquo;s thread, read the introduction in&nbsp;Asynchronous Programming with async and await. The following code is found inside an async method and calls the&nbsp;HttpClient.GetStringAsync&nbsp;method:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> contents = <span>await</span> httpClient.GetStringAsync(requestUrl);  \r\n</code></pre>\r\n<p>\r\n\tAn async method runs synchronously until it reaches its first&nbsp;<code>await</code>&nbsp;expression, at which point the method is suspended until the awaited task is complete. In the meantime, control returns to the caller of the method, as the example in the next section shows.</p>\r\n<p>\r\n\tIf the method that the&nbsp;<code>async</code>&nbsp;keyword modifies doesn&#39;t contain an&nbsp;<code>await</code>&nbsp;expression or statement, the method executes synchronously. A compiler warning alerts you to any async methods that don&#39;t contain&nbsp;<code>await</code>&nbsp;statements, because that situation might indicate an error. See&nbsp;Compiler Warning (level 1) CS4014.</p>\r\n<p>\r\n\tThe&nbsp;<code>async</code>&nbsp;keyword is contextual in that it&#39;s a keyword only when it modifies a method, a lambda expression, or an anonymous method. In all other contexts, it&#39;s interpreted as an identifier.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example shows the structure and flow of control between an async event handler,&nbsp;<code>StartButton_Click</code>, and an async method,&nbsp;<code>ExampleMethodAsync</code>. The result from the async method is the number of characters of a web page. The code is suitable for a Windows Presentation Foundation (WPF) app or Windows Store app that you create in Visual Studio; see the code comments for setting up the app.</p>\r\n<p>\r\n\tYou can run this code in Visual Studio as a Windows Presentation Foundation (WPF) app or a Windows Store app. You need a Button control named&nbsp;<code>StartButton</code>&nbsp;and a Textbox control named&nbsp;<code>ResultsTextBox</code>. Remember to set the names and handler so that you have something like this:</p>\r\n<div>\r\n\t<span>XAML</span></div>\r\n<pre>\r\n<code><span>&lt;<span>Button</span> <span>Content</span>=<span>&quot;Button&quot;</span> <span>HorizontalAlignment</span>=<span>&quot;Left&quot;</span> <span>Margin</span>=<span>&quot;88,77,0,0&quot;</span> <span>VerticalAlignment</span>=<span>&quot;Top&quot;</span> <span>Width</span>=<span>&quot;75&quot;</span>  \r\n        <span>Click</span>=<span>&quot;StartButton_Click&quot;</span> <span>Name</span>=<span>&quot;StartButton&quot;</span>/&gt;</span>  \r\n<span>&lt;<span>TextBox</span> <span>HorizontalAlignment</span>=<span>&quot;Left&quot;</span> <span>Height</span>=<span>&quot;137&quot;</span> <span>Margin</span>=<span>&quot;88,140,0,0&quot;</span> <span>TextWrapping</span>=<span>&quot;Wrap&quot;</span>   \r\n         <span>Text</span>=<span>&quot;&amp;lt;Enter a URL&amp;gt;&quot;</span> <span>VerticalAlignment</span>=<span>&quot;Top&quot;</span> <span>Width</span>=<span>&quot;310&quot;</span> <span>Name</span>=<span>&quot;ResultsTextBox&quot;</span>/&gt;</span>  \r\n</code></pre>\r\n<p>\r\n\tTo run the code as a WPF app:</p>\r\n<ul>\r\n\t<li>\r\n\t\tPaste this code into the&nbsp;<code>MainWindow</code>&nbsp;class in MainWindow.xaml.cs.</li>\r\n\t<li>\r\n\t\tAdd a reference to System.Net.Http.</li>\r\n\t<li>\r\n\t\tAdd a&nbsp;<code>using</code>&nbsp;directive for System.Net.Http.</li>\r\n</ul>\r\n<p>\r\n\tTo run the code as a Windows Store app:</p>\r\n<ul>\r\n\t<li>\r\n\t\tPaste this code into the&nbsp;<code>MainPage</code>&nbsp;class in MainPage.xaml.cs.</li>\r\n\t<li>\r\n\t\tAdd using directives for System.Net.Http and System.Threading.Tasks.</li>\r\n</ul>\r\n<div>\r\n\t<span>C#</span></div>\r\n<pre>\r\n<code><span><span>private</span> <span>async</span> <span>void</span> <span>StartButton_Click</span>(<span><span>object</span> sender, RoutedEventArgs e</span>)\r\n</span>{\r\n    <span>// ExampleMethodAsync returns a Task&lt;int&gt;, which means that the method  </span>\r\n    <span>// eventually produces an int result. However, ExampleMethodAsync returns  </span>\r\n    <span>// the Task&lt;int&gt; value as soon as it reaches an await.  </span>\r\n    ResultsTextBox.Text += <span>&quot;\\n&quot;</span>;\r\n\r\n    <span>try</span>\r\n    {\r\n        <span>int</span> length = <span>await</span> ExampleMethodAsync();\r\n        <span>// Note that you could put &quot;await ExampleMethodAsync()&quot; in the next line where  </span>\r\n        <span>// &quot;length&quot; is, but due to when &#39;+=&#39; fetches the value of ResultsTextBox, you  </span>\r\n        <span>// would not see the global side effect of ExampleMethodAsync setting the text.  </span>\r\n        ResultsTextBox.Text += String.Format(<span>&quot;Length: {0:N0}\\n&quot;</span>, length);\r\n    }\r\n    <span>catch</span> (Exception)\r\n    {\r\n        <span>// Process the exception if one occurs.  </span>\r\n    }\r\n}\r\n\r\n<span><span>public</span> <span>async</span> Task&lt;<span>int</span>&gt; <span>ExampleMethodAsync</span>()\r\n</span>{\r\n    <span>var</span> httpClient = <span>new</span> HttpClient();\r\n    <span>int</span> exampleInt = (<span>await</span> httpClient.GetStringAsync(<span>&quot;http://msdn.microsoft.com&quot;</span>)).Length;\r\n    ResultsTextBox.Text += <span>&quot;Preparing to finish ExampleMethodAsync.\\n&quot;</span>;\r\n    <span>// After the following return statement, any method that&#39;s awaiting  </span>\r\n    <span>// ExampleMethodAsync (in this case, StartButton_Click) can get the   </span>\r\n    <span>// integer result.  </span>\r\n    <span>return</span> exampleInt;\r\n}\r\n<span>// The example displays the following output:  </span>\r\n<span>// Preparing to finish ExampleMethodAsync.  </span>\r\n<span>// Length: 53292  </span>\r\n</code></pre>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;</p>\r\n</div>\r\n<h2>\r\n\tReturn Types</h2>\r\n<p>\r\n\tAn async method can have the following return types:</p>\r\n<ul>\r\n\t<li>\r\n\t\tTask</li>\r\n\t<li>\r\n\t\tTask&lt;TResult&gt;</li>\r\n\t<li>\r\n\t\tvoid, which should only be used for event handlers.</li>\r\n\t<li>\r\n\t\tStarting with C# 7.0, any type that has an accessible&nbsp;<code>GetAwaiter</code>&nbsp;method. The&nbsp;<code>System.Threading.Tasks.ValueTask&lt;TResult&gt;</code>&nbsp;type is one such implementation. It is available by adding the NuGet package&nbsp;<code>System.Threading.Tasks.Extensions</code>.</li>\r\n</ul>\r\n<p>\r\n\tThe async method can&#39;t declare any&nbsp;in,&nbsp;ref&nbsp;or&nbsp;out&nbsp;parameters, nor can it have a&nbsp;reference return value, but it can call methods that have such parameters.</p>\r\n<p>\r\n\tYou specify&nbsp;<code>Task&lt;TResult&gt;</code>&nbsp;as the return type of an async method if the&nbsp;return&nbsp;statement of the method specifies an operand of type&nbsp;<code>TResult</code>. You use&nbsp;<code>Task</code>&nbsp;if no meaningful value is returned when the method is completed. That is, a call to the method returns a&nbsp;<code>Task</code>, but when the&nbsp;<code>Task</code>&nbsp;is completed, any&nbsp;<code>await</code>&nbsp;expression that&#39;s awaiting the&nbsp;<code>Task</code>&nbsp;evaluates to&nbsp;<code>void</code>.</p>\r\n<p>\r\n\tYou use the&nbsp;<code>void</code>&nbsp;return type primarily to define event handlers, which require that return type. The caller of a&nbsp;<code>void</code>-returning async method can&#39;t await it and can&#39;t catch exceptions that the method throws.</p>\r\n<p>\r\n\tStarting with C# 7.0, you return another type, typically a value type, that has a&nbsp;<code>GetAwaiter</code>&nbsp;method to minimize memory allocations in performance-critical sections of code.</p>"
          },
          {
            "const": "<p>\r\n\tYou use the&nbsp;<code>const</code>&nbsp;keyword to declare a constant field or a constant local. Constant fields and locals aren&#39;t variables and may not be modified. Constants can be numbers, Boolean values, strings, or a null reference. Don&rsquo;t create a constant to represent information that you expect to change at any time. For example, don&rsquo;t use a constant field to store the price of a service, a product version number, or the brand name of a company. These values can change over time, and because compilers propagate constants, other code compiled with your libraries will have to be recompiled to see the changes. See also the&nbsp;readonly&nbsp;keyword. For example:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>const</span> <span>int</span> x = <span>0</span>;\r\n<span>public</span> <span>const</span> <span>double</span> gravitationalConstant = <span>6.673e-11</span>;\r\n<span>private</span> <span>const</span> <span>string</span> productName = <span>&quot;Visual C#&quot;</span>;\r\n</code></pre>\r\n<h2>\r\n\tRemarks</h2>\r\n<p>\r\n\tThe type of a constant declaration specifies the type of the members that the declaration introduces. The initializer of a constant local or a constant field must be a constant expression that can be implicitly converted to the target type.</p>\r\n<p>\r\n\tA constant expression is an expression that can be fully evaluated at compile time. Therefore, the only possible values for constants of reference types are&nbsp;<code>string</code>&nbsp;and a null reference.</p>\r\n<p>\r\n\tThe constant declaration can declare multiple constants, such as:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>const</span> <span>double</span> x = <span>1.0</span>, y = <span>2.0</span>, z = <span>3.0</span>;\r\n</code></pre>\r\n<p>\r\n\tThe&nbsp;<code>static</code>&nbsp;modifier is not allowed in a constant declaration.</p>\r\n<p>\r\n\tA constant can participate in a constant expression, as follows:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>const</span> <span>int</span> c1 = <span>5</span>;\r\n<span>public</span> <span>const</span> <span>int</span> c2 = c1 + <span>100</span>;\r\n</code></pre>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tThe&nbsp;readonly&nbsp;keyword differs from the&nbsp;<code>const</code>&nbsp;keyword. A&nbsp;<code>const</code>&nbsp;field can only be initialized at the declaration of the field. A&nbsp;<code>readonly</code>&nbsp;field can be initialized either at the declaration or in a constructor. Therefore,&nbsp;<code>readonly</code>&nbsp;fields can have different values depending on the constructor used. Also, although a&nbsp;<code>const</code>&nbsp;field is a compile-time constant, the&nbsp;<code>readonly</code>&nbsp;field can be used for run-time constants, as in this line:&nbsp;<code>public static readonly uint l1 = (uint)DateTime.Now.Ticks;</code></p>\r\n</div>\r\n<h2>\r\n\tExample</h2>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>class</span> <span>ConstTest</span> \r\n{\r\n    <span>class</span> <span>SampleClass</span>\r\n    {\r\n        <span>public</span> <span>int</span> x;\r\n        <span>public</span> <span>int</span> y;\r\n        <span>public</span> <span>const</span> <span>int</span> c1 = <span>5</span>;\r\n        <span>public</span> <span>const</span> <span>int</span> c2 = c1 + <span>5</span>;\r\n\r\n        <span><span>public</span> <span>SampleClass</span>(<span><span>int</span> p1, <span>int</span> p2</span>) \r\n        </span>{\r\n            x = p1; \r\n            y = p2;\r\n        }\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        SampleClass mC = <span>new</span> SampleClass(<span>11</span>, <span>22</span>);\r\n        Console.WriteLine(<span>&quot;x = {0}, y = {1}&quot;</span>, mC.x, mC.y);\r\n        Console.WriteLine(<span>&quot;c1 = {0}, c2 = {1}&quot;</span>, \r\n                          SampleClass.c1, SampleClass.c2);\r\n    }\r\n}\r\n<span>/* Output\r\n    x = 11, y = 22\r\n    c1 = 5, c2 = 10\r\n*/</span>\r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThis example demonstrates how to use constants as local variables.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>class</span> <span>SealedTest</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>const</span> <span>int</span> c = <span>707</span>;\r\n        Console.WriteLine(<span>&quot;My local constant = {0}&quot;</span>, c);\r\n    }\r\n}\r\n<span>// Output: My local constant = 707</span></code></pre>"
          },
          {
            "event": "<p>\r\n\tThe&nbsp;<code>event</code>&nbsp;keyword is used to declare an event in a publisher class.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example shows how to declare and raise an event that uses&nbsp;EventHandler&nbsp;as the underlying delegate type. For the complete code example that also shows how to use the generic&nbsp;EventHandler&lt;TEventArgs&gt;&nbsp;delegate type and how to subscribe to an event and create an event handler method, see&nbsp;How to: Publish Events that Conform to .NET Framework Guidelines.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>class</span> <span>SampleEventArgs</span>\r\n{\r\n    <span><span>public</span> <span>SampleEventArgs</span>(<span><span>string</span> s</span>) </span>{ Text = s; }\r\n    <span>public</span> String Text { <span>get</span>; } <span>// readonly</span>\r\n}\r\n\r\n<span>public</span> <span>class</span> <span>Publisher</span>\r\n{\r\n    <span>// Declare the delegate (if using non-generic pattern).</span>\r\n    <span><span>public</span> <span>delegate</span> <span>void</span> <span>SampleEventHandler</span>(<span><span>object</span> sender, SampleEventArgs e</span>)</span>;\r\n\r\n    <span>// Declare the event.</span>\r\n    <span>public</span> <span>event</span> SampleEventHandler SampleEvent;\r\n\r\n    <span>// Wrap the event in a protected virtual method</span>\r\n    <span>// to enable derived classes to raise the event.</span>\r\n    <span><span>protected</span> <span>virtual</span> <span>void</span> <span>RaiseSampleEvent</span>()\r\n    </span>{\r\n        <span>// Raise the event by using the () operator.</span>\r\n        <span>if</span> (SampleEvent != <span>null</span>)\r\n            SampleEvent(<span>this</span>, <span>new</span> SampleEventArgs(<span>&quot;Hello&quot;</span>));\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tEvents are a special kind of multicast delegate that can only be invoked from within the class or struct where they are declared (the publisher class). If other classes or structs subscribe to the event, their event handler methods will be called when the publisher class raises the event. For more information and code examples, see&nbsp;Events&nbsp;and&nbsp;Delegates.</p>\r\n<p>\r\n\tEvents can be marked as&nbsp;public,&nbsp;private,&nbsp;protected,&nbsp;internal,&nbsp;protected internal&nbsp;or&nbsp;private protected. These access modifiers define how users of the class can access the event. For more information, see&nbsp;Access Modifiers.</p>\r\n<h2>\r\n\tKeywords and Events</h2>\r\n<p>\r\n\tThe following keywords apply to events.</p>\r\n<div>\r\n\t<table>\r\n\t\t<thead>\r\n\t\t\t<tr>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tKeyword&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tDescription</th>\r\n\t\t\t\t<th>\r\n\t\t\t\t\tFor more information</th>\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tstatic</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tMakes the event available to callers at any time, even if no instance of the class exists.</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t<p>\r\n\t\t\t\t\t\t&nbsp; &nbsp;Static Classes and Static Class Members</p>\r\n\t\t\t\t</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tvirtual</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tAllows derived classes to override the event behavior by using the&nbsp;override&nbsp;keyword.</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Inheritance</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tsealed</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tSpecifies that for derived classes it is no longer virtual.</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t\t<tr>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tabstract</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\tThe compiler will not generate the&nbsp;<code>add</code>&nbsp;and&nbsp;<code>remove</code>&nbsp;event accessor blocks and therefore derived classes must provide their own implementation.</td>\r\n\t\t\t\t<td>\r\n\t\t\t\t\t&nbsp;</td>\r\n\t\t\t</tr>\r\n\t\t</tbody>\r\n\t</table>\r\n</div>\r\n<p>\r\n\tAn event may be declared as a static event by using the&nbsp;static&nbsp;keyword. This makes the event available to callers at any time, even if no instance of the class exists. For more information, see&nbsp;Static Classes and Static Class Members.</p>\r\n<p>\r\n\tAn event can be marked as a virtual event by using the&nbsp;virtual&nbsp;keyword. This enables derived classes to override the event behavior by using the&nbsp;override&nbsp;keyword. For more information, see&nbsp;Inheritance. An event overriding a virtual event can also be&nbsp;sealed, which specifies that for derived classes it is no longer virtual. Lastly, an event can be declared&nbsp;abstract, which means that the compiler will not generate the&nbsp;<code>add</code>&nbsp;and&nbsp;<code>remove</code>&nbsp;event accessor blocks. Therefore derived classes must provide their own implementation.</p>"
          },
          {
            "extern": "<p>\r\n\tThe&nbsp;<code>extern</code>&nbsp;modifier is used to declare a method that is implemented externally. A common use of the&nbsp;<code>extern</code>&nbsp;modifier is with the&nbsp;<code>DllImport</code>&nbsp;attribute when you are using Interop services to call into unmanaged code. In this case, the method must also be declared as&nbsp;<code>static</code>, as shown in the following example:</p>\r\n<pre>\r\n<code>[<span>DllImport(<span>&quot;avifil32.dll&quot;</span>)</span>]\r\n<span><span>private</span> <span>static</span> <span>extern</span> <span>void</span> <span>AVIFileInit</span>()</span>;\r\n</code></pre>\r\n<p>\r\n\tThe&nbsp;<code>extern</code>&nbsp;keyword can also define an external assembly alias, which makes it possible to reference different versions of the same component from within a single assembly. For more information, see&nbsp;extern alias.</p>\r\n<p>\r\n\tIt is an error to use the&nbsp;abstract&nbsp;and&nbsp;<code>extern</code>&nbsp;modifiers together to modify the same member. Using the&nbsp;<code>extern</code>&nbsp;modifier means that the method is implemented outside the C# code, whereas using the&nbsp;<code>abstract</code>&nbsp;modifier means that the method implementation is not provided in the class.</p>\r\n<p>\r\n\tThe extern keyword has more limited uses in C# than in C++. To compare the C# keyword with the C++ keyword, see Using extern to Specify Linkage in the C++ Language Reference.</p>\r\n<h2>\r\n\tExample 1</h2>\r\n<p>\r\n\tIn this example, the program receives a string from the user and displays it inside a message box. The program uses the&nbsp;<code>MessageBox</code>&nbsp;method imported from the User32.dll library.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>//using System.Runtime.InteropServices;</span>\r\n<span>class</span> <span>ExternTest</span>\r\n{\r\n    [<span>DllImport(<span>&quot;User32.dll&quot;</span>, CharSet=CharSet.Unicode)</span>] \r\n    <span><span>public</span> <span>static</span> <span>extern</span> <span>int</span> <span>MessageBox</span>(<span>IntPtr h, <span>string</span> m, <span>string</span> c, <span>int</span> type</span>)</span>;\r\n\r\n    <span><span>static</span> <span>int</span> <span>Main</span>()\r\n    </span>{\r\n        <span>string</span> myString;\r\n        Console.Write(<span>&quot;Enter your message: &quot;</span>);\r\n        myString = Console.ReadLine();\r\n        <span>return</span> MessageBox((IntPtr)<span>0</span>, myString, <span>&quot;My Message Box&quot;</span>, <span>0</span>);\r\n    }\r\n\r\n}\r\n</code></pre>\r\n<h2>\r\n\tExample 2</h2>\r\n<p>\r\n\tThis example illustrates a C# program that calls into a C library (a native DLL).</p>\r\n<ol>\r\n\t<li>\r\n\t\tCreate the following C file and name it&nbsp;<code>cmdll.c</code>:</li>\r\n</ol>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// cmdll.c</span>\r\n<span>// Compile with: -LD</span>\r\n<span>int</span> __declspec(dllexport) SampleMethod(<span>int</span> i)\r\n{\r\n  <span>return</span> i*<span>10</span>;\r\n}\r\n</code></pre>\r\n<ol>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tOpen a Visual Studio x64 (or x32) Native Tools Command Prompt window from the Visual Studio installation directory and compile the&nbsp;<code>cmdll.c</code>&nbsp;file by typing&nbsp;<span>cl -LD cmdll.c</span>&nbsp;at the command prompt.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tIn the same directory, create the following C# file and name it&nbsp;<code>cm.cs</code>:</p>\r\n\t</li>\r\n</ol>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// cm.cs</span>\r\n<span>using</span> System;\r\n<span>using</span> System.Runtime.InteropServices;\r\n<span>public</span> <span>class</span> <span>MainClass</span>\r\n{\r\n    [<span>DllImport(<span>&quot;Cmdll.dll&quot;</span>)</span>]\r\n      <span><span>public</span> <span>static</span> <span>extern</span> <span>int</span> <span>SampleMethod</span>(<span><span>int</span> x</span>)</span>;\r\n\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        Console.WriteLine(<span>&quot;SampleMethod() returns {0}.&quot;</span>, SampleMethod(<span>5</span>));\r\n    }\r\n}\r\n</code></pre>\r\n<ol>\r\n\t<li>\r\n\t\tOpen a Visual Studio x64 (or x32) Native Tools Command Prompt window from the Visual Studio installation directory and compile the&nbsp;<code>cm.cs</code>&nbsp;file by typing:</li>\r\n</ol>\r\n<blockquote>\r\n\t<p>\r\n\t\t<span>csc cm.cs</span>&nbsp;(for the x64 command prompt) &mdash;or&mdash;&nbsp;<span>csc -platform:x86 cm.cs</span>&nbsp;(for the x32 command prompt)</p>\r\n</blockquote>\r\n<p>\r\n\tThis will create the executable file&nbsp;<code>cm.exe</code>.</p>\r\n<ol>\r\n\t<li>\r\n\t\tRun&nbsp;<code>cm.exe</code>. The&nbsp;<code>SampleMethod</code>&nbsp;method passes the value 5 to the DLL file, which returns the value multiplied by 10. The program produces the following output:</li>\r\n</ol>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>SampleMethod() returns 50.</code></pre>"
          },
          {
            "in (Generic Modifier)": "<p>\r\n\tFor generic type parameters, the&nbsp;<code>in</code>&nbsp;keyword specifies that the type parameter is contravariant. You can use the&nbsp;<code>in</code>&nbsp;keyword in generic interfaces and delegates.</p>\r\n<p>\r\n\tContravariance enables you to use a less derived type than that specified by the generic parameter. This allows for implicit conversion of classes that implement variant interfaces and implicit conversion of delegate types. Covariance and contravariance in generic type parameters are supported for reference types, but they are not supported for value types.</p>\r\n<p>\r\n\tA type can be declared contravariant in a generic interface or delegate only if it defines the type of a method&#39;s parameters and not of a method&#39;s return type.&nbsp;<code>In</code>,&nbsp;<code>ref</code>, and&nbsp;<code>out</code>&nbsp;parameters must be invariant, meaning they are neither covariant or contravariant.</p>\r\n<p>\r\n\tAn interface that has a contravariant type parameter allows its methods to accept arguments of less derived types than those specified by the interface type parameter. For example, in the&nbsp;IComparer&lt;T&gt;interface, type T is contravariant, you can assign an object of the&nbsp;<code>IComparer&lt;Person&gt;</code>&nbsp;type to an object of the&nbsp;<code>IComparer&lt;Employee&gt;</code>&nbsp;type without using any special conversion methods if&nbsp;<code>Employee</code>&nbsp;inherits&nbsp;<code>Person</code>.</p>\r\n<p>\r\n\tA contravariant delegate can be assigned another delegate of the same type, but with a less derived generic type parameter.</p>\r\n<p>\r\n\tFor more information, see&nbsp;Covariance and Contravariance.</p>\r\n<h2>\r\n\tContravariant generic interface</h2>\r\n<p>\r\n\tThe following example shows how to declare, extend, and implement a contravariant generic interface. It also shows how you can use implicit conversion for classes that implement this interface.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Contravariant interface.</span>\r\n<span>interface</span> <span>IContravariant</span>&lt;<span>in</span> <span>A</span>&gt; { }\r\n\r\n<span>// Extending contravariant interface.</span>\r\n<span>interface</span> <span>IExtContravariant</span>&lt;<span>in</span> <span>A</span>&gt; : <span>IContravariant</span>&lt;<span>A</span>&gt; { }\r\n\r\n<span>// Implementing contravariant interface.</span>\r\n<span>class</span> <span>Sample</span>&lt;<span>A</span>&gt; : <span>IContravariant</span>&lt;<span>A</span>&gt; { }\r\n\r\n<span>class</span> <span>Program</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Test</span>()\r\n    </span>{\r\n        IContravariant&lt;Object&gt; iobj = <span>new</span> Sample&lt;Object&gt;();\r\n        IContravariant&lt;String&gt; istr = <span>new</span> Sample&lt;String&gt;();\r\n\r\n        <span>// You can assign iobj to istr because</span>\r\n        <span>// the IContravariant interface is contravariant.</span>\r\n        istr = iobj;\r\n    }\r\n}\r\n</code></pre>\r\n<h2>\r\n\tContravariant generic delegate</h2>\r\n<p>\r\n\tThe following example shows how to declare, instantiate, and invoke a contravariant generic delegate. It also shows how you can implicitly convert a delegate type.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Contravariant delegate.</span>\r\n<span>public</span> <span>delegate</span> <span>void</span> DContravariant&lt;<span>in</span> A&gt;(A argument);\r\n\r\n<span>// Methods that match the delegate signature.</span>\r\n<span><span>public</span> <span>static</span> <span>void</span> <span>SampleControl</span>(<span>Control control</span>)\r\n</span>{ }\r\n<span><span>public</span> <span>static</span> <span>void</span> <span>SampleButton</span>(<span>Button button</span>)\r\n</span>{ }\r\n\r\n<span><span>public</span> <span>void</span> <span>Test</span>()\r\n</span>{\r\n\r\n    <span>// Instantiating the delegates with the methods.</span>\r\n    DContravariant&lt;Control&gt; dControl = SampleControl;\r\n    DContravariant&lt;Button&gt; dButton = SampleButton;\r\n\r\n    <span>// You can assign dControl to dButton</span>\r\n    <span>// because the DContravariant delegate is contravariant.</span>\r\n    dButton = dControl;\r\n\r\n    <span>// Invoke the delegate.</span>\r\n    dButton(<span>new</span> Button()); \r\n}</code></pre>"
          },
          {
            "out (Generic modifier)": "<p>\r\n\tFor generic type parameters, the&nbsp;<code>out</code>&nbsp;keyword specifies that the type parameter is covariant. You can use the&nbsp;<code>out</code>&nbsp;keyword in generic interfaces and delegates.</p>\r\n<p>\r\n\tCovariance enables you to use a more derived type than that specified by the generic parameter. This allows for implicit conversion of classes that implement variant interfaces and implicit conversion of delegate types. Covariance and contravariance are supported for reference types, but they are not supported for value types.</p>\r\n<p>\r\n\tAn interface that has a covariant type parameter enables its methods to return more derived types than those specified by the type parameter. For example, because in .NET Framework 4, in&nbsp;IEnumerable&lt;T&gt;, type T is covariant, you can assign an object of the&nbsp;<code>IEnumerable(Of String)</code>&nbsp;type to an object of the&nbsp;<code>IEnumerable(Of Object)</code>&nbsp;type without using any special conversion methods.</p>\r\n<p>\r\n\tA covariant delegate can be assigned another delegate of the same type, but with a more derived generic type parameter.</p>\r\n<p>\r\n\tFor more information, see&nbsp;Covariance and Contravariance.</p>\r\n<h2>\r\n\tExample - covariant generic interface</h2>\r\n<p>\r\n\tThe following example shows how to declare, extend, and implement a covariant generic interface. It also shows how to use implicit conversion for classes that implement a covariant interface.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Covariant interface.</span>\r\n<span>interface</span> <span>ICovariant</span>&lt;<span>out</span> <span>R</span>&gt; { }\r\n\r\n<span>// Extending covariant interface.</span>\r\n<span>interface</span> <span>IExtCovariant</span>&lt;<span>out</span> <span>R</span>&gt; : <span>ICovariant</span>&lt;<span>R</span>&gt; { }\r\n\r\n<span>// Implementing covariant interface.</span>\r\n<span>class</span> <span>Sample</span>&lt;<span>R</span>&gt; : <span>ICovariant</span>&lt;<span>R</span>&gt; { }\r\n\r\n<span>class</span> <span>Program</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Test</span>()\r\n    </span>{\r\n        ICovariant&lt;Object&gt; iobj = <span>new</span> Sample&lt;Object&gt;();\r\n        ICovariant&lt;String&gt; istr = <span>new</span> Sample&lt;String&gt;();\r\n\r\n        <span>// You can assign istr to iobj because</span>\r\n        <span>// the ICovariant interface is covariant.</span>\r\n        iobj = istr;\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tIn a generic interface, a type parameter can be declared covariant if it satisfies the following conditions:</p>\r\n<ul>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tThe type parameter is used only as a return type of interface methods and not used as a type of method arguments.</p>\r\n\t\t<div>\r\n\t\t\t<p>\r\n\t\t\t\t&nbsp;Note</p>\r\n\t\t\t<p>\r\n\t\t\t\tThere is one exception to this rule. If in a covariant interface you have a contravariant generic delegate as a method parameter, you can use the covariant type as a generic type parameter for this delegate. For more information about covariant and contravariant generic delegates, see&nbsp;Variance in Delegates&nbsp;and&nbsp;Using Variance for Func and Action Generic Delegates.</p>\r\n\t\t</div>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tThe type parameter is not used as a generic constraint for the interface methods.</p>\r\n\t</li>\r\n</ul>\r\n<h2>\r\n\tExample - covariant generic delegate</h2>\r\n<p>\r\n\tThe following example shows how to declare, instantiate, and invoke a covariant generic delegate. It also shows how to implicitly convert delegate types.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Covariant delegate.</span>\r\n<span>public</span> <span>delegate</span> R DCovariant&lt;<span>out</span> R&gt;();\r\n\r\n<span>// Methods that match the delegate signature.</span>\r\n<span><span>public</span> <span>static</span> Control <span>SampleControl</span>()\r\n</span>{ <span>return</span> <span>new</span> Control(); }\r\n\r\n<span><span>public</span> <span>static</span> Button <span>SampleButton</span>()\r\n</span>{ <span>return</span> <span>new</span> Button(); }\r\n\r\n<span><span>public</span> <span>void</span> <span>Test</span>()\r\n</span>{            \r\n    <span>// Instantiate the delegates with the methods.</span>\r\n    DCovariant&lt;Control&gt; dControl = SampleControl;\r\n    DCovariant&lt;Button&gt; dButton = SampleButton;\r\n\r\n    <span>// You can assign dButton to dControl</span>\r\n    <span>// because the DCovariant delegate is covariant.</span>\r\n    dControl = dButton;\r\n\r\n    <span>// Invoke the delegate.</span>\r\n    dControl(); \r\n}\r\n</code></pre>\r\n<p>\r\n\tIn a generic delegate, a type can be declared covariant if it is used only as a method return type and not used for method arguments.</p>"
          },
          {
            "override": "<p>\r\n\tThe&nbsp;<code>override</code>&nbsp;modifier is required to extend or modify the abstract or virtual implementation of an inherited method, property, indexer, or event.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tIn this example, the&nbsp;<code>Square</code>&nbsp;class must provide an overridden implementation of&nbsp;<code>Area</code>&nbsp;because&nbsp;<code>Area</code>&nbsp;is inherited from the abstract&nbsp;<code>ShapesClass</code>:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>abstract</span> <span>class</span> <span>ShapesClass</span>\r\n{\r\n    <span><span>abstract</span> <span>public</span> <span>int</span> <span>Area</span>()</span>;\r\n}\r\n\r\n<span>class</span> <span>Square</span> : <span>ShapesClass</span>\r\n{\r\n    <span>int</span> side = <span>0</span>;\r\n\r\n    <span><span>public</span> <span>Square</span>(<span><span>int</span> n</span>)\r\n    </span>{\r\n        side = n;\r\n    }\r\n    <span>// Area method is required to avoid</span>\r\n    <span>// a compile-time error.</span>\r\n    <span><span>public</span> <span>override</span> <span>int</span> <span>Area</span>()\r\n    </span>{\r\n        <span>return</span> side * side;\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>Main</span>() \r\n    </span>{\r\n        Square sq = <span>new</span> Square(<span>12</span>);\r\n        Console.WriteLine(<span>&quot;Area of the square = {0}&quot;</span>, sq.Area());\r\n    }\r\n\r\n    <span>interface</span> <span>I</span>\r\n    {\r\n        <span><span>void</span> <span>M</span>()</span>;\r\n    }\r\n    <span>abstract</span> <span>class</span> <span>C</span> : <span>I</span>\r\n    {\r\n        <span><span>public</span> <span>abstract</span> <span>void</span> <span>M</span>()</span>;\r\n    }\r\n\r\n}\r\n<span>// Output: Area of the square = 144</span>\r\n</code></pre>\r\n<p>\r\n\tAn&nbsp;<code>override</code>&nbsp;method provides a new implementation of a member that is inherited from a base class. The method that is overridden by an&nbsp;<code>override</code>&nbsp;declaration is known as the overridden base method. The overridden base method must have the same signature as the&nbsp;<code>override</code>&nbsp;method. For information about inheritance, see&nbsp;Inheritance.</p>\r\n<p>\r\n\tYou cannot override a non-virtual or static method. The overridden base method must be&nbsp;<code>virtual</code>,&nbsp;<code>abstract</code>, or&nbsp;<code>override</code>.</p>\r\n<p>\r\n\tAn&nbsp;<code>override</code>&nbsp;declaration cannot change the accessibility of the&nbsp;<code>virtual</code>&nbsp;method. Both the&nbsp;<code>override</code>method and the&nbsp;<code>virtual</code>&nbsp;method must have the same&nbsp;access level modifier.</p>\r\n<p>\r\n\tYou cannot use the&nbsp;<code>new</code>,&nbsp;<code>static</code>, or&nbsp;<code>virtual</code>&nbsp;modifiers to modify an&nbsp;<code>override</code>&nbsp;method.</p>\r\n<p>\r\n\tAn overriding property declaration must specify exactly the same access modifier, type, and name as the inherited property, and the overridden property must be&nbsp;<code>virtual</code>,&nbsp;<code>abstract</code>, or&nbsp;<code>override</code>.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThis example defines a base class named&nbsp;<code>Employee</code>, and a derived class named&nbsp;<code>SalesEmployee</code>. The&nbsp;<code>SalesEmployee</code>&nbsp;class includes an extra field,&nbsp;<code>salesbonus</code>, and overrides the method&nbsp;<code>CalculatePay</code>&nbsp;in order to take it into account.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>TestOverride</span>\r\n{\r\n    <span>public</span> <span>class</span> <span>Employee</span>\r\n    {\r\n        <span>public</span> <span>string</span> name;\r\n\r\n        <span>// Basepay is defined as protected, so that it may be </span>\r\n        <span>// accessed only by this class and derived classes.</span>\r\n        <span>protected</span> <span>decimal</span> basepay;\r\n\r\n        <span>// Constructor to set the name and basepay values.</span>\r\n        <span><span>public</span> <span>Employee</span>(<span><span>string</span> name, <span>decimal</span> basepay</span>)\r\n        </span>{\r\n            <span>this</span>.name = name;\r\n            <span>this</span>.basepay = basepay;\r\n        }\r\n\r\n        <span>// Declared virtual so it can be overridden.</span>\r\n        <span><span>public</span> <span>virtual</span> <span>decimal</span> <span>CalculatePay</span>()\r\n        </span>{\r\n            <span>return</span> basepay;\r\n        }\r\n    }\r\n\r\n    <span>// Derive a new class from Employee.</span>\r\n    <span>public</span> <span>class</span> <span>SalesEmployee</span> : <span>Employee</span>\r\n    {\r\n        <span>// New field that will affect the base pay.</span>\r\n        <span>private</span> <span>decimal</span> salesbonus;\r\n\r\n        <span>// The constructor calls the base-class version, and</span>\r\n        <span>// initializes the salesbonus field.</span>\r\n        <span><span>public</span> <span>SalesEmployee</span>(<span><span>string</span> name, <span>decimal</span> basepay, \r\n                  <span>decimal</span> salesbonus</span>) : <span>base</span>(<span>name, basepay</span>)\r\n        </span>{\r\n            <span>this</span>.salesbonus = salesbonus;\r\n        }\r\n\r\n        <span>// Override the CalculatePay method </span>\r\n        <span>// to take bonus into account.</span>\r\n        <span><span>public</span> <span>override</span> <span>decimal</span> <span>CalculatePay</span>()\r\n        </span>{\r\n            <span>return</span> basepay + salesbonus;\r\n        }\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>// Create some new employees.</span>\r\n        SalesEmployee employee1 = <span>new</span> SalesEmployee(<span>&quot;Alice&quot;</span>, \r\n                      <span>1000</span>, <span>500</span>);\r\n        Employee employee2 = <span>new</span> Employee(<span>&quot;Bob&quot;</span>, <span>1200</span>);\r\n\r\n        Console.WriteLine(<span>&quot;Employee4 &quot;</span> + employee1.name + \r\n                  <span>&quot; earned: &quot;</span> + employee1.CalculatePay());\r\n        Console.WriteLine(<span>&quot;Employee4 &quot;</span> + employee2.name + \r\n                  <span>&quot; earned: &quot;</span> + employee2.CalculatePay());\r\n    }\r\n}\r\n<span>/*\r\n    Output:\r\n    Employee4 Alice earned: 1500\r\n    Employee4 Bob earned: 1200\r\n*/</span></code></pre>"
          },
          {
            "readonly": "<p>\r\n\tThe&nbsp;<code>readonly</code>&nbsp;keyword is a modifier that can be used in three contexts:</p>\r\n<ul>\r\n\t<li>\r\n\t\tIn a&nbsp;field declaration,&nbsp;<code>readonly</code>&nbsp;indicates that assignment to the field can only occur as part of the declaration or in a constructor in the same class.</li>\r\n\t<li>\r\n\t\tIn a&nbsp;<code>readonly struct</code>&nbsp;definition,&nbsp;<code>readonly</code>&nbsp;indicates that the&nbsp;<code>struct</code>&nbsp;is immutable.</li>\r\n\t<li>\r\n\t\tIn a&nbsp;<code>ref readonly</code>&nbsp;method return, the&nbsp;<code>readonly</code>&nbsp;modifier indicates that method returns a reference and writes are not allowed to that reference.</li>\r\n</ul>\r\n<p>\r\n\tThe final two contexts were added in C# 7.2.</p>\r\n<h2>\r\n\tReadonly field example</h2>\r\n<p>\r\n\tIn this example, the value of the field&nbsp;<code>year</code>&nbsp;cannot be changed in the method&nbsp;<code>ChangeYear</code>, even though it is assigned a value in the class constructor:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>Age</span>\r\n{\r\n    <span>readonly</span> <span>int</span> year;\r\n    Age(<span>int</span> year)\r\n    {\r\n        <span>this</span>.year = year;\r\n    }\r\n    <span><span>void</span> <span>ChangeYear</span>()\r\n    </span>{\r\n        <span>//year = 1967; // Compile error if uncommented.</span>\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tYou can assign a value to a&nbsp;<code>readonly</code>&nbsp;field only in the following contexts:</p>\r\n<ul>\r\n\t<li>\r\n\t\tWhen the variable is initialized in the declaration, for example:</li>\r\n</ul>\r\n<pre>\r\n<code><span>public</span> <span>readonly</span> <span>int</span> y = <span>5</span>;\r\n\r\n\r\n\r\n</code></pre>\r\n<div>\r\n\t<ul>\r\n\t\t<li>\r\n\t\t\tIn an instance constructor of the class that contains the instance field declaration.</li>\r\n\t\t<li>\r\n\t\t\tIn the static constructor of the class that contains the static field declaration.</li>\r\n\t</ul>\r\n\t<p>\r\n\t\t<span style=\"color: rgb(0, 0, 0); font-family: &quot;Segoe UI&quot;, SegoeUI, &quot;Segoe WP&quot;, &quot;Helvetica Neue&quot;, Helvetica, Tahoma, Arial, sans-serif; font-size: 16px;\">These constructor contexts are also the only contexts in which it is valid to pass a&nbsp;</span><code style=\"line-height: 19px; -webkit-font-smoothing: auto; font-family: monospace, monospace; font-size: 0.8rem; direction: ltr; border-radius: 2px; display: inline-block; padding: 3px 7px; border: 1px solid var(--border); background-color: var(--body-background-medium); box-sizing: inherit; color: rgb(0, 0, 0);\">readonly</code><span style=\"color: rgb(0, 0, 0); font-family: &quot;Segoe UI&quot;, SegoeUI, &quot;Segoe WP&quot;, &quot;Helvetica Neue&quot;, Helvetica, Tahoma, Arial, sans-serif; font-size: 16px;\">&nbsp;field as an&nbsp;</span><font face=\"Segoe UI, SegoeUI, Segoe WP, Helvetica Neue, Helvetica, Tahoma, Arial, sans-serif\"><span style=\"cursor: pointer; box-sizing: inherit; font-size: 16px;\">o</span></font><font face=\"Segoe UI, SegoeUI, Segoe WP, Helvetica Neue, Helvetica, Tahoma, Arial, sans-serif\"><span style=\"cursor: pointer; box-sizing: inherit; font-size: 16px;\">ut</span></font><span style=\"color: rgb(0, 0, 0); font-family: &quot;Segoe UI&quot;, SegoeUI, &quot;Segoe WP&quot;, &quot;Helvetica Neue&quot;, Helvetica, Tahoma, Arial, sans-serif; font-size: 16px;\">&nbsp;or&nbsp;</span><font face=\"Segoe UI, SegoeUI, Segoe WP, Helvetica Neue, Helvetica, Tahoma, Arial, sans-serif\"><span style=\"cursor: pointer; box-sizing: inherit; font-size: 16px;\">re</span></font><font face=\"Segoe UI, SegoeUI, Segoe WP, Helvetica Neue, Helvetica, Tahoma, Arial, sans-serif\"><span style=\"cursor: pointer; box-sizing: inherit; font-size: 16px;\">f</span></font><span style=\"color: rgb(0, 0, 0); font-family: &quot;Segoe UI&quot;, SegoeUI, &quot;Segoe WP&quot;, &quot;Helvetica Neue&quot;, Helvetica, Tahoma, Arial, sans-serif; font-size: 16px;\">&nbsp;parameter.</span></p>\r\n\t<p>\r\n\t\tThe&nbsp;<code>readonly</code>&nbsp;keyword is different from the&nbsp;const&nbsp;keyword. A&nbsp;<code>const</code>&nbsp;field can only be initialized at the declaration of the field. A&nbsp;<code>readonly</code>&nbsp;field can be initialized either at the declaration or in a constructor. Therefore,&nbsp;<code>readonly</code>&nbsp;fields can have different values depending on the constructor used. Also, while a&nbsp;<code>const</code>&nbsp;field is a compile-time constant, the&nbsp;<code>readonly</code>&nbsp;field can be used for runtime constants as in the following example:</p>\r\n\t<p>\r\n\t\t&nbsp;</p>\r\n</div>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>static</span> <span>readonly</span> <span>uint</span> timeStamp = (<span>uint</span>)DateTime.Now.Ticks;</code></pre>\r\n<pre>\r\n<code><span>class</span> <span>SampleClass</span>\r\n{\r\n    <span>public</span> <span>int</span> x;\r\n    <span>// Initialize a readonly field</span>\r\n    <span>public</span> <span>readonly</span> <span>int</span> y = <span>25</span>;\r\n    <span>public</span> <span>readonly</span> <span>int</span> z;\r\n\r\n    <span><span>public</span> <span>SampleClass</span>()\r\n    </span>{\r\n        <span>// Initialize a readonly instance field</span>\r\n        z = <span>24</span>;\r\n    }\r\n\r\n    <span><span>public</span> <span>SampleClass</span>(<span><span>int</span> p1, <span>int</span> p2, <span>int</span> p3</span>)\r\n    </span>{\r\n        x = p1;\r\n        y = p2;\r\n        z = p3;\r\n    }\r\n\r\n    <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        SampleClass p1 = <span>new</span> SampleClass(<span>11</span>, <span>21</span>, <span>32</span>);   <span>// OK</span>\r\n        Console.WriteLine(<span>$&quot;p1: x=<span>{p1.x}</span>, y=<span>{p1.y}</span>, z=<span>{p1.z}</span>&quot;</span>);\r\n        SampleClass p2 = <span>new</span> SampleClass();\r\n        p2.x = <span>55</span>;   <span>// OK</span>\r\n        Console.WriteLine(<span>$&quot;p2: x=<span>{p2.x}</span>, y=<span>{p2.y}</span>, z=<span>{p2.z}</span>&quot;</span>);\r\n    }\r\n    <span>/*\r\n     Output:\r\n        p1: x=11, y=21, z=32\r\n        p2: x=55, y=25, z=24\r\n    */</span>\r\n}\r\n</code></pre>\r\n<p>\r\n\tIn the preceding example, if you use a statement like the following example:</p>\r\n<p>\r\n\t<code>p2.y = 66; // Error</code></p>\r\n<p>\r\n\tyou will get the compiler error message:</p>\r\n<p>\r\n\t<code>A readonly field cannot be assigned to (except in a constructor or a variable initializer)</code></p>\r\n<h2>\r\n\tReadonly struct example</h2>\r\n<p>\r\n\tThe&nbsp;<code>readonly</code>&nbsp;modifier on a&nbsp;<code>struct</code>&nbsp;definition declares that the struct is&nbsp;<span>immutable</span>. Every instance field of the&nbsp;<code>struct</code>&nbsp;must be marked&nbsp;<code>readonly</code>, as shown in the following example:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>readonly</span> <span>struct</span> Point\r\n{\r\n    <span>public</span> <span>double</span> X { <span>get</span>; }\r\n    <span>public</span> <span>double</span> Y { <span>get</span>; }\r\n\r\n    <span><span>public</span> <span>Point</span>(<span><span>double</span> x, <span>double</span> y</span>) </span>=&gt; (X, Y) = (x, y);\r\n\r\n    <span><span>public</span> <span>override</span> <span>string</span> <span>ToString</span>() </span>=&gt; <span>$&quot;(<span>{X}</span>, <span>{Y}</span>)&quot;</span>;\r\n}\r\n</code></pre>\r\n<p>\r\n\tThe preceding example uses&nbsp;readonly auto properties&nbsp;to declare its storage. That instructs the compiler to create&nbsp;<code>readonly</code>&nbsp;backing fields for those properties. You could also declare&nbsp;<code>readonly</code>fields directly:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>readonly</span> <span>struct</span> Point\r\n{\r\n    <span>public</span> <span>readonly</span> <span>double</span> X;\r\n    <span>public</span> <span>readonly</span> <span>double</span> Y;\r\n\r\n    <span><span>public</span> <span>Point</span>(<span><span>double</span> x, <span>double</span> y</span>) </span>=&gt; (X, Y) = (x, y);\r\n\r\n    <span><span>public</span> <span>override</span> <span>string</span> <span>ToString</span>() </span>=&gt; <span>$&quot;(<span>{X}</span>, <span>{Y}</span>)&quot;</span>;\r\n}\r\n</code></pre>\r\n<p>\r\n\tAdding a field not marked&nbsp;<code>readonly</code>&nbsp;generates compiler error&nbsp;<code>CS8340</code>: &quot;Instance fields of readonly structs must be readonly.&quot;</p>\r\n<h2>\r\n\tRef readonly return example</h2>\r\n<p>\r\n\tThe&nbsp;<code>readonly</code>&nbsp;modifier on a&nbsp;<code>ref return</code>&nbsp;indicates that the returned reference cannot be modified. The following example returns a reference to the origin. It uses the&nbsp;<code>readonly</code>&nbsp;modifier to indicate that callers cannot modify the origin:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>private</span> <span>static</span> <span>readonly</span> Point origin = <span>new</span> Point(<span>0</span>, <span>0</span>);\r\n<span>public</span> <span>static</span> <span>ref</span> <span>readonly</span> Point Origin =&gt; <span>ref</span> origin;\r\n</code></pre>\r\n<p>\r\n\tThe type returned doesn&#39;t need to be a&nbsp;<code>readonly struct</code>. Any type that can be returned by&nbsp;<code>ref</code>&nbsp;can be returned by&nbsp;<code>ref readonly</code></p>"
          },
          {
            "sealed": "<p>\r\n\tWhen applied to a class, the&nbsp;<code>sealed</code>&nbsp;modifier prevents other classes from inheriting from it. In the following example, class&nbsp;<code>B</code>&nbsp;inherits from class&nbsp;<code>A</code>, but no class can inherit from class&nbsp;<code>B</code>.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>A</span> {}\r\n<span>sealed</span> <span>class</span> <span>B</span> : <span>A</span> {}\r\n</code></pre>\r\n<p>\r\n\tYou can also use the&nbsp;<code>sealed</code>&nbsp;modifier on a method or property that overrides a virtual method or property in a base class. This enables you to allow classes to derive from your class and prevent them from overriding specific virtual methods or properties.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tIn the following example,&nbsp;<code>Z</code>&nbsp;inherits from&nbsp;<code>Y</code>&nbsp;but&nbsp;<code>Z</code>&nbsp;cannot override the virtual function&nbsp;<code>F</code>&nbsp;that is declared in&nbsp;<code>X</code>&nbsp;and sealed in&nbsp;<code>Y</code>.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>X</span>\r\n{\r\n    <span><span>protected</span> <span>virtual</span> <span>void</span> <span>F</span>() </span>{ Console.WriteLine(<span>&quot;X.F&quot;</span>); }\r\n    <span><span>protected</span> <span>virtual</span> <span>void</span> <span>F2</span>() </span>{ Console.WriteLine(<span>&quot;X.F2&quot;</span>); }\r\n}\r\n\r\n<span>class</span> <span>Y</span> : <span>X</span>\r\n{\r\n    <span><span>sealed</span> <span>protected</span> <span>override</span> <span>void</span> <span>F</span>() </span>{ Console.WriteLine(<span>&quot;Y.F&quot;</span>); }\r\n    <span><span>protected</span> <span>override</span> <span>void</span> <span>F2</span>() </span>{ Console.WriteLine(<span>&quot;Y.F2&quot;</span>); }\r\n}\r\n\r\n<span>class</span> <span>Z</span> : <span>Y</span>\r\n{\r\n    <span>// Attempting to override F causes compiler error CS0239.</span>\r\n    <span>// protected override void F() { Console.WriteLine(&quot;Z.F&quot;); }</span>\r\n\r\n    <span>// Overriding F2 is allowed.</span>\r\n    <span><span>protected</span> <span>override</span> <span>void</span> <span>F2</span>() </span>{ Console.WriteLine(<span>&quot;Z.F2&quot;</span>); }\r\n}\r\n</code></pre>\r\n<p>\r\n\tWhen you define new methods or properties in a class, you can prevent deriving classes from overriding them by not declaring them as&nbsp;virtual.</p>\r\n<p>\r\n\tIt is an error to use the&nbsp;abstract&nbsp;modifier with a sealed class, because an abstract class must be inherited by a class that provides an implementation of the abstract methods or properties.</p>\r\n<p>\r\n\tWhen applied to a method or property, the&nbsp;<code>sealed</code>&nbsp;modifier must always be used with&nbsp;override.</p>\r\n<p>\r\n\tBecause structs are implicitly sealed, they cannot be inherited.</p>\r\n<p>\r\n\tFor more information, see&nbsp;Inheritance.</p>\r\n<p>\r\n\tFor more examples, see&nbsp;Abstract and Sealed Classes and Class Members.</p>\r\n<h2>\r\n\tExample</h2>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>sealed</span> <span>class</span> <span>SealedClass</span>\r\n{\r\n    <span>public</span> <span>int</span> x;\r\n    <span>public</span> <span>int</span> y;\r\n}\r\n\r\n<span>class</span> <span>SealedTest2</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        SealedClass sc = <span>new</span> SealedClass();\r\n        sc.x = <span>110</span>;\r\n        sc.y = <span>150</span>;\r\n        Console.WriteLine(<span>&quot;x = {0}, y = {1}&quot;</span>, sc.x, sc.y);\r\n    }\r\n}\r\n<span>// Output: x = 110, y = 150</span>\r\n</code></pre>\r\n<p>\r\n\tIn the previous example, you might try to inherit from the sealed class by using the following statement:</p>\r\n<p>\r\n\t<code>class MyDerivedC: SealedClass {} // Error</code></p>\r\n<p>\r\n\tThe result is an error message:</p>\r\n<p>\r\n\t<code>&#39;MyDerivedC&#39;: cannot derive from sealed type &#39;SealedClass&#39;</code></p>\r\n<h2>\r\n\tRemarks</h2>\r\n<p>\r\n\tTo determine whether to seal a class, method, or property, you should generally consider the following two points:</p>\r\n<ul>\r\n\t<li>\r\n\t\tThe potential benefits that deriving classes might gain through the ability to customize your class.</li>\r\n\t<li>\r\n\t\tThe potential that deriving classes could modify your classes in such a way that they would no longer work correctly or as expected.</li>\r\n</ul>"
          },
          {
            "static": "<p>\r\n\tUse the&nbsp;<code>static</code>&nbsp;modifier to declare a static member, which belongs to the type itself rather than to a specific object. The&nbsp;<code>static</code>&nbsp;modifier can be used with classes, fields, methods, properties, operators, events, and constructors, but it cannot be used with indexers, finalizers, or types other than classes.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following class is declared as&nbsp;<code>static</code>&nbsp;and contains only&nbsp;<code>static</code>&nbsp;methods:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>static</span> <span>class</span> <span>CompanyEmployee</span>\r\n{\r\n    <span><span>public</span> <span>static</span> <span>void</span> <span>DoSomething</span>() </span>{ <span>/*...*/</span> }\r\n    <span><span>public</span> <span>static</span> <span>void</span> <span>DoSomethingElse</span>() </span>{ <span>/*...*/</span>  }\r\n}\r\n</code></pre>\r\n<p>\r\n\tA constant or type declaration is implicitly a static member.</p>\r\n<p>\r\n\tA static member cannot be referenced through an instance. Instead, it is referenced through the type name. For example, consider the following class:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>class</span> <span>MyBaseC</span>\r\n{\r\n    <span>public</span> <span>struct</span> MyStruct\r\n    {\r\n        <span>public</span> <span>static</span> <span>int</span> x = <span>100</span>;\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tTo refer to the static member&nbsp;<code>x</code>, use the fully qualified name,&nbsp;<code>MyBaseC.MyStruct.x</code>, unless the member is accessible from the same scope:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>Console.WriteLine(MyBaseC.MyStruct.x);\r\n</code></pre>\r\n<p>\r\n\tWhile an instance of a class contains a separate copy of all instance fields of the class, there is only one copy of each static field.</p>\r\n<p>\r\n\tIt is not possible to use&nbsp;this&nbsp;to reference static methods or property accessors.</p>\r\n<p>\r\n\tIf the&nbsp;<code>static</code>&nbsp;keyword is applied to a class, all the members of the class must be static.</p>\r\n<p>\r\n\tClasses and static classes may have static constructors. Static constructors are called at some point between when the program starts and the class is instantiated.</p>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tThe&nbsp;<code>static</code>&nbsp;keyword has more limited uses than in C++. To compare with the C++ keyword, see&nbsp;Storage classes (C++).</p>\r\n</div>\r\n<p>\r\n\tTo demonstrate static members, consider a class that represents a company employee. Assume that the class contains a method to count employees and a field to store the number of employees. Both the method and the field do not belong to any instance employee. Instead they belong to the company class. Therefore, they should be declared as static members of the class.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThis example reads the name and ID of a new employee, increments the employee counter by one, and displays the information for the new employee and the new number of employees. For simplicity, this program reads the current number of employees from the keyboard. In a real application, this information should be read from a file.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>class</span> <span>Employee4</span>\r\n{\r\n    <span>public</span> <span>string</span> id;\r\n    <span>public</span> <span>string</span> name;\r\n\r\n    <span><span>public</span> <span>Employee4</span>()\r\n    </span>{\r\n    }\r\n\r\n    <span><span>public</span> <span>Employee4</span>(<span><span>string</span> name, <span>string</span> id</span>)\r\n    </span>{\r\n        <span>this</span>.name = name;\r\n        <span>this</span>.id = id;\r\n    }\r\n\r\n    <span>public</span> <span>static</span> <span>int</span> employeeCounter;\r\n\r\n    <span><span>public</span> <span>static</span> <span>int</span> <span>AddEmployee</span>()\r\n    </span>{\r\n        <span>return</span> ++employeeCounter;\r\n    }\r\n}\r\n\r\n<span>class</span> <span>MainClass</span> : <span>Employee4</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        Console.Write(<span>&quot;Enter the employee&#39;s name: &quot;</span>);\r\n        <span>string</span> name = Console.ReadLine();\r\n        Console.Write(<span>&quot;Enter the employee&#39;s ID: &quot;</span>);\r\n        <span>string</span> id = Console.ReadLine();\r\n\r\n        <span>// Create and configure the employee object:</span>\r\n        Employee4 e = <span>new</span> Employee4(name, id);\r\n        Console.Write(<span>&quot;Enter the current number of employees: &quot;</span>);\r\n        <span>string</span> n = Console.ReadLine();\r\n        Employee4.employeeCounter = Int32.Parse(n);\r\n        Employee4.AddEmployee();\r\n\r\n        <span>// Display the new information:</span>\r\n        Console.WriteLine(<span>&quot;Name: {0}&quot;</span>, e.name);\r\n        Console.WriteLine(<span>&quot;ID:   {0}&quot;</span>, e.id);\r\n        Console.WriteLine(<span>&quot;New Number of Employees: {0}&quot;</span>,\r\n                  Employee4.employeeCounter);\r\n    }\r\n}\r\n<span>/*\r\nInput:\r\nMatthias Berndt\r\nAF643G\r\n15\r\n * \r\nSample Output:\r\nEnter the employee&#39;s name: Matthias Berndt\r\nEnter the employee&#39;s ID: AF643G\r\nEnter the current number of employees: 15\r\nName: Matthias Berndt\r\nID:   AF643G\r\nNew Number of Employees: 16\r\n*/</span>\r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThis example shows that although you can initialize a static field by using another static field not yet declared, the results will be undefined until you explicitly assign a value to the static field.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>Test</span>\r\n{\r\n    <span>static</span> <span>int</span> x = y;\r\n    <span>static</span> <span>int</span> y = <span>5</span>;\r\n\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        Console.WriteLine(Test.x);\r\n        Console.WriteLine(Test.y);\r\n\r\n        Test.x = <span>99</span>;\r\n        Console.WriteLine(Test.x);\r\n    }\r\n}\r\n<span>/*\r\nOutput:\r\n    0\r\n    5\r\n    99\r\n*/</span>\r\n</code></pre>"
          },
          {
            "unsafe": "<p>\r\n\tThe&nbsp;<code>unsafe</code>&nbsp;keyword denotes an unsafe context, which is required for any operation involving pointers.</p>\r\n<p>\r\n\tYou can use the&nbsp;<code>unsafe</code>&nbsp;modifier in the declaration of a type or a member. The entire textual extent of the type or member is therefore considered an unsafe context. For example, the following is a method declared with the&nbsp;<code>unsafe</code>&nbsp;modifier:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>unsafe</span> <span>static</span> <span>void</span> <span>FastCopy</span>(<span><span>byte</span>[] src, <span>byte</span>[] dst, <span>int</span> count</span>)  \r\n</span>{  \r\n    <span>// Unsafe context: can use pointers here.  </span>\r\n}  \r\n</code></pre>\r\n<p>\r\n\tThe scope of the unsafe context extends from the parameter list to the end of the method, so pointers can also be used in the parameter list:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>unsafe</span> <span>static</span> <span>void</span> <span>FastCopy</span> (<span> <span>byte</span>* ps, <span>byte</span>* pd, <span>int</span> count </span>) </span>{...}  \r\n</code></pre>\r\n<p>\r\n\tYou can also use an unsafe block to enable the use of an unsafe code inside this block. For example:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>unsafe</span>  \r\n{  \r\n    <span>// Unsafe context: can use pointers here.  </span>\r\n}  \r\n</code></pre>\r\n<p>\r\n\tTo compile unsafe code, you must specify the&nbsp;/unsafe&nbsp;compiler option. Unsafe code is not verifiable by the common language runtime.</p>\r\n<h2>\r\n\tExample</h2>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// compile with: -unsafe</span>\r\n\r\n<span>class</span> <span>UnsafeTest</span>\r\n{\r\n   <span>// Unsafe method: takes pointer to int:</span>\r\n   <span><span>unsafe</span> <span>static</span> <span>void</span> <span>SquarePtrParam</span>(<span><span>int</span>* p</span>)\r\n   </span>{\r\n      *p *= *p;\r\n   }\r\n\r\n   <span><span>unsafe</span> <span>static</span> <span>void</span> <span>Main</span>()\r\n   </span>{\r\n      <span>int</span> i = <span>5</span>;\r\n      <span>// Unsafe method: uses address-of operator (&amp;):</span>\r\n      SquarePtrParam(&amp;i);\r\n      Console.WriteLine(i);\r\n   }\r\n}\r\n<span>// Output: 25</span></code></pre>"
          },
          {
            "virtual": "<p>\r\n\tThe&nbsp;<code>virtual</code>&nbsp;keyword is used to modify a method, property, indexer, or event declaration and allow for it to be overridden in a derived class. For example, this method can be overridden by any class that inherits it:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>public</span> <span>virtual</span> <span>double</span> <span>Area</span>()   \r\n</span>{  \r\n    <span>return</span> x * y;  \r\n}  \r\n</code></pre>\r\n<p>\r\n\tThe implementation of a virtual member can be changed by an&nbsp;overriding member&nbsp;in a derived class. For more information about how to use the&nbsp;<code>virtual</code>&nbsp;keyword, see&nbsp;Versioning with the Override and New Keywords&nbsp;and&nbsp;Knowing When to Use Override and New Keywords.</p>\r\n<h2>\r\n\tRemarks</h2>\r\n<p>\r\n\tWhen a virtual method is invoked, the run-time type of the object is checked for an overriding member. The overriding member in the most derived class is called, which might be the original member, if no derived class has overridden the member.</p>\r\n<p>\r\n\tBy default, methods are non-virtual. You cannot override a non-virtual method.</p>\r\n<p>\r\n\tYou cannot use the&nbsp;<code>virtual</code>&nbsp;modifier with the&nbsp;<code>static</code>,&nbsp;<code>abstract</code>,&nbsp;<code>private</code>, or&nbsp;<code>override</code>&nbsp;modifiers. The following example shows a virtual property:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>   <span>class</span> <span>MyBaseClass</span>\r\n   {\r\n       <span>// virtual auto-implemented property. Overrides can only</span>\r\n       <span>// provide specialized behavior if they implement get and set accessors.</span>\r\n       <span>public</span> <span>virtual</span> <span>string</span> Name { <span>get</span>; <span>set</span>; }\r\n\r\n       <span>// ordinary virtual property with backing field</span>\r\n       <span>private</span> <span>int</span> num;\r\n       <span>public</span> <span>virtual</span> <span>int</span> Number\r\n       {\r\n           <span>get</span> { <span>return</span> num; }\r\n           <span>set</span> { num = <span>value</span>; }\r\n       }\r\n   }\r\n\r\n  \r\n   <span>class</span> <span>MyDerivedClass</span> : <span>MyBaseClass</span>\r\n   {\r\n       <span>private</span> <span>string</span> name;\r\n\r\n      <span>// Override auto-implemented property with ordinary property</span>\r\n      <span>// to provide specialized accessor behavior.</span>\r\n       <span>public</span> <span>override</span> <span>string</span> Name\r\n       {\r\n           <span>get</span>\r\n           {\r\n               <span>return</span> name;\r\n           }\r\n           <span>set</span>\r\n           {\r\n               <span>if</span> (<span>value</span> != String.Empty)\r\n               {\r\n                   name = <span>value</span>;\r\n               }\r\n               <span>else</span>\r\n               {\r\n                   name = <span>&quot;Unknown&quot;</span>;\r\n               }\r\n           }\r\n       }\r\n\r\n   }\r\n</code></pre>\r\n<p>\r\n\tVirtual properties behave like abstract methods, except for the differences in declaration and invocation syntax.</p>\r\n<ul>\r\n\t<li>\r\n\t\tIt is an error to use the&nbsp;<code>virtual</code>&nbsp;modifier on a static property.</li>\r\n\t<li>\r\n\t\tA virtual inherited property can be overridden in a derived class by including a property declaration that uses the&nbsp;<code>override</code>&nbsp;modifier.</li>\r\n</ul>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tIn this example, the&nbsp;<code>Shape</code>&nbsp;class contains the two coordinates&nbsp;<code>x</code>,&nbsp;<code>y</code>, and the&nbsp;<code>Area()</code>&nbsp;virtual method. Different shape classes such as&nbsp;<code>Circle</code>,&nbsp;<code>Cylinder</code>, and&nbsp;<code>Sphere</code>&nbsp;inherit the&nbsp;<code>Shape</code>&nbsp;class, and the surface area is calculated for each figure. Each derived class has its own override implementation of&nbsp;<code>Area()</code>.</p>\r\n<p>\r\n\tNotice that the inherited classes&nbsp;<code>Circle</code>,&nbsp;<code>Sphere</code>, and&nbsp;<code>Cylinder</code>&nbsp;all use constructors that initialize the base class, as shown in the following declaration.</p>\r\n<p>\r\n\t&nbsp;</p>\r\n<pre>\r\n<code><span><span>public</span> <span>Cylinder</span>(<span><span>double</span> r, <span>double</span> h</span>): <span>base</span>(<span>r, h</span>) </span>{}  \r\n</code></pre>\r\n<p>\r\n\tThe following program calculates and displays the appropriate area for each figure by invoking the appropriate implementation of the&nbsp;<code>Area()</code>&nbsp;method, according to the object that is associated with the method.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>TestClass</span>\r\n{\r\n    <span>public</span> <span>class</span> <span>Shape</span>\r\n    {\r\n        <span>public</span> <span>const</span> <span>double</span> PI = Math.PI;\r\n        <span>protected</span> <span>double</span> x, y;\r\n        <span><span>public</span> <span>Shape</span>()\r\n        </span>{\r\n        }\r\n        <span><span>public</span> <span>Shape</span>(<span><span>double</span> x, <span>double</span> y</span>)\r\n        </span>{\r\n            <span>this</span>.x = x;\r\n            <span>this</span>.y = y;\r\n        }\r\n\r\n        <span><span>public</span> <span>virtual</span> <span>double</span> <span>Area</span>()\r\n        </span>{\r\n            <span>return</span> x * y;\r\n        }\r\n    }\r\n\r\n    <span>public</span> <span>class</span> <span>Circle</span> : <span>Shape</span>\r\n    {\r\n        <span><span>public</span> <span>Circle</span>(<span><span>double</span> r</span>) : <span>base</span>(<span>r, <span>0</span></span>)\r\n        </span>{\r\n        }\r\n\r\n        <span><span>public</span> <span>override</span> <span>double</span> <span>Area</span>()\r\n        </span>{\r\n            <span>return</span> PI * x * x;\r\n        }\r\n    }\r\n\r\n    <span>class</span> <span>Sphere</span> : <span>Shape</span>\r\n    {\r\n        <span><span>public</span> <span>Sphere</span>(<span><span>double</span> r</span>) : <span>base</span>(<span>r, <span>0</span></span>)\r\n        </span>{\r\n        }\r\n\r\n        <span><span>public</span> <span>override</span> <span>double</span> <span>Area</span>()\r\n        </span>{\r\n            <span>return</span> <span>4</span> * PI * x * x;\r\n        }\r\n    }\r\n\r\n    <span>class</span> <span>Cylinder</span> : <span>Shape</span>\r\n    {\r\n        <span><span>public</span> <span>Cylinder</span>(<span><span>double</span> r, <span>double</span> h</span>) : <span>base</span>(<span>r, h</span>)\r\n        </span>{\r\n        }\r\n\r\n        <span><span>public</span> <span>override</span> <span>double</span> <span>Area</span>()\r\n        </span>{\r\n            <span>return</span> <span>2</span> * PI * x * x + <span>2</span> * PI * x * y;\r\n        }\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>double</span> r = <span>3.0</span>, h = <span>5.0</span>;\r\n        Shape c = <span>new</span> Circle(r);\r\n        Shape s = <span>new</span> Sphere(r);\r\n        Shape l = <span>new</span> Cylinder(r, h);\r\n        <span>// Display results:</span>\r\n        Console.WriteLine(<span>&quot;Area of Circle   = {0:F2}&quot;</span>, c.Area());\r\n        Console.WriteLine(<span>&quot;Area of Sphere   = {0:F2}&quot;</span>, s.Area());\r\n        Console.WriteLine(<span>&quot;Area of Cylinder = {0:F2}&quot;</span>, l.Area());\r\n        }\r\n    }\r\n    <span>/*\r\n        Output:\r\n        Area of Circle   = 28.27\r\n        Area of Sphere   = 113.10\r\n        Area of Cylinder = 150.80\r\n    */</span></code></pre>"
          },
          {
            "volatile": "<p>\r\n\tThe&nbsp;<code>volatile</code>&nbsp;keyword indicates that a field might be modified by multiple threads that are executing at the same time. The compiler, the runtime system, and even hardware may rearrange reads and writes to memory locations for performance reasons. Fields that are declared&nbsp;<code>volatile</code>&nbsp;are not subject to these optimizations. Adding the&nbsp;<code>volatile</code>&nbsp;modifier ensures that all threads will observe volatile writes performed by any other thread in the order in which they were performed. There is no guarantee of a single total ordering of volatile writes as seen from all threads of execution.</p>\r\n<p>\r\n\tThe&nbsp;<code>volatile</code>&nbsp;keyword can be applied to fields of these types:</p>\r\n<ul>\r\n\t<li>\r\n\t\tReference types.</li>\r\n\t<li>\r\n\t\tPointer types (in an unsafe context). Note that although the pointer itself can be volatile, the object that it points to cannot. In other words, you cannot declare a &quot;pointer to volatile.&quot;</li>\r\n\t<li>\r\n\t\tSimple types such as&nbsp;<code>sbyte</code>,&nbsp;<code>byte</code>,&nbsp;<code>short</code>,&nbsp;<code>ushort</code>,&nbsp;<code>int</code>,&nbsp;<code>uint</code>,&nbsp;<code>char</code>,&nbsp;<code>float</code>, and&nbsp;<code>bool</code>.</li>\r\n\t<li>\r\n\t\tAn&nbsp;<code>enum</code>&nbsp;type with one of the following base types:&nbsp;<code>byte</code>,&nbsp;<code>sbyte</code>,&nbsp;<code>short</code>,&nbsp;<code>ushort</code>,&nbsp;<code>int</code>, or&nbsp;<code>uint</code>.</li>\r\n\t<li>\r\n\t\tGeneric type parameters known to be reference types.</li>\r\n\t<li>\r\n\t\tIntPtr&nbsp;and&nbsp;UIntPtr.</li>\r\n</ul>\r\n<p>\r\n\tOther types, including&nbsp;<code>double</code>&nbsp;and&nbsp;<code>long</code>, cannot be marked&nbsp;<code>volatile</code>&nbsp;because reads and writes to fields of those types cannot be guaranteed to be atomic. To protect multi-threaded access to those types of fields, use the&nbsp;Interlocked&nbsp;class members or protect access using the&nbsp;<code>lock</code>&nbsp;statement.</p>\r\n<p>\r\n\tThe&nbsp;<code>volatile</code>&nbsp;keyword can only be applied to fields of a&nbsp;<code>class</code>&nbsp;or&nbsp;<code>struct</code>. Local variables cannot be declared&nbsp;<code>volatile</code>.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example shows how to declare a public field variable as&nbsp;<code>volatile</code>.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>VolatileTest</span>\r\n{\r\n    <span>public</span> <span>volatile</span> <span>int</span> sharedStorage;\r\n\r\n    <span><span>public</span> <span>void</span> <span>Test</span>(<span><span>int</span> _i</span>)\r\n    </span>{\r\n        sharedStorage = _i;\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tThe following example demonstrates how an auxiliary or worker thread can be created and used to perform processing in parallel with that of the primary thread.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>class</span> <span>Worker</span>\r\n{\r\n    <span>// This method is called when the thread is started.</span>\r\n    <span><span>public</span> <span>void</span> <span>DoWork</span>()\r\n    </span>{\r\n        <span>while</span> (!_shouldStop)\r\n        {\r\n            Console.WriteLine(<span>&quot;Worker thread: working...&quot;</span>);\r\n        }\r\n        Console.WriteLine(<span>&quot;Worker thread: terminating gracefully.&quot;</span>);\r\n    }\r\n    <span><span>public</span> <span>void</span> <span>RequestStop</span>()\r\n    </span>{\r\n        _shouldStop = <span>true</span>;\r\n    }\r\n    <span>// Keyword volatile is used as a hint to the compiler that this data</span>\r\n    <span>// member is accessed by multiple threads.</span>\r\n    <span>private</span> <span>volatile</span> <span>bool</span> _shouldStop;\r\n}\r\n\r\n<span>public</span> <span>class</span> <span>WorkerThreadExample</span>\r\n{\r\n    <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>// Create the worker thread object. This does not start the thread.</span>\r\n        Worker workerObject = <span>new</span> Worker();\r\n        Thread workerThread = <span>new</span> Thread(workerObject.DoWork);\r\n\r\n        <span>// Start the worker thread.</span>\r\n        workerThread.Start();\r\n        Console.WriteLine(<span>&quot;Main thread: starting worker thread...&quot;</span>);\r\n\r\n        <span>// Loop until the worker thread activates.</span>\r\n        <span>while</span> (!workerThread.IsAlive)\r\n            ;\r\n\r\n        <span>// Put the main thread to sleep for 1 millisecond to</span>\r\n        <span>// allow the worker thread to do some work.</span>\r\n        Thread.Sleep(<span>1</span>);\r\n\r\n        <span>// Request that the worker thread stop itself.</span>\r\n        workerObject.RequestStop();\r\n\r\n        <span>// Use the Thread.Join method to block the current thread </span>\r\n        <span>// until the object&#39;s thread terminates.</span>\r\n        workerThread.Join();\r\n        Console.WriteLine(<span>&quot;Main thread: worker thread has terminated.&quot;</span>);\r\n    }\r\n    <span>// Sample output:</span>\r\n    <span>// Main thread: starting worker thread...</span>\r\n    <span>// Worker thread: working...</span>\r\n    <span>// Worker thread: working...</span>\r\n    <span>// Worker thread: working...</span>\r\n    <span>// Worker thread: working...</span>\r\n    <span>// Worker thread: working...</span>\r\n    <span>// Worker thread: working...</span>\r\n    <span>// Worker thread: terminating gracefully.</span>\r\n    <span>// Main thread: worker thread has terminated.</span>\r\n}\r\n</code></pre>\r\n<p>\r\n\tWith the&nbsp;<code>volatile</code>&nbsp;modifier added to the declaration of&nbsp;<code>_shouldStop</code>&nbsp;in place, you&#39;ll always get the same results (similar to the excerpt shown in the preceding code). However, without that modifier on the&nbsp;<code>_shouldStop</code>&nbsp;member, the behavior is unpredictable. The&nbsp;<code>DoWork</code>&nbsp;method may optimize the member access, resulting in reading stale data. Because of the nature of multi-threaded programming, the number of stale reads is unpredictable. Different runs of the program will produce somewhat different results.</p>"
          },
          {
            "if-else": "<p>\r\n\tAn&nbsp;<code>if</code>&nbsp;statement identifies which statement to run based on the value of a Boolean expression. In the following example, the&nbsp;<code>bool</code>&nbsp;variable&nbsp;<code>result</code>&nbsp;is set to&nbsp;<code>true</code>&nbsp;and then checked in the&nbsp;<code>if</code>statement. The output is&nbsp;<code>The variable is set to true.</code>.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>bool</span> condition = <span>true</span>;\r\n\r\n<span>if</span> (condition)\r\n{\r\n    Console.WriteLine(<span>&quot;The variable is set to true.&quot;</span>);\r\n}\r\n<span>else</span>\r\n{\r\n    Console.WriteLine(<span>&quot;The variable is set to false.&quot;</span>);\r\n}\r\n</code></pre>\r\n<p>\r\n\tYou can run the examples in this topic by placing them in the&nbsp;<code>Main</code>&nbsp;method of a console app.</p>\r\n<p>\r\n\tAn&nbsp;<code>if</code>&nbsp;statement in C# can take two forms, as the following example shows.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// if-else statement</span>\r\n<span>if</span> (condition)\r\n{\r\n    then-statement;\r\n}\r\n<span>else</span>\r\n{\r\n    <span>else</span>-statement;\r\n}\r\n<span>// Next statement in the program.</span>\r\n\r\n<span>// if statement without an else</span>\r\n<span>if</span> (condition)\r\n{\r\n    then-statement;\r\n}\r\n<span>// Next statement in the program.</span>\r\n</code></pre>\r\n<p>\r\n\tIn an&nbsp;<code>if-else</code>&nbsp;statement, if&nbsp;<code>condition</code>&nbsp;evaluates to true, the&nbsp;<code>then-statement</code>&nbsp;runs. If&nbsp;<code>condition</code>&nbsp;is false, the&nbsp;<code>else-statement</code>&nbsp;runs. Because&nbsp;<code>condition</code>&nbsp;can&rsquo;t be simultaneously true and false, the&nbsp;<code>then-statement</code>&nbsp;and the&nbsp;<code>else-statement</code>&nbsp;of an&nbsp;<code>if-else</code>&nbsp;statement can never both run. After the&nbsp;<code>then-statement</code>&nbsp;or the&nbsp;<code>else-statement</code>&nbsp;runs, control is transferred to the next statement after the&nbsp;<code>if</code>&nbsp;statement.</p>\r\n<p>\r\n\tIn an&nbsp;<code>if</code>&nbsp;statement that doesn&rsquo;t include an&nbsp;<code>else</code>&nbsp;statement, if&nbsp;<code>condition</code>&nbsp;is true, the&nbsp;<code>then-statement</code>&nbsp;runs. If&nbsp;<code>condition</code>&nbsp;is false, control is transferred to the next statement after the&nbsp;<code>if</code>&nbsp;statement.</p>\r\n<p>\r\n\tBoth the&nbsp;<code>then-statement</code>&nbsp;and the&nbsp;<code>else-statement</code>&nbsp;can consist of a single statement or multiple statements that are enclosed in braces (<code>{}</code>). For a single statement, the braces are optional but recommended.</p>\r\n<p>\r\n\tThe statement or statements in the&nbsp;<code>then-statement</code>&nbsp;and the&nbsp;<code>else-statement</code>&nbsp;can be of any kind, including another&nbsp;<code>if</code>&nbsp;statement nested inside the original&nbsp;<code>if</code>&nbsp;statement. In nested&nbsp;<code>if</code>statements, each&nbsp;<code>else</code>&nbsp;clause belongs to the last&nbsp;<code>if</code>&nbsp;that doesn&rsquo;t have a corresponding&nbsp;<code>else</code>. In the following example,&nbsp;<code>Result1</code>&nbsp;appears if both&nbsp;<code>m &gt; 10</code>&nbsp;and&nbsp;<code>n &gt; 20</code>&nbsp;evaluate to true. If&nbsp;<code>m &gt; 10</code>&nbsp;is true but&nbsp;<code>n &gt; 20</code>&nbsp;is false,&nbsp;<code>Result2</code>&nbsp;appears.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Try with m = 12 and then with m = 8.</span>\r\n<span>int</span> m = <span>12</span>;\r\n<span>int</span> n = <span>18</span>;\r\n\r\n<span>if</span> (m &gt; <span>10</span>)\r\n    <span>if</span> (n &gt; <span>20</span>)\r\n    {\r\n        Console.WriteLine(<span>&quot;Result1&quot;</span>);\r\n    }\r\n    <span>else</span>\r\n    {\r\n        Console.WriteLine(<span>&quot;Result2&quot;</span>);\r\n    }\r\n</code></pre>\r\n<p>\r\n\tIf, instead, you want&nbsp;<code>Result2</code>&nbsp;to appear when&nbsp;<code>(m &gt; 10)</code>&nbsp;is false, you can specify that association by using braces to establish the start and end of the nested&nbsp;<code>if</code>&nbsp;statement, as the following example shows.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Try with m = 12 and then with m = 8.</span>\r\n<span>if</span> (m &gt; <span>10</span>)\r\n{\r\n    <span>if</span> (n &gt; <span>20</span>)\r\n        Console.WriteLine(<span>&quot;Result1&quot;</span>);\r\n}\r\n<span>else</span>\r\n{\r\n    Console.WriteLine(<span>&quot;Result2&quot;</span>);\r\n}\r\n</code></pre>\r\n<p>\r\n\t<code>Result2</code>&nbsp;appears if the condition&nbsp;<code>(m &gt; 10)</code>&nbsp;evaluates to false.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tIn the following example, you enter a character from the keyboard, and the program uses a nested&nbsp;<code>if</code>&nbsp;statement to determine whether the input character is an alphabetic character. If the input character is an alphabetic character, the program checks whether the input character is lowercase or uppercase. A message appears for each case.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>Console.Write(<span>&quot;Enter a character: &quot;</span>);\r\n<span>char</span> c = (<span>char</span>)Console.Read();\r\n<span>if</span> (Char.IsLetter(c))\r\n{\r\n    <span>if</span> (Char.IsLower(c))\r\n    {\r\n        Console.WriteLine(<span>&quot;The character is lowercase.&quot;</span>);\r\n    }\r\n    <span>else</span>\r\n    {\r\n        Console.WriteLine(<span>&quot;The character is uppercase.&quot;</span>);\r\n    }\r\n}\r\n<span>else</span>\r\n{\r\n    Console.WriteLine(<span>&quot;The character isn&#39;t an alphabetic character.&quot;</span>);\r\n}\r\n\r\n<span>//Sample Output:</span>\r\n\r\n<span>//Enter a character: 2</span>\r\n<span>//The character isn&#39;t an alphabetic character.</span>\r\n\r\n<span>//Enter a character: A</span>\r\n<span>//The character is uppercase.</span>\r\n\r\n<span>//Enter a character: h</span>\r\n<span>//The character is lowercase.</span>\r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tYou also can nest an&nbsp;<code>if</code>&nbsp;statement inside an else block, as the following partial code shows. The example nests&nbsp;<code>if</code>&nbsp;statements inside two else blocks and one then block. The comments specify which conditions are true or false in each block.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Change the values of these variables to test the results.</span>\r\n<span>bool</span> Condition1 = <span>true</span>;\r\n<span>bool</span> Condition2 = <span>true</span>;\r\n<span>bool</span> Condition3 = <span>true</span>;\r\n<span>bool</span> Condition4 = <span>true</span>;\r\n\r\n<span>if</span> (Condition1)\r\n{\r\n    <span>// Condition1 is true.</span>\r\n}\r\n<span>else</span> <span>if</span> (Condition2)\r\n{\r\n    <span>// Condition1 is false and Condition2 is true.</span>\r\n}\r\n<span>else</span> <span>if</span> (Condition3)\r\n{\r\n    <span>if</span> (Condition4)\r\n    {\r\n        <span>// Condition1 and Condition2 are false. Condition3 and Condition4 are true.</span>\r\n    }\r\n    <span>else</span>\r\n    {\r\n        <span>// Condition1, Condition2, and Condition4 are false. Condition3 is true.</span>\r\n    }\r\n}\r\n<span>else</span>\r\n{\r\n    <span>// Condition1, Condition2, and Condition3 are false.</span>\r\n}\r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example determines whether an input character is a lowercase letter, an uppercase letter, or a number. If all three conditions are false, the character isn&rsquo;t an alphanumeric character. The example displays a message for each case.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>Console.Write(<span>&quot;Enter a character: &quot;</span>);\r\n<span>char</span> ch = (<span>char</span>)Console.Read();\r\n\r\n<span>if</span> (Char.IsUpper(ch))\r\n{\r\n    Console.WriteLine(<span>&quot;The character is an uppercase letter.&quot;</span>);\r\n}\r\n<span>else</span> <span>if</span> (Char.IsLower(ch))\r\n{\r\n    Console.WriteLine(<span>&quot;The character is a lowercase letter.&quot;</span>);\r\n}\r\n<span>else</span> <span>if</span> (Char.IsDigit(ch))\r\n{\r\n    Console.WriteLine(<span>&quot;The character is a number.&quot;</span>);\r\n}\r\n<span>else</span>\r\n{\r\n    Console.WriteLine(<span>&quot;The character is not alphanumeric.&quot;</span>);\r\n}\r\n\r\n<span>//Sample Input and Output:</span>\r\n<span>//Enter a character: E</span>\r\n<span>//The character is an uppercase letter.</span>\r\n\r\n<span>//Enter a character: e</span>\r\n<span>//The character is a lowercase letter.</span>\r\n\r\n<span>//Enter a character: 4</span>\r\n<span>//The character is a number.</span>\r\n\r\n<span>//Enter a character: =</span>\r\n<span>//The character is not alphanumeric.</span>\r\n</code></pre>\r\n<p>\r\n\tJust as a statement in the else block or the then block can be any valid statement, you can use any valid Boolean expression for the condition. You can use logical operators such as&nbsp;&amp;&amp;,&nbsp;&amp;,&nbsp;||,&nbsp;|&nbsp;and&nbsp;!&nbsp;to make compound conditions. The following code shows examples.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// NOT</span>\r\n<span>bool</span> result = <span>true</span>;\r\n<span>if</span> (!result)\r\n{\r\n    Console.WriteLine(<span>&quot;The condition is true (result is false).&quot;</span>);\r\n}\r\n<span>else</span>\r\n{\r\n    Console.WriteLine(<span>&quot;The condition is false (result is true).&quot;</span>);\r\n}\r\n\r\n<span>// Short-circuit AND</span>\r\n<span>int</span> m = <span>9</span>;\r\n<span>int</span> n = <span>7</span>;\r\n<span>int</span> p = <span>5</span>;\r\n<span>if</span> (m &gt;= n &amp;&amp; m &gt;= p)\r\n{\r\n    Console.WriteLine(<span>&quot;Nothing is larger than m.&quot;</span>);\r\n}\r\n\r\n<span>// AND and NOT</span>\r\n<span>if</span> (m &gt;= n &amp;&amp; !(p &gt; m))\r\n{\r\n    Console.WriteLine(<span>&quot;Nothing is larger than m.&quot;</span>);\r\n}\r\n\r\n<span>// Short-circuit OR</span>\r\n<span>if</span> (m &gt; n || m &gt; p)\r\n{\r\n    Console.WriteLine(<span>&quot;m isn&#39;t the smallest.&quot;</span>);\r\n}\r\n\r\n<span>// NOT and OR</span>\r\nm = <span>4</span>;\r\n<span>if</span> (!(m &gt;= n || m &gt;= p))\r\n{\r\n    Console.WriteLine(<span>&quot;Now m is the smallest.&quot;</span>);\r\n}\r\n<span>// Output:</span>\r\n<span>// The condition is false (result is true).</span>\r\n<span>// Nothing is larger than m.</span>\r\n<span>// Nothing is larger than m.</span>\r\n<span>// m isn&#39;t the smallest.</span>\r\n<span>// Now m is the smallest.</span></code></pre>"
          },
          {
            "switch": "<p>\r\n\t<code>switch</code>&nbsp;is a selection statement that chooses a single&nbsp;<em>switch section</em>&nbsp;to execute from a list of candidates based on a pattern match with the&nbsp;<em>match expression</em>.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System;\r\n\r\n<span>public</span> <span>class</span> <span>Example</span>\r\n{\r\n   <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>()\r\n   </span>{\r\n      <span>int</span> caseSwitch = <span>1</span>;\r\n      \r\n      <span>switch</span> (caseSwitch)\r\n      {\r\n          <span>case</span> <span>1</span>:\r\n              Console.WriteLine(<span>&quot;Case 1&quot;</span>);\r\n              <span>break</span>;\r\n          <span>case</span> <span>2</span>:\r\n              Console.WriteLine(<span>&quot;Case 2&quot;</span>);\r\n              <span>break</span>;\r\n          <span>default</span>:\r\n              Console.WriteLine(<span>&quot;Default case&quot;</span>);\r\n              <span>break</span>;\r\n      }\r\n   }\r\n}\r\n<span>// The example displays the following output:</span>\r\n<span>//       Case 1</span>\r\n</code></pre>\r\n<p>\r\n\tThe&nbsp;<code>switch</code>&nbsp;statement is often used as an alternative to an&nbsp;if-else&nbsp;construct if a single expression is tested against three or more conditions. For example, the following&nbsp;<code>switch</code>&nbsp;statement determines whether a variable of type&nbsp;<code>Color</code>&nbsp;has one of three values:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System;\r\n\r\n<span>public</span> <span>enum</span> Color { Red, Green, Blue }\r\n\r\n<span>public</span> <span>class</span> <span>Example</span>\r\n{\r\n   <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>()\r\n   </span>{\r\n      Color c = (Color) (<span>new</span> Random()).Next(<span>0</span>, <span>3</span>);\r\n      <span>switch</span> (c)\r\n      {\r\n         <span>case</span> Color.Red:\r\n            Console.WriteLine(<span>&quot;The color is red&quot;</span>);\r\n            <span>break</span>;\r\n         <span>case</span> Color.Green:\r\n            Console.WriteLine(<span>&quot;The color is green&quot;</span>);\r\n            <span>break</span>;\r\n         <span>case</span> Color.Blue:\r\n            Console.WriteLine(<span>&quot;The color is blue&quot;</span>);   \r\n            <span>break</span>;\r\n         <span>default</span>:\r\n            Console.WriteLine(<span>&quot;The color is unknown.&quot;</span>);\r\n            <span>break</span>;   \r\n      }\r\n   }\r\n}\r\n</code></pre>\r\n<p>\r\n\tIt is equivalent to the following example that uses an&nbsp;<code>if</code>-<code>else</code>&nbsp;construct.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System;\r\n\r\n<span>public</span> <span>enum</span> Color { Red, Green, Blue }\r\n\r\n<span>public</span> <span>class</span> <span>Example</span>\r\n{\r\n   <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>()\r\n   </span>{\r\n      Color c = (Color) (<span>new</span> Random()).Next(<span>0</span>, <span>3</span>);\r\n      <span>if</span> (c == Color.Red)\r\n         Console.WriteLine(<span>&quot;The color is red&quot;</span>);\r\n      <span>else</span> <span>if</span> (c == Color.Green)\r\n         Console.WriteLine(<span>&quot;The color is green&quot;</span>);\r\n      <span>else</span> <span>if</span> (c == Color.Blue)\r\n         Console.WriteLine(<span>&quot;The color is blue&quot;</span>);   \r\n      <span>else</span>\r\n         Console.WriteLine(<span>&quot;The color is unknown.&quot;</span>);\r\n   }\r\n}\r\n<span>// The example displays the following output:</span>\r\n<span>//       The color is red</span>\r\n</code></pre>\r\n<h2>\r\n\tThe match expression</h2>\r\n<p>\r\n\tThe match expression provides the value to match against the patterns in&nbsp;<code>case</code>&nbsp;labels. Its syntax is:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>   <span>switch</span> (expr)\r\n</code></pre>\r\n<p>\r\n\tIn C# 6, the match expression must be an expression that returns a value of the following types:</p>\r\n<ul>\r\n\t<li>\r\n\t\ta&nbsp;char.</li>\r\n\t<li>\r\n\t\ta&nbsp;string.</li>\r\n\t<li>\r\n\t\ta&nbsp;bool.</li>\r\n\t<li>\r\n\t\tan integral value, such as an&nbsp;int&nbsp;or a&nbsp;long.</li>\r\n\t<li>\r\n\t\tan&nbsp;enum&nbsp;value.</li>\r\n</ul>\r\n<p>\r\n\tStarting with C# 7.0, the match expression can be any non-null expression.</p>\r\n<h2>\r\n\tThe switch section</h2>\r\n<p>\r\n\tA&nbsp;<code>switch</code>&nbsp;statement includes one or more switch sections. Each switch section contains one or more&nbsp;<em>case labels</em>&nbsp;(either a case or default label) followed by one or more statements. The&nbsp;<code>switch</code>statement may include at most one default label placed in any switch section. The following example shows a simple&nbsp;<code>switch</code>&nbsp;statement that has three switch sections, each containing two statements. The second switch section contains the&nbsp;<code>case 2:</code>&nbsp;and&nbsp;<code>case 3:</code>&nbsp;labels.</p>\r\n<p>\r\n\tA&nbsp;<code>switch</code>&nbsp;statement can include any number of switch sections, and each section can have one or more case labels, as shown in the following example. However, no two case labels may contain the same expression.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System;\r\n\r\n<span>public</span> <span>class</span> <span>Example</span>\r\n{\r\n   <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>()\r\n   </span>{\r\n      Random rnd = <span>new</span> Random();\r\n      <span>int</span> caseSwitch = rnd.Next(<span>1</span>,<span>4</span>);\r\n      \r\n      <span>switch</span> (caseSwitch)\r\n      {\r\n          <span>case</span> <span>1</span>:\r\n              Console.WriteLine(<span>&quot;Case 1&quot;</span>);\r\n              <span>break</span>;\r\n          <span>case</span> <span>2</span>:\r\n          <span>case</span> <span>3</span>:\r\n              Console.WriteLine(<span>$&quot;Case <span>{caseSwitch}</span>&quot;</span>);\r\n              <span>break</span>;\r\n          <span>default</span>:\r\n              Console.WriteLine(<span>$&quot;An unexpected value (<span>{caseSwitch}</span>)&quot;</span>);\r\n              <span>break</span>;\r\n      }\r\n   }\r\n}\r\n<span>// The example displays output like the following:</span>\r\n<span>//       Case 1</span>\r\n</code></pre>\r\n<p>\r\n\tOnly one switch section in a switch statement executes. C# does not allow execution to continue from one switch section to the next. Because of this, the following code generates a compiler error, CS0163: &quot;Control cannot fall through from one case label (<case>) to another.&quot;</case></p>\r\n<p>\r\n\t&nbsp;</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>switch</span> (caseSwitch)\r\n{\r\n    <span>// The following switch section causes an error.</span>\r\n    <span>case</span> <span>1</span>:\r\n        Console.WriteLine(<span>&quot;Case 1...&quot;</span>);\r\n        <span>// Add a break or other jump statement here.</span>\r\n    <span>case</span> <span>2</span>:\r\n        Console.WriteLine(<span>&quot;... and/or Case 2&quot;</span>);\r\n        <span>break</span>;\r\n}\r\n</code></pre>\r\n<p>\r\n\tThis requirement is usually met by explicitly exiting the switch section by using a&nbsp;break,&nbsp;goto, or&nbsp;return&nbsp;statement. However, the following code is also valid, because it ensures that program control cannot fall through to the&nbsp;<code>default</code>&nbsp;switch section.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>switch</span> (caseSwitch)  \r\n{  \r\n    <span>// The following switch section causes an error.  </span>\r\n    <span>case</span> <span>1</span>:  \r\n        Console.WriteLine(<span>&quot;Case 1...&quot;</span>);  \r\n        <span>break</span>;  \r\n    <span>case</span> <span>2</span>:  \r\n    <span>case</span> <span>3</span>:\r\n        Console.WriteLine(<span>&quot;... and/or Case 2&quot;</span>);  \r\n        <span>break</span>;\r\n    <span>case</span> <span>4</span>:  \r\n        <span>while</span> (<span>true</span>)  \r\n           Console.WriteLine(<span>&quot;Endless looping. . . .&quot;</span>); \r\n    <span>default</span>:\r\n        Console.WriteLine(<span>&quot;Default value...&quot;</span>);\r\n        <span>break</span>;                 \r\n}  \r\n</code></pre>\r\n<p>\r\n\tExecution of the statement list in the switch section with a case label that matches the match expression begins with the first statement and proceeds through the statement list, typically until a jump statement, such as a&nbsp;<code>break</code>,&nbsp;<code>goto case</code>,&nbsp;<code>goto label</code>,&nbsp;<code>return</code>, or&nbsp;<code>throw</code>, is reached. At that point, control is transferred outside the&nbsp;<code>switch</code>&nbsp;statement or to another case label. A&nbsp;<code>goto</code>statement, if it is used, must transfer control to a constant label. This restriction is necessary, since attempting to transfer control to a non-constant label can have undesirable side-effects, such transferring control to an unintended location in code or creating an endless loop.</p>\r\n<h2>\r\n\tCase labels</h2>\r\n<p>\r\n\tEach case label specifies a pattern to compare to the match expression (the&nbsp;<code>caseSwitch</code>&nbsp;variable in the previous examples). If they match, control is transferred to the switch section that contains the&nbsp;<span>first</span>&nbsp;matching case label. If no case label pattern matches the match expression, control is transferred to the section with the&nbsp;<code>default</code>&nbsp;case label, if there is one. If there is no&nbsp;<code>default</code>&nbsp;case, no statements in any switch section are executed, and control is transferred outside the&nbsp;<code>switch</code>statement.</p>\r\n<p>\r\n\tFor information on the&nbsp;<code>switch</code>&nbsp;statement and pattern matching, see the&nbsp;Pattern matching with the&nbsp;<code>switch</code>&nbsp;statement&nbsp;section.</p>\r\n<p>\r\n\tBecause C# 6 supports only the constant pattern and does not allow the repetition of constant values, case labels define mutually exclusive values, and only one pattern can match the match expression. As a result, the order in which&nbsp;<code>case</code>&nbsp;statements appear is unimportant.</p>\r\n<p>\r\n\tIn C# 7.0, however, because other patterns are supported, case labels need not define mutually exclusive values, and multiple patterns can match the match expression. Because only the statements in the switch section that contains the first matching pattern are executed, the order in which&nbsp;<code>case</code>&nbsp;statements appear is now important. If C# detects a switch section whose case statement or statements are equivalent to or are subsets of previous statements, it generates a compiler error, CS8120, &quot;The switch case has already been handled by a previous case.&quot;</p>\r\n<p>\r\n\tThe following example illustrates a&nbsp;<code>switch</code>&nbsp;statement that uses a variety of non-mutually exclusive patterns. If you move the&nbsp;<code>case 0:</code>&nbsp;switch section so that it is no longer the first section in the&nbsp;<code>switch</code>&nbsp;statement, C# generates a compiler error because an integer whose value is zero is a subset of all integers, which is the pattern defined by the&nbsp;<code>case int val</code>&nbsp;statement.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System;\r\n<span>using</span> System.Collections.Generic;\r\n<span>using</span> System.Linq;\r\n\r\n<span>public</span> <span>class</span> <span>Example</span>\r\n{\r\n   <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>()\r\n   </span>{\r\n      <span>var</span> values = <span>new</span> List&lt;<span>object</span>&gt;();\r\n      <span>for</span> (<span>int</span> ctr = <span>0</span>; ctr &lt;= <span>7</span>; ctr++) {\r\n         <span>if</span> (ctr == <span>2</span>) \r\n            values.Add(DiceLibrary.Roll2());\r\n         <span>else</span> <span>if</span> (ctr == <span>4</span>)\r\n            values.Add(DiceLibrary.Pass());\r\n         <span>else</span>   \r\n            values.Add(DiceLibrary.Roll());\r\n      }   \r\n\r\n      Console.WriteLine(<span>$&quot;The sum of <span>{ values.Count }</span> die is <span>{ DiceLibrary.DiceSum(values) }</span>&quot;</span>);\r\n   }\r\n}\r\n\r\n<span>public</span> <span>static</span> <span>class</span> <span>DiceLibrary</span>\r\n{\r\n   <span>// Random number generator to simulate dice rolls.</span>\r\n   <span>static</span> Random rnd = <span>new</span> Random();\r\n\r\n   <span>// Roll a single die.</span>\r\n   <span><span>public</span> <span>static</span> <span>int</span> <span>Roll</span>()\r\n   </span>{\r\n      <span>return</span> rnd.Next(<span>1</span>, <span>7</span>);\r\n   }\r\n\r\n   <span>// Roll two dice.</span>\r\n   <span><span>public</span> <span>static</span> List&lt;<span>object</span>&gt; <span>Roll2</span>()\r\n   </span>{\r\n      <span>var</span> rolls = <span>new</span> List&lt;<span>object</span>&gt;();      \r\n      rolls.Add(Roll());\r\n      rolls.Add(Roll());\r\n      <span>return</span> rolls;\r\n   }\r\n\r\n   <span>// Calculate the sum of n dice rolls.</span>\r\n   <span><span>public</span> <span>static</span> <span>int</span> <span>DiceSum</span>(<span>IEnumerable&lt;<span>object</span>&gt; values</span>)\r\n   </span>{\r\n      <span>var</span> sum = <span>0</span>;\r\n      <span>foreach</span> (<span>var</span> item <span>in</span> values)\r\n      {\r\n            <span>switch</span> (item)\r\n            {\r\n               <span>// A single zero value.</span>\r\n               <span>case</span> <span>0</span>:\r\n                  <span>break</span>;\r\n               <span>// A single value.</span>\r\n               <span>case</span> <span>int</span> val:\r\n                  sum += val;\r\n                  <span>break</span>;\r\n               <span>// A non-empty collection.</span>\r\n               <span>case</span> IEnumerable&lt;<span>object</span>&gt; subList when subList.Any():\r\n                  sum += DiceSum(subList);\r\n                  <span>break</span>;\r\n               <span>// An empty collection.</span>\r\n               <span>case</span> IEnumerable&lt;<span>object</span>&gt; subList:\r\n                  <span>break</span>;\r\n               <span>//  A null reference.</span>\r\n               <span>case</span> <span>null</span>:\r\n                  <span>break</span>;\r\n               <span>// A value that is neither an integer nor a collection.</span>\r\n               <span>default</span>:\r\n                  <span>throw</span> <span>new</span> InvalidOperationException(<span>&quot;unknown item type&quot;</span>);\r\n            }\r\n      }\r\n      <span>return</span> sum;\r\n   }\r\n\r\n   <span><span>public</span> <span>static</span> <span>object</span> <span>Pass</span>()\r\n   </span>{\r\n      <span>if</span> (rnd.Next(<span>0</span>, <span>2</span>) == <span>0</span>)\r\n         <span>return</span> <span>null</span>;\r\n      <span>else</span>\r\n         <span>return</span> <span>new</span> List&lt;<span>object</span>&gt;();\r\n   }\r\n}\r\n</code></pre>\r\n<p>\r\n\tYou can correct this issue and eliminate the compiler warning in one of two ways:</p>\r\n<ul>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tBy changing the order of the switch sections.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tBy using a&nbsp;when clause&nbsp;in the&nbsp;<code>case</code>&nbsp;label.</p>\r\n\t</li>\r\n</ul>\r\n<h2>\r\n\tThe&nbsp;<code>default</code>&nbsp;case</h2>\r\n<p>\r\n\tThe&nbsp;<code>default</code>&nbsp;case specifies the switch section to execute if the match expression does not match any other&nbsp;<code>case</code>&nbsp;label. If a&nbsp;<code>default</code>&nbsp;case is not present and the match expression does not match any other&nbsp;<code>case</code>&nbsp;label, program flow falls through the&nbsp;<code>switch</code>&nbsp;statement.</p>\r\n<p>\r\n\tThe&nbsp;<code>default</code>&nbsp;case can appear in any order in the&nbsp;<code>switch</code>&nbsp;statement. Regardless of its order in the source code, it is always evaluated last, after all&nbsp;<code>case</code>&nbsp;labels have been evaluated.</p>\r\n<h2>\r\n\tPattern matching with the&nbsp;<code>switch</code>&nbsp;statement</h2>\r\n<p>\r\n\tEach&nbsp;<code>case</code>&nbsp;statement defines a pattern that, if it matches the match expression, causes its containing switch section to be executed. All versions of C# support the constant pattern. The remaining patterns are supported beginning with C# 7.0.</p>\r\n<h3>\r\n\tConstant pattern</h3>\r\n<p>\r\n\tThe constant pattern tests whether the match expression equals a specified constant. Its syntax is:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>   <span>case</span> constant:\r\n</code></pre>\r\n<p>\r\n\twhere&nbsp;<em>constant</em>&nbsp;is the value to test for.&nbsp;<em>constant</em>&nbsp;can be any of the following constant expressions:</p>\r\n<ul>\r\n\t<li>\r\n\t\tA&nbsp;bool&nbsp;literal, either&nbsp;<code>true</code>&nbsp;or&nbsp;<code>false</code>.</li>\r\n\t<li>\r\n\t\tAny integral constant, such as an&nbsp;int, a&nbsp;long, or a&nbsp;byte.</li>\r\n\t<li>\r\n\t\tThe name of a declared&nbsp;<code>const</code>&nbsp;variable.</li>\r\n\t<li>\r\n\t\tAn enumeration constant.</li>\r\n\t<li>\r\n\t\tA&nbsp;char&nbsp;literal.</li>\r\n\t<li>\r\n\t\tA&nbsp;string&nbsp;literal.</li>\r\n</ul>\r\n<p>\r\n\tThe constant expression is evaluated as follows:</p>\r\n<ul>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tIf&nbsp;<em>expr</em>&nbsp;and&nbsp;<em>constant</em>&nbsp;are integral types, the C# equality operator determines whether the expression returns&nbsp;<code>true</code>&nbsp;(that is, whether&nbsp;<code>expr == constant</code>).</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tOtherwise, the value of the expression is determined by a call to the static&nbsp;Object.Equals(expr, constant)&nbsp;method.</p>\r\n\t</li>\r\n</ul>\r\n<p>\r\n\tThe following example uses the constant pattern to determine whether a particular date is a weekend, the first day of the work week, the last day of the work week, or the middle of the work week. It evaluates the&nbsp;DateTime.DayOfWeek&nbsp;property of the current day against the members of the&nbsp;DayOfWeek&nbsp;enumeration.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System;\r\n\r\n<span>class</span> <span>Program</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>switch</span> (DateTime.Now.DayOfWeek)\r\n        {\r\n           <span>case</span> DayOfWeek.Sunday:\r\n           <span>case</span> DayOfWeek.Saturday:\r\n              Console.WriteLine(<span>&quot;The weekend&quot;</span>);\r\n              <span>break</span>;\r\n           <span>case</span> DayOfWeek.Monday:\r\n              Console.WriteLine(<span>&quot;The first day of the work week.&quot;</span>);\r\n              <span>break</span>;\r\n           <span>case</span> DayOfWeek.Friday:\r\n              Console.WriteLine(<span>&quot;The last day of the work week.&quot;</span>);\r\n              <span>break</span>;\r\n           <span>default</span>:\r\n              Console.WriteLine(<span>&quot;The middle of the work week.&quot;</span>);\r\n              <span>break</span>;   \r\n        }\r\n    }\r\n}\r\n<span>// The example displays output like the following:</span>\r\n<span>//       The middle of the work week.</span>\r\n</code></pre>\r\n<p>\r\n\tThe following example uses the constant pattern to handle user input in a console application that simulates an automatic coffee machine.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System;\r\n\r\n<span>class</span> <span>Example</span>\r\n{\r\n   <span><span>static</span> <span>void</span> <span>Main</span>()\r\n   </span>{\r\n       Console.WriteLine(<span>&quot;Coffee sizes: 1=small 2=medium 3=large&quot;</span>);\r\n       Console.Write(<span>&quot;Please enter your selection: &quot;</span>);\r\n       <span>string</span> str = Console.ReadLine();\r\n       <span>int</span> cost = <span>0</span>;\r\n\r\n       <span>// Because of the goto statements in cases 2 and 3, the base cost of 25</span>\r\n       <span>// cents is added to the additional cost for the medium and large sizes.</span>\r\n       <span>switch</span> (str)\r\n       {\r\n          <span>case</span> <span>&quot;1&quot;</span>:\r\n          <span>case</span> <span>&quot;small&quot;</span>:\r\n              cost += <span>25</span>;\r\n              <span>break</span>;\r\n          <span>case</span> <span>&quot;2&quot;</span>:\r\n          <span>case</span> <span>&quot;medium&quot;</span>:\r\n              cost += <span>25</span>;\r\n              <span>goto</span> <span>case</span> <span>&quot;1&quot;</span>;\r\n          <span>case</span> <span>&quot;3&quot;</span>:\r\n          <span>case</span> <span>&quot;large&quot;</span>:\r\n              cost += <span>50</span>;\r\n              <span>goto</span> <span>case</span> <span>&quot;1&quot;</span>;\r\n          <span>default</span>:\r\n              Console.WriteLine(<span>&quot;Invalid selection. Please select 1, 2, or 3.&quot;</span>);\r\n              <span>break</span>;\r\n      }\r\n      <span>if</span> (cost != <span>0</span>)\r\n      {\r\n          Console.WriteLine(<span>&quot;Please insert {0} cents.&quot;</span>, cost);\r\n      }\r\n      Console.WriteLine(<span>&quot;Thank you for your business.&quot;</span>);\r\n   }\r\n}\r\n<span>// The example displays output like the following:</span>\r\n<span>//         Coffee sizes: 1=small 2=medium 3=large</span>\r\n<span>//         Please enter your selection: 2</span>\r\n<span>//         Please insert 50 cents.</span>\r\n<span>//         Thank you for your business.</span>\r\n\r\n\r\n</code></pre>\r\n<h3>\r\n\tType pattern</h3>\r\n<p>\r\n\tThe type pattern enables concise type evaluation and conversion. When used with the&nbsp;<code>switch</code>statement to perform pattern matching, it tests whether an expression can be converted to a specified type and, if it can be, casts it to a variable of that type. Its syntax is:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>   <span>case</span> type varname\r\n</code></pre>\r\n<p>\r\n\twhere&nbsp;<em>type</em>&nbsp;is the name of the type to which the result of&nbsp;<em>expr</em>&nbsp;is to be converted, and&nbsp;<em>varname</em>&nbsp;is the object to which the result of&nbsp;<em>expr</em>&nbsp;is converted if the match succeeds.</p>\r\n<p>\r\n\tThe&nbsp;<code>case</code>&nbsp;expression is&nbsp;<code>true</code>&nbsp;if any of the following is true:</p>\r\n<ul>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\t<em>expr</em>&nbsp;is an instance of the same type as&nbsp;<em>type</em>.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\t<em>expr</em>&nbsp;is an instance of a type that derives from&nbsp;<em>type</em>. In other words, the result of&nbsp;<em>expr</em>&nbsp;can be upcast to an instance of&nbsp;<em>type</em>.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\t<em>expr</em>&nbsp;has a compile-time type that is a base class of&nbsp;<em>type</em>, and&nbsp;<em>expr</em>&nbsp;has a runtime type that is&nbsp;<em>type</em>&nbsp;or is derived from&nbsp;<em>type</em>. The&nbsp;<em>compile-time type</em>&nbsp;of a variable is the variable&#39;s type as defined in its type declaration. The&nbsp;<em>runtime type</em>&nbsp;of a variable is the type of the instance that is assigned to that variable.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\t<em>expr</em>&nbsp;is an instance of a type that implements the&nbsp;<em>type</em>&nbsp;interface.</p>\r\n\t</li>\r\n</ul>\r\n<p>\r\n\tIf the case expression is true,&nbsp;<em>varname</em>&nbsp;is definitely assigned and has local scope within the switch section only.</p>\r\n<p>\r\n\tNote that&nbsp;<code>null</code>&nbsp;does not match a type. To match a&nbsp;<code>null</code>, you use the following&nbsp;<code>case</code>&nbsp;label:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>case</span> <span>null</span>:\r\n</code></pre>\r\n<p>\r\n\tThe following example uses the type pattern to provide information about various kinds of collection types.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System;\r\n<span>using</span> System.Collections;\r\n<span>using</span> System.Collections.Generic;\r\n<span>using</span> System.Linq;\r\n\r\n<span>class</span> <span>Example</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)\r\n    </span>{\r\n        <span>int</span>[] values = { <span>2</span>, <span>4</span>, <span>6</span>, <span>8</span>, <span>10</span> };\r\n        ShowCollectionInformation(values);\r\n        \r\n        <span>var</span> names = <span>new</span> List&lt;<span>string</span>&gt;();\r\n        names.AddRange( <span>new</span> <span>string</span>[] { <span>&quot;Adam&quot;</span>, <span>&quot;Abigail&quot;</span>, <span>&quot;Bertrand&quot;</span>, <span>&quot;Bridgette&quot;</span> } );\r\n        ShowCollectionInformation(names);\r\n\r\n        List&lt;<span>int</span>&gt; numbers = <span>null</span>;\r\n        ShowCollectionInformation(numbers);\r\n    }\r\n   \r\n    <span><span>private</span> <span>static</span> <span>void</span> <span>ShowCollectionInformation</span>(<span><span>object</span> coll</span>)\r\n    </span>{\r\n        <span>switch</span> (coll)\r\n        {\r\n            <span>case</span> Array arr:\r\n               Console.WriteLine(<span>$&quot;An array with <span>{arr.Length}</span> elements.&quot;</span>);\r\n               <span>break</span>;\r\n            <span>case</span> IEnumerable&lt;<span>int</span>&gt; ieInt:\r\n               Console.WriteLine(<span>$&quot;Average: <span>{ieInt.Average(s =&gt; s)}</span>&quot;</span>);\r\n               <span>break</span>;   \r\n            <span>case</span> IList list:\r\n               Console.WriteLine(<span>$&quot;<span>{list.Count}</span> items&quot;</span>);\r\n               <span>break</span>;\r\n            <span>case</span> IEnumerable ie:\r\n               <span>string</span> result = <span>&quot;&quot;</span>;\r\n               <span>foreach</span> (<span>var</span> item <span>in</span> ie) \r\n                  result += <span>&quot;${e} &quot;</span>;\r\n               Console.WriteLine(result);\r\n               <span>break</span>;   \r\n            <span>case</span> <span>null</span>:\r\n               <span>// Do nothing for a null.</span>\r\n               <span>break</span>;\r\n            <span>default</span>:\r\n               Console.WriteLine(<span>$&quot;A instance of type <span>{coll.GetType().Name}</span>&quot;</span>);\r\n               <span>break</span>;   \r\n        }\r\n    }\r\n}\r\n<span>// The example displays the following output:</span>\r\n<span>//     An array with 5 elements.</span>\r\n<span>//     4 items</span>\r\n</code></pre>\r\n<p>\r\n\tWithout pattern matching, this code might be written as follows. The use of type pattern matching produces more compact, readable code by eliminating the need to test whether the result of a conversion is a&nbsp;<code>null</code>&nbsp;or to perform repeated casts.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System;\r\n<span>using</span> System.Collections;\r\n<span>using</span> System.Collections.Generic;\r\n<span>using</span> System.Linq;\r\n\r\n<span>class</span> <span>Example</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)\r\n    </span>{\r\n        <span>int</span>[] values = { <span>2</span>, <span>4</span>, <span>6</span>, <span>8</span>, <span>10</span> };\r\n        ShowCollectionInformation(values);\r\n        \r\n        <span>var</span> names = <span>new</span> List&lt;<span>string</span>&gt;();\r\n        names.AddRange( <span>new</span> <span>string</span>[] { <span>&quot;Adam&quot;</span>, <span>&quot;Abigail&quot;</span>, <span>&quot;Bertrand&quot;</span>, <span>&quot;Bridgette&quot;</span> } );\r\n        ShowCollectionInformation(names);\r\n        \r\n        List&lt;<span>int</span>&gt; numbers = <span>null</span>;\r\n        ShowCollectionInformation(numbers);\r\n    }\r\n   \r\n    <span><span>private</span> <span>static</span> <span>void</span> <span>ShowCollectionInformation</span>(<span><span>object</span> coll</span>)\r\n    </span>{\r\n        <span>if</span> (coll <span>is</span> Array) {\r\n           Array arr = (Array) coll;\r\n           Console.WriteLine(<span>$&quot;An array with <span>{arr.Length}</span> elements.&quot;</span>);\r\n        }\r\n        <span>else</span> <span>if</span> (coll <span>is</span> IEnumerable&lt;<span>int</span>&gt;) {\r\n            IEnumerable&lt;<span>int</span>&gt; ieInt = (IEnumerable&lt;<span>int</span>&gt;) coll;\r\n            Console.WriteLine(<span>$&quot;Average: <span>{ieInt.Average(s =&gt; s)}</span>&quot;</span>);\r\n        }\r\n        <span>else</span> <span>if</span> (coll <span>is</span> IList) {\r\n            IList list = (IList) coll;\r\n            Console.WriteLine(<span>$&quot;<span>{list.Count}</span> items&quot;</span>);\r\n        }\r\n        <span>else</span> <span>if</span> (coll <span>is</span> IEnumerable) { \r\n            IEnumerable ie = (IEnumerable) coll;\r\n            <span>string</span> result = <span>&quot;&quot;</span>;\r\n            <span>foreach</span> (<span>var</span> item <span>in</span> ie) \r\n               result += <span>&quot;${e} &quot;</span>;\r\n            Console.WriteLine(result);\r\n        }\r\n        <span>else</span> <span>if</span> (coll == <span>null</span>) { \r\n            <span>// Do nothing. </span>\r\n        }\r\n        <span>else</span> {\r\n            Console.WriteLine(<span>$&quot;An instance of type <span>{coll.GetType().Name}</span>&quot;</span>);\r\n        }   \r\n    }\r\n}\r\n<span>// The example displays the following output:</span>\r\n<span>//     An array with 5 elements.</span>\r\n<span>//     4 items</span>\r\n</code></pre>\r\n<h2>\r\n\tThe&nbsp;<code>case</code>&nbsp;statement and the&nbsp;<code>when</code>&nbsp;clause</h2>\r\n<p>\r\n\tStarting with C# 7.0, because case statements need not be mutually exclusive, you can add a&nbsp;<code>when</code>clause to specify an additional condition that must be satisfied for the case statement to evaluate to true. The&nbsp;<code>when</code>&nbsp;clause can be any expression that returns a Boolean value.</p>\r\n<p>\r\n\tThe following example defines a base&nbsp;<code>Shape</code>&nbsp;class, a&nbsp;<code>Rectangle</code>&nbsp;class that derives from&nbsp;<code>Shape</code>, and a&nbsp;<code>Square</code>&nbsp;class that derives from&nbsp;<code>Rectangle</code>. It uses the&nbsp;<code>when</code>&nbsp;clause to ensure that the&nbsp;<code>ShowShapeInfo</code>&nbsp;treats a&nbsp;<code>Rectangle</code>&nbsp;object that has been assigned equal lengths and widths as a&nbsp;<code>Square</code>&nbsp;even if it has not been instantiated as a&nbsp;<code>Square</code>&nbsp;object. The method does not attempt to display information either about an object that is&nbsp;<code>null</code>&nbsp;or a shape whose area is zero.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System;\r\n\r\n<span>public</span> <span>abstract</span> <span>class</span> <span>Shape</span>\r\n{\r\n   <span>public</span> <span>abstract</span> <span>double</span> Area { <span>get</span>; }\r\n   <span>public</span> <span>abstract</span> <span>double</span> Circumference { <span>get</span>; } \r\n}\r\n\r\n<span>public</span> <span>class</span> <span>Rectangle</span> : <span>Shape</span>\r\n{\r\n   <span><span>public</span> <span>Rectangle</span>(<span><span>double</span> length, <span>double</span> width</span>) \r\n   </span>{\r\n      Length = length;\r\n      Width = width; \r\n   }\r\n\r\n   <span>public</span> <span>double</span> Length { <span>get</span>; <span>set</span>; }\r\n   <span>public</span> <span>double</span> Width { <span>get</span>; <span>set</span>; }\r\n   \r\n   <span>public</span> <span>override</span> <span>double</span> Area\r\n   { \r\n      <span>get</span> { <span>return</span> Math.Round(Length * Width,<span>2</span>); } \r\n   } \r\n   \r\n   <span>public</span> <span>override</span> <span>double</span> Circumference \r\n   {\r\n      <span>get</span> { <span>return</span> (Length + Width) * <span>2</span>; }\r\n   }\r\n}\r\n\r\n<span>public</span> <span>class</span> <span>Square</span> : <span>Rectangle</span>\r\n{\r\n   <span><span>public</span> <span>Square</span>(<span><span>double</span> side</span>) : <span>base</span>(<span>side, side</span>) \r\n   </span>{\r\n      Side = side; \r\n   }\r\n\r\n   <span>public</span> <span>double</span> Side { <span>get</span>; <span>set</span>; }\r\n}\r\n\r\n<span>public</span> <span>class</span> <span>Circle</span> : <span>Shape</span>\r\n{\r\n   <span><span>public</span> <span>Circle</span>(<span><span>double</span> radius</span>) \r\n   </span>{\r\n      Radius = radius;\r\n   } \r\n   \r\n   <span>public</span> <span>double</span> Radius { <span>get</span>; <span>set</span>; }\r\n\r\n   <span>public</span> <span>override</span> <span>double</span> Circumference\r\n   {\r\n      <span>get</span> { <span>return</span> <span>2</span> * Math.PI * Radius; }\r\n   }\r\n\r\n   <span>public</span> <span>override</span> <span>double</span> Area\r\n   {\r\n      <span>get</span> { <span>return</span> Math.PI * Math.Pow(Radius, <span>2</span>); } \r\n   }\r\n}\r\n\r\n<span>public</span> <span>class</span> <span>Example</span>\r\n{\r\n   <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>()\r\n   </span>{\r\n      Shape sh = <span>null</span>;\r\n      Shape[] shapes = { <span>new</span> Square(<span>10</span>), <span>new</span> Rectangle(<span>5</span>, <span>7</span>),\r\n                         sh, <span>new</span> Square(<span>0</span>), <span>new</span> Rectangle(<span>8</span>, <span>8</span>),\r\n                         <span>new</span> Circle(<span>3</span>) };\r\n      <span>foreach</span> (<span>var</span> shape <span>in</span> shapes)\r\n         ShowShapeInfo(shape);\r\n   }\r\n\r\n   <span><span>private</span> <span>static</span> <span>void</span> <span>ShowShapeInfo</span>(<span>Shape sh</span>)\r\n   </span>{\r\n      <span>switch</span> (sh)\r\n      {\r\n         <span>// Note that this code never evaluates to true.</span>\r\n         <span>case</span> Shape shape when shape == <span>null</span>:\r\n            Console.WriteLine(<span>$&quot;An uninitialized shape (shape == null)&quot;</span>);\r\n            <span>break</span>;\r\n         <span>case</span> <span>null</span>:\r\n            Console.WriteLine(<span>$&quot;An uninitialized shape&quot;</span>);\r\n            <span>break</span>;\r\n         <span>case</span> Shape shape when sh.Area == <span>0</span>:\r\n            Console.WriteLine(<span>$&quot;The shape: <span>{sh.GetType().Name}</span> with no dimensions&quot;</span>);\r\n            <span>break</span>;\r\n         <span>case</span> Square sq when sh.Area &gt; <span>0</span>:\r\n            Console.WriteLine(<span>&quot;Information about square:&quot;</span>);\r\n            Console.WriteLine(<span>$&quot;   Length of a side: <span>{sq.Side}</span>&quot;</span>);\r\n            Console.WriteLine(<span>$&quot;   Area: <span>{sq.Area}</span>&quot;</span>);\r\n            <span>break</span>;\r\n         <span>case</span> Rectangle r when r.Length == r.Width &amp;&amp; r.Area &gt; <span>0</span>:\r\n            Console.WriteLine(<span>&quot;Information about square rectangle:&quot;</span>);\r\n            Console.WriteLine(<span>$&quot;   Length of a side: <span>{r.Length}</span>&quot;</span>);\r\n            Console.WriteLine(<span>$&quot;   Area: <span>{r.Area}</span>&quot;</span>);\r\n            <span>break</span>;\r\n         <span>case</span> Rectangle r when sh.Area &gt; <span>0</span>:\r\n            Console.WriteLine(<span>&quot;Information about rectangle:&quot;</span>);\r\n            Console.WriteLine(<span>$&quot;   Dimensions: <span>{r.Length}</span> x <span>{r.Width}</span>&quot;</span>);\r\n            Console.WriteLine(<span>$&quot;   Area: <span>{r.Area}</span>&quot;</span>);\r\n            <span>break</span>;\r\n         <span>case</span> Shape shape when sh != <span>null</span>:\r\n            Console.WriteLine(<span>$&quot;A <span>{sh.GetType().Name}</span> shape&quot;</span>);\r\n            <span>break</span>;\r\n         <span>default</span>:\r\n            Console.WriteLine(<span>$&quot;The <span>{<span>nameof</span>(sh)}</span> variable does not represent a Shape.&quot;</span>);\r\n            <span>break</span>;   \r\n      }\r\n   }\r\n}\r\n<span>// The example displays the following output:</span>\r\n<span>//       Information about square:</span>\r\n<span>//          Length of a side: 10</span>\r\n<span>//          Area: 100</span>\r\n<span>//       Information about rectangle:</span>\r\n<span>//          Dimensions: 5 x 7</span>\r\n<span>//          Area: 35</span>\r\n<span>//       An uninitialized shape</span>\r\n<span>//       The shape: Square with no dimensions</span>\r\n<span>//       Information about square rectangle:</span>\r\n<span>//          Length of a side: 8</span>\r\n<span>//          Area: 64</span>\r\n<span>//       A Circle shape</span>\r\n</code></pre>\r\n<blockquote>\r\n\t<p>\r\n\t\tNote that the&nbsp;<code>when</code>&nbsp;clause in the example that attempts to test whether a&nbsp;<code>Shape</code>&nbsp;object is&nbsp;<code>null</code>does not execute. The correct type pattern to test for a&nbsp;<code>null</code>&nbsp;is&nbsp;<code>case null:</code>.</p>\r\n</blockquote>"
          },
          {
            "do": "<p>\r\n\tThe&nbsp;<code>do</code>&nbsp;statement executes a statement or a block of statements while a specified Boolean expression evaluates to&nbsp;<code>true</code>. Because that expression is evaluated after each execution of the loop, a&nbsp;<code>do-while</code>&nbsp;loop executes one or more times. This differs from the&nbsp;while&nbsp;loop, which executes zero or more times.</p>\r\n<p>\r\n\tAt any point within the&nbsp;<code>do</code>&nbsp;statement block, you can break out of the loop by using the&nbsp;breakstatement.</p>\r\n<p>\r\n\tYou can step directly to the evaluation of the&nbsp;<code>while</code>&nbsp;expression by using the&nbsp;continue&nbsp;statement. If the expression evaluates to&nbsp;<code>true</code>, execution continues at the first statement in the loop. Otherwise, execution continues at the first statement after the loop.</p>\r\n<p>\r\n\tYou also can exit a&nbsp;<code>do-while</code>&nbsp;loop by the&nbsp;goto,&nbsp;return, or&nbsp;throw&nbsp;statements.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example shows the usage of the&nbsp;<code>do</code>&nbsp;statement. Select&nbsp;<span>Run</span>&nbsp;to run the example code. After that you can modify the code and run it again.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>int</span> n = <span>0</span>;\r\n<span>do</span> \r\n{\r\n    Console.WriteLine(n);\r\n    n++;\r\n} <span>while</span> (n &lt; <span>5</span>);</code></pre>"
          },
          {
            "for": "<p>\r\n\tThe&nbsp;<code>for</code>&nbsp;statement executes a statement or a block of statements while a specified Boolean expression evaluates to&nbsp;<code>true</code>.</p>\r\n<p>\r\n\tAt any point within the&nbsp;<code>for</code>&nbsp;statement block, you can break out of the loop by using the&nbsp;breakstatement, or step to the next iteration in the loop by using the&nbsp;continue&nbsp;statement. You also can exit a&nbsp;<code>for</code>&nbsp;loop by the&nbsp;goto,&nbsp;return, or&nbsp;throw&nbsp;statements.</p>\r\n<h2>\r\n\tStructure of the&nbsp;<code>for</code>&nbsp;statement</h2>\r\n<p>\r\n\tThe&nbsp;<code>for</code>&nbsp;statement defines&nbsp;<em>initializer</em>,&nbsp;<em>condition</em>, and&nbsp;<em>iterator</em>&nbsp;sections:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>for</span> (initializer; condition; iterator)\r\n    body\r\n</code></pre>\r\n<p>\r\n\tAll three sections are optional. The body of the loop is either a statement or a block of statements.</p>\r\n<p>\r\n\tThe following example shows the&nbsp;<code>for</code>&nbsp;statement with all of the sections defined:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>for</span> (<span>int</span> i = <span>0</span>; i &lt; <span>5</span>; i++)\r\n{\r\n    Console.WriteLine(i);\r\n}\r\n</code></pre>\r\n<h3>\r\n\tThe&nbsp;<em>initializer</em>&nbsp;section</h3>\r\n<p>\r\n\tThe statements in the&nbsp;<em>initializer</em>&nbsp;section are executed only once, before entering the loop. The&nbsp;<em>initializer</em>&nbsp;section is either of the following:<span>The declaration and initialization of a local loop variable, which can&#39;t be accessed from outside the loop.</span></p>\r\n<p>\r\n\t&nbsp;</p>\r\n<ul>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tThe declaration and initialization of a local loop variable, which can&#39;t be accessed from outside the loop.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tZero or more statement expressions from the following list, separated by commas:</p>\r\n\t\t<ul>\r\n\t\t\t<li>\r\n\t\t\t\t<p>\r\n\t\t\t\t\t<span>assignm</span><span>ent</span>&nbsp;statement</p>\r\n\t\t\t</li>\r\n\t\t\t<li>\r\n\t\t\t\t<p>\r\n\t\t\t\t\tinvocation of a method</p>\r\n\t\t\t</li>\r\n\t\t\t<li>\r\n\t\t\t\t<p>\r\n\t\t\t\t\tprefix or postfix&nbsp;increment&nbsp;expression, such as&nbsp;<code>++i</code>&nbsp;or&nbsp;<code>i++</code></p>\r\n\t\t\t</li>\r\n\t\t\t<li>\r\n\t\t\t\t<p>\r\n\t\t\t\t\tprefix or postfix&nbsp;decrement&nbsp;expression, such as&nbsp;<code>--i</code>&nbsp;or&nbsp;<code>i--</code></p>\r\n\t\t\t</li>\r\n\t\t\t<li>\r\n\t\t\t\t<p>\r\n\t\t\t\t\tcreation of an object by using&nbsp;new&nbsp;keyword</p>\r\n\t\t\t</li>\r\n\t\t\t<li>\r\n\t\t\t\t<p>\r\n\t\t\t\t\tawait&nbsp;expression</p>\r\n\t\t\t</li>\r\n\t\t</ul>\r\n\t</li>\r\n</ul>\r\n<p>\r\n\tThe&nbsp;<em>initializer</em>&nbsp;section in the example above declares and initializes the local loop variable&nbsp;<code>i</code>:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>int</span> i = <span>0</span>\r\n</code></pre>\r\n<h3>\r\n\tThe&nbsp;<em>condition</em>&nbsp;section</h3>\r\n<p>\r\n\tThe&nbsp;<em>condition</em>&nbsp;section, if present, must be a boolean expression. That expression is evaluated before every loop iteration. If the&nbsp;<em>condition</em>&nbsp;section is not present or the boolean expression evaluates to&nbsp;<code>true</code>, the next loop iteration is executed; otherwise, the loop is exited.</p>\r\n<p>\r\n\tThe&nbsp;<em>condition</em>&nbsp;section in the example above determines if the loop terminates based on the value of the local loop variable:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>i &lt; <span>5</span>\r\n</code></pre>\r\n<h3>\r\n\tThe&nbsp;<em>iterator</em>&nbsp;section</h3>\r\n<p>\r\n\tThe&nbsp;<em>iterator</em>&nbsp;section defines what happens after each iteration of the body of the loop. The&nbsp;<em>iterator</em>section contains zero or more of the following statement expressions, separated by commas:</p>\r\n<ul>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tassignment&nbsp;statement</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tinvocation of a method</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tprefix or postfix&nbsp;increment&nbsp;expression, such as&nbsp;<code>++i</code>&nbsp;or&nbsp;<code>i++</code></p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tprefix or postfix&nbsp;decrement&nbsp;expression, such as&nbsp;<code>--i</code>&nbsp;or&nbsp;<code>i--</code></p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tcreation of an object by using&nbsp;new&nbsp;keyword</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tawait&nbsp;expression</p>\r\n\t</li>\r\n</ul>\r\n<p>\r\n\tThe&nbsp;<em>iterator</em>&nbsp;section in the example above increments the local loop variable:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>i++\r\n</code></pre>\r\n<h2>\r\n\tExamples</h2>\r\n<p>\r\n\tThe following example illustrates several less common usages of the&nbsp;<code>for</code>&nbsp;statement sections: assigning a value to an external loop variable in the&nbsp;<em>initializer</em>&nbsp;section, invoking a method in both the&nbsp;<em>initializer</em>&nbsp;and the&nbsp;<em>iterator</em>&nbsp;sections, and changing the values of two variables in the&nbsp;<em>iterator</em>&nbsp;section. Select&nbsp;<span>Run</span>&nbsp;to run the example code. After that you can modify the code and run it again.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>int</span> i;\r\n<span>int</span> j = <span>10</span>;\r\n<span>for</span> (i = <span>0</span>, Console.WriteLine(<span>$&quot;Start: i=<span>{i}</span>, j=<span>{j}</span>&quot;</span>); i &lt; j; i++, j--, Console.WriteLine(<span>$&quot;Step: i=<span>{i}</span>, j=<span>{j}</span>&quot;</span>))\r\n{\r\n    <span>// Body of the loop.</span>\r\n}\r\n</code></pre>\r\n<p>\r\n\tThe following example defines the infinite&nbsp;<code>for</code>&nbsp;loop:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>for</span> ( ; ; )\r\n{\r\n    <span>// Body of the loop.</span>\r\n}</code></pre>"
          },
          {
            "foreach, in": "<p>\r\n\tThe&nbsp;<code>foreach</code>&nbsp;statement executes a statement or a block of statements for each element in an instance of the type that implements the&nbsp;System.Collections.IEnumerable&nbsp;or&nbsp;System.Collections.Generic.IEnumerable&lt;T&gt;&nbsp;interface. The&nbsp;<code>foreach</code>&nbsp;statement is not limited to those types and can be applied to an instance of any type that satisfies the following conditions:</p>\r\n<ul>\r\n\t<li>\r\n\t\thas the public parameterless&nbsp;<code>GetEnumerator</code>&nbsp;method whose return type is either class, struct, or interface type,</li>\r\n\t<li>\r\n\t\tthe return type of the&nbsp;<code>GetEnumerator</code>&nbsp;method has the public&nbsp;<code>Current</code>&nbsp;property and the public parameterless&nbsp;<code>MoveNext</code>&nbsp;method whose return type is&nbsp;Boolean.</li>\r\n</ul>\r\n<p>\r\n\tBeginning with C# 7.3, if the enumerator&#39;s&nbsp;<code>Current</code>&nbsp;property returns a&nbsp;reference return value&nbsp;(<code>ref T</code>&nbsp;where&nbsp;<code>T</code>&nbsp;is the type of the collection element), you can declare the iteration variable with the&nbsp;<code>ref</code>&nbsp;or&nbsp;<code>ref readonly</code>&nbsp;modifier.</p>\r\n<p>\r\n\tAt any point within the&nbsp;<code>foreach</code>&nbsp;statement block, you can break out of the loop by using the&nbsp;breakstatement, or step to the next iteration in the loop by using the&nbsp;continue&nbsp;statement. You also can exit a&nbsp;<code>foreach</code>&nbsp;loop by the&nbsp;goto,&nbsp;return, or&nbsp;throw&nbsp;statements.</p>\r\n<h2>\r\n\tExamples</h2>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tThe C# examples in this article run in the&nbsp;Try.NET&nbsp;inline code runner and playground. Select the&nbsp;<span>Run</span>&nbsp;button to run an example in an interactive window. Once you execute the code, you can modify it and run the modified code by selecting&nbsp;<span>Run</span>&nbsp;again. The modified code either runs in the interactive window or, if compilation fails, the interactive window displays all C# compiler error messages.</p>\r\n</div>\r\n<p>\r\n\tThe following example shows usage of the&nbsp;<code>foreach</code>&nbsp;statement with an instance of the&nbsp;List&lt;T&gt;&nbsp;type that implements the&nbsp;IEnumerable&lt;T&gt;&nbsp;interface:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>var</span> fibNumbers = <span>new</span> List&lt;<span>int</span>&gt; { <span>0</span>, <span>1</span>, <span>1</span>, <span>2</span>, <span>3</span>, <span>5</span>, <span>8</span>, <span>13</span> };\r\n<span>int</span> count = <span>0</span>;\r\n<span>foreach</span> (<span>int</span> element <span>in</span> fibNumbers)\r\n{\r\n    count++;\r\n    Console.WriteLine(<span>$&quot;Element #<span>{count}</span>: <span>{element}</span>&quot;</span>);\r\n}\r\nConsole.WriteLine(<span>$&quot;Number of elements: <span>{count}</span>&quot;</span>);\r\n</code></pre>\r\n<p>\r\n\tThe next example uses the&nbsp;<code>foreach</code>&nbsp;statement with an instance of the&nbsp;System.Span&lt;T&gt;&nbsp;type, which doesn&#39;t implement any interfaces:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>class</span> <span>IterateSpanExample</span>\r\n{\r\n    <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        Span&lt;<span>int</span>&gt; numbers = <span>new</span> <span>int</span>[] { <span>3</span>, <span>14</span>, <span>15</span>, <span>92</span>, <span>6</span> };\r\n        <span>foreach</span> (<span>int</span> number <span>in</span> numbers)\r\n        {\r\n            Console.Write(<span>$&quot;<span>{number}</span> &quot;</span>);\r\n        }\r\n        Console.WriteLine();\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tThe following example uses a&nbsp;<code>ref</code>&nbsp;iteration variable to set the value of each item in a stackalloc array. The&nbsp;<code>ref readonly</code>&nbsp;version iterates the collection to print all the values. The&nbsp;<code>readonly</code>declaration uses an implicit local variable declaration. Implicit variable declarations can be used with either&nbsp;<code>ref</code>&nbsp;or&nbsp;<code>ref readonly</code>&nbsp;declarations, as can explicitly typed variable declarations.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>class</span> <span>ForeachRefExample</span>\r\n{\r\n    <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        Span&lt;<span>int</span>&gt; storage = <span>stackalloc</span> <span>int</span>[<span>10</span>];\r\n        <span>int</span> num = <span>0</span>;\r\n        <span>foreach</span> (<span>ref</span> <span>int</span> item <span>in</span> storage)\r\n        {\r\n            item = num++;\r\n        }\r\n\r\n        <span>foreach</span> (<span>ref</span> <span>readonly</span> <span>var</span> item <span>in</span> storage)\r\n        {\r\n            Console.Write(<span>$&quot;<span>{item}</span> &quot;</span>);\r\n        }\r\n        <span>// Output:</span>\r\n        <span>// 0 1 2 3 4 5 6 7 8 9</span>\r\n    }\r\n}</code></pre>"
          },
          {
            "while": "<p>\r\n\tThe&nbsp;<code>while</code>&nbsp;statement executes a statement or a block of statements while a specified Boolean expression evaluates to&nbsp;<code>true</code>. Because that expression is evaluated before each execution of the loop, a&nbsp;<code>while</code>&nbsp;loop executes zero or more times. This differs from the&nbsp;do&nbsp;loop, which executes one or more times.</p>\r\n<p>\r\n\tAt any point within the&nbsp;<code>while</code>&nbsp;statement block, you can break out of the loop by using the&nbsp;breakstatement.</p>\r\n<p>\r\n\tYou can step directly to the evaluation of the&nbsp;<code>while</code>&nbsp;expression by using the&nbsp;continue&nbsp;statement. If the expression evaluates to&nbsp;<code>true</code>, execution continues at the first statement in the loop. Otherwise, execution continues at the first statement after the loop.</p>\r\n<p>\r\n\tYou also can exit a&nbsp;<code>while</code>&nbsp;loop by the&nbsp;goto,&nbsp;return, or&nbsp;throw&nbsp;statements.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example shows the usage of the&nbsp;<code>while</code>&nbsp;statement. Select&nbsp;<span>Run</span>&nbsp;to run the example code. After that you can modify the code and run it again.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>int</span> n = <span>0</span>;\r\n<span>while</span> (n &lt; <span>5</span>)\r\n{\r\n    Console.WriteLine(n);\r\n    n++;\r\n}</code></pre>"
          },
          {
            "break": "<p>\r\n\tThe&nbsp;<code>break</code>&nbsp;statement terminates the closest enclosing loop or&nbsp;switch&nbsp;statement in which it appears. Control is passed to the statement that follows the terminated statement, if any.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tIn this example, the conditional statement contains a counter that is supposed to count from 1 to 100; however, the&nbsp;<code>break</code>&nbsp;statement terminates the loop after 4 counts.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>BreakTest</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>for</span> (<span>int</span> i = <span>1</span>; i &lt;= <span>100</span>; i++)\r\n        {\r\n            <span>if</span> (i == <span>5</span>)\r\n            {\r\n                <span>break</span>;\r\n            }\r\n            Console.WriteLine(i);\r\n        }\r\n\r\n        <span>// Keep the console open in debug mode.</span>\r\n        Console.WriteLine(<span>&quot;Press any key to exit.&quot;</span>);\r\n        Console.ReadKey();\r\n    }\r\n}\r\n<span>/* \r\n Output:\r\n    1\r\n    2\r\n    3\r\n    4  \r\n*/</span>\r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tIn this example, the&nbsp;<code>break</code>&nbsp;statement is used to break out of an inner nested loop, and return control to the outer loop.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>BreakInNestedLoops</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)\r\n    </span>{\r\n\r\n        <span>int</span>[] numbers = { <span>0</span>, <span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>, <span>6</span>, <span>7</span>, <span>8</span>, <span>9</span> };\r\n        <span>char</span>[] letters = { <span>&#39;a&#39;</span>, <span>&#39;b&#39;</span>, <span>&#39;c&#39;</span>, <span>&#39;d&#39;</span>, <span>&#39;e&#39;</span>, <span>&#39;f&#39;</span>, <span>&#39;g&#39;</span>, <span>&#39;h&#39;</span>, <span>&#39;i&#39;</span>, <span>&#39;j&#39;</span> };\r\n\r\n        <span>// Outer loop</span>\r\n        <span>for</span> (<span>int</span> x = <span>0</span>; x &lt; numbers.Length; x++)\r\n        {\r\n            Console.WriteLine(<span>&quot;num = {0}&quot;</span>, numbers[x]);\r\n\r\n            <span>// Inner loop</span>\r\n            <span>for</span> (<span>int</span> y = <span>0</span>; y &lt; letters.Length; y++)\r\n            {\r\n                <span>if</span> (y == x)\r\n                {\r\n                    <span>// Return control to outer loop</span>\r\n                    <span>break</span>;\r\n                }\r\n                Console.Write(<span>&quot; {0} &quot;</span>, letters[y]);\r\n            }\r\n            Console.WriteLine();\r\n        }\r\n\r\n        <span>// Keep the console open in debug mode.</span>\r\n        Console.WriteLine(<span>&quot;Press any key to exit.&quot;</span>);\r\n        Console.ReadKey();\r\n    }\r\n}\r\n\r\n<span>/*\r\n * Output:\r\n    num = 0\r\n\r\n    num = 1\r\n     a\r\n    num = 2\r\n     a  b\r\n    num = 3\r\n     a  b  c\r\n    num = 4\r\n     a  b  c  d\r\n    num = 5\r\n     a  b  c  d  e\r\n    num = 6\r\n     a  b  c  d  e  f\r\n    num = 7\r\n     a  b  c  d  e  f  g\r\n    num = 8\r\n     a  b  c  d  e  f  g  h\r\n    num = 9\r\n     a  b  c  d  e  f  g  h  i\r\n */</span>\r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThis example demonstrates the use of&nbsp;<code>break</code>&nbsp;in a&nbsp;switch&nbsp;statement.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>Switch</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        Console.Write(<span>&quot;Enter your selection (1, 2, or 3): &quot;</span>);\r\n        <span>string</span> s = Console.ReadLine();\r\n        <span>int</span> n = Int32.Parse(s);\r\n\r\n        <span>switch</span> (n)\r\n        {\r\n            <span>case</span> <span>1</span>:\r\n                Console.WriteLine(<span>&quot;Current value is {0}&quot;</span>, <span>1</span>);\r\n                <span>break</span>;\r\n            <span>case</span> <span>2</span>:\r\n                Console.WriteLine(<span>&quot;Current value is {0}&quot;</span>, <span>2</span>);\r\n                <span>break</span>;\r\n            <span>case</span> <span>3</span>:\r\n                Console.WriteLine(<span>&quot;Current value is {0}&quot;</span>, <span>3</span>);\r\n                <span>break</span>;\r\n            <span>default</span>:\r\n                Console.WriteLine(<span>&quot;Sorry, invalid selection.&quot;</span>);\r\n                <span>break</span>;\r\n        }\r\n\r\n        <span>// Keep the console open in debug mode.</span>\r\n        Console.WriteLine(<span>&quot;Press any key to exit.&quot;</span>);\r\n        Console.ReadKey();\r\n    }\r\n}\r\n<span>/*\r\nSample Input: 1\r\n \r\nSample Output:\r\nEnter your selection (1, 2, or 3): 1\r\nCurrent value is 1\r\n*/</span>\r\n</code></pre>\r\n<p>\r\n\tIf you entered&nbsp;<code>4</code>, the output would be:</p>\r\n<div>\r\n\t<span>console:</span></div>\r\n<pre>\r\n<code>Enter your selection (1, 2, or 3): 4\r\nSorry, invalid selection.</code></pre>"
          },
          {
            "continue": "<p>\r\n\tThe&nbsp;<code>continue</code>&nbsp;statement passes control to the next iteration of the enclosing&nbsp;while,&nbsp;do,&nbsp;for, or&nbsp;foreach&nbsp;statement in which it appears.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tIn this example, a counter is initialized to count from 1 to 10. By using the&nbsp;<code>continue</code>&nbsp;statement in conjunction with the expression&nbsp;<code>(i &lt; 9)</code>, the statements between&nbsp;<code>continue</code>&nbsp;and the end of the&nbsp;<code>for</code>&nbsp;body are skipped.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>ContinueTest</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>for</span> (<span>int</span> i = <span>1</span>; i &lt;= <span>10</span>; i++)\r\n        {\r\n            <span>if</span> (i &lt; <span>9</span>)\r\n            {\r\n                <span>continue</span>;\r\n            }\r\n            Console.WriteLine(i);\r\n        }\r\n\r\n        <span>// Keep the console open in debug mode.</span>\r\n        Console.WriteLine(<span>&quot;Press any key to exit.&quot;</span>);\r\n        Console.ReadKey();\r\n    }\r\n}\r\n<span>/*\r\nOutput:\r\n9\r\n10\r\n*/</span></code></pre>"
          },
          {
            "goto": "<p>\r\n\tThe&nbsp;<code>goto</code>&nbsp;statement transfers the program control directly to a labeled statement.</p>\r\n<p>\r\n\tA common use of&nbsp;<code>goto</code>&nbsp;is to transfer control to a specific switch-case label or the default label in a&nbsp;<code>switch</code>&nbsp;statement.</p>\r\n<p>\r\n\tThe&nbsp;<code>goto</code>&nbsp;statement is also useful to get out of deeply nested loops.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example demonstrates using&nbsp;<code>goto</code>&nbsp;in a&nbsp;switch&nbsp;statement.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>SwitchTest</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        Console.WriteLine(<span>&quot;Coffee sizes: 1=Small 2=Medium 3=Large&quot;</span>);\r\n        Console.Write(<span>&quot;Please enter your selection: &quot;</span>);\r\n        <span>string</span> s = Console.ReadLine();\r\n        <span>int</span> n = <span>int</span>.Parse(s);\r\n        <span>int</span> cost = <span>0</span>;\r\n        <span>switch</span> (n)\r\n        {\r\n            <span>case</span> <span>1</span>:\r\n                cost += <span>25</span>;\r\n                <span>break</span>;\r\n            <span>case</span> <span>2</span>:\r\n                cost += <span>25</span>;\r\n                <span>goto</span> <span>case</span> <span>1</span>;\r\n            <span>case</span> <span>3</span>:\r\n                cost += <span>50</span>;\r\n                <span>goto</span> <span>case</span> <span>1</span>;\r\n            <span>default</span>:\r\n                Console.WriteLine(<span>&quot;Invalid selection.&quot;</span>);\r\n                <span>break</span>;\r\n        }\r\n        <span>if</span> (cost != <span>0</span>)\r\n        {\r\n            Console.WriteLine(<span>&quot;Please insert {0} cents.&quot;</span>, cost);\r\n        }\r\n        Console.WriteLine(<span>&quot;Thank you for your business.&quot;</span>);\r\n\r\n        <span>// Keep the console open in debug mode.</span>\r\n        Console.WriteLine(<span>&quot;Press any key to exit.&quot;</span>);\r\n        Console.ReadKey();\r\n    }\r\n}\r\n<span>/*\r\nSample Input:  2\r\n \r\nSample Output:\r\nCoffee sizes: 1=Small 2=Medium 3=Large\r\nPlease enter your selection: 2\r\nPlease insert 50 cents.\r\nThank you for your business.\r\n*/</span>\r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example demonstrates using&nbsp;<code>goto</code>&nbsp;to break out from nested loops.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>class</span> <span>GotoTest1</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>int</span> x = <span>200</span>, y = <span>4</span>;\r\n        <span>int</span> count = <span>0</span>;\r\n        <span>string</span>[,] array = <span>new</span> <span>string</span>[x, y];\r\n\r\n        <span>// Initialize the array:</span>\r\n        <span>for</span> (<span>int</span> i = <span>0</span>; i &lt; x; i++)\r\n\r\n            <span>for</span> (<span>int</span> j = <span>0</span>; j &lt; y; j++)\r\n                array[i, j] = (++count).ToString();\r\n\r\n        <span>// Read input:</span>\r\n        Console.Write(<span>&quot;Enter the number to search for: &quot;</span>);\r\n\r\n        <span>// Input a string:</span>\r\n        <span>string</span> myNumber = Console.ReadLine();\r\n\r\n        <span>// Search:</span>\r\n        <span>for</span> (<span>int</span> i = <span>0</span>; i &lt; x; i++)\r\n        {\r\n            <span>for</span> (<span>int</span> j = <span>0</span>; j &lt; y; j++)\r\n            {\r\n                <span>if</span> (array[i, j].Equals(myNumber))\r\n                {\r\n                    <span>goto</span> Found;\r\n                }\r\n            }\r\n        }\r\n\r\n        Console.WriteLine(<span>&quot;The number {0} was not found.&quot;</span>, myNumber);\r\n        <span>goto</span> Finish;\r\n\r\n    Found:\r\n        Console.WriteLine(<span>&quot;The number {0} is found.&quot;</span>, myNumber);\r\n\r\n    Finish:\r\n        Console.WriteLine(<span>&quot;End of search.&quot;</span>);\r\n\r\n\r\n        <span>// Keep the console open in debug mode.</span>\r\n        Console.WriteLine(<span>&quot;Press any key to exit.&quot;</span>);\r\n        Console.ReadKey();\r\n    }\r\n}\r\n<span>/*\r\nSample Input: 44\r\n \r\nSample Output\r\nEnter the number to search for: 44\r\nThe number 44 is found.\r\nEnd of search.\r\n*/</span></code></pre>"
          },
          {
            "return": "<p>\r\n\tThe&nbsp;<code>return</code>&nbsp;statement terminates execution of the method in which it appears and returns control to the calling method. It can also return an optional value. If the method is a&nbsp;<code>void</code>&nbsp;type, the&nbsp;<code>return</code>&nbsp;statement can be omitted.</p>\r\n<p>\r\n\tIf the return statement is inside a&nbsp;<code>try</code>&nbsp;block, the&nbsp;<code>finally</code>&nbsp;block, if one exists, will be executed before control returns to the calling method.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tIn the following example, the method&nbsp;<code>CalculateArea()</code>&nbsp;returns the local variable&nbsp;<code>area</code>&nbsp;as a&nbsp;doublevalue.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>ReturnTest</span>\r\n{\r\n    <span><span>static</span> <span>double</span> <span>CalculateArea</span>(<span><span>int</span> r</span>)\r\n    </span>{\r\n        <span>double</span> area = r * r * Math.PI;\r\n        <span>return</span> area;\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>int</span> radius = <span>5</span>;\r\n        <span>double</span> result = CalculateArea(radius);\r\n        Console.WriteLine(<span>&quot;The area is {0:0.00}&quot;</span>, result);\r\n\r\n        <span>// Keep the console open in debug mode.</span>\r\n        Console.WriteLine(<span>&quot;Press any key to exit.&quot;</span>);\r\n        Console.ReadKey();\r\n    }\r\n}\r\n<span>// Output: The area is 78.54</span></code></pre>"
          },
          {
            "throw": "<p>\r\n\tSignals the occurrence of an exception during program execution.</p>\r\n<h2>\r\n\tRemarks</h2>\r\n<p>\r\n\tThe syntax of&nbsp;<code>throw</code>&nbsp;is:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>throw</span> [e]\r\n</code></pre>\r\n<p>\r\n\twhere&nbsp;<code>e</code>&nbsp;is an instance of a class derived from&nbsp;System.Exception. The following example uses the&nbsp;<code>throw</code>&nbsp;statement to throw an&nbsp;IndexOutOfRangeException&nbsp;if the argument passed to a method named&nbsp;<code>GetNumber</code>&nbsp;does not correspond to a valid index of an internal array.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System;\r\n\r\n<span>public</span> <span>class</span> <span>NumberGenerator</span>\r\n{\r\n   <span>int</span>[] numbers = { <span>2</span>, <span>4</span>, <span>6</span>, <span>8</span>, <span>10</span>, <span>12</span>, <span>14</span>, <span>16</span>, <span>18</span>, <span>20</span> };\r\n   \r\n   <span><span>public</span> <span>int</span> <span>GetNumber</span>(<span><span>int</span> index</span>)\r\n   </span>{\r\n      <span>if</span> (index &lt; <span>0</span> || index &gt;= numbers.Length) {\r\n         <span>throw</span> <span>new</span> IndexOutOfRangeException();\r\n      }\r\n      <span>return</span> numbers[index];\r\n   }\r\n}\r\n</code></pre>\r\n<p>\r\n\tMethod callers then use a&nbsp;<code>try-catch</code>&nbsp;or&nbsp;<code>try-catch-finally</code>&nbsp;block to handle the thrown exception. The following example handles the exception thrown by the&nbsp;<code>GetNumber</code>&nbsp;method.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System;\r\n\r\n<span>public</span> <span>class</span> <span>Example</span>\r\n{\r\n   <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>()\r\n   </span>{\r\n      <span>var</span> gen = <span>new</span> NumberGenerator();\r\n      <span>int</span> index = <span>10</span>;\r\n      <span>try</span> {\r\n          <span>int</span> <span>value</span> = gen.GetNumber(index);\r\n          Console.WriteLine(<span>$&quot;Retrieved <span>{<span>value</span>}</span>&quot;</span>);\r\n      }\r\n      <span>catch</span> (IndexOutOfRangeException e) \r\n      {\r\n         Console.WriteLine(<span>$&quot;<span>{e.GetType().Name}</span>: <span>{index}</span> is outside the bounds of the array&quot;</span>);\r\n      }\r\n   }\r\n}\r\n<span>// The example displays the following output:</span>\r\n<span>//        IndexOutOfRangeException: 10 is outside the bounds of the array</span>\r\n</code></pre>\r\n<h2>\r\n\tRe-throwing an exception</h2>\r\n<p>\r\n\t<code>throw</code>&nbsp;can also be used in a&nbsp;<code>catch</code>&nbsp;block to re-throw an exception handled in a&nbsp;<code>catch</code>&nbsp;block. In this case,&nbsp;<code>throw</code>&nbsp;does not take an exception operand. It is most useful when a method passes on an argument from a caller to some other library method, and the library method throws an exception that must be passed on to the caller. For example, the following example re-throws an&nbsp;NullReferenceException&nbsp;that is thrown when attempting to retrieve the first character of an uninitialized string.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System;\r\n\r\n<span>public</span> <span>class</span> <span>Sentence</span>\r\n{\r\n   <span><span>public</span> <span>Sentence</span>(<span><span>string</span> s</span>)\r\n   </span>{\r\n      Value = s;\r\n   }\r\n\r\n   <span>public</span> <span>string</span> Value { <span>get</span>; <span>set</span>; }\r\n\r\n   <span><span>public</span> <span>char</span> <span>GetFirstCharacter</span>()\r\n   </span>{\r\n      <span>try</span> {\r\n         <span>return</span> Value[<span>0</span>];\r\n        }\r\n      <span>catch</span> (NullReferenceException e) {\r\n         <span>throw</span>;   \r\n      } \r\n   }\r\n}\r\n\r\n<span>public</span> <span>class</span> <span>Example</span> \r\n{\r\n   <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>()\r\n   </span>{\r\n      <span>var</span> s = <span>new</span> Sentence(<span>null</span>);\r\n      Console.WriteLine(<span>$&quot;The first character is <span>{s.GetFirstCharacter()}</span>&quot;</span>);\r\n   }\r\n}\r\n<span>// The example displays the following output:</span>\r\n<span>//    Unhandled Exception: System.NullReferenceException: Object reference not set to an instance of an object.</span>\r\n<span>//       at Sentence.GetFirstCharacter()</span>\r\n<span>//       at Example.Main()</span>\r\n</code></pre>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Important</p>\r\n\t<p>\r\n\t\tYou can also use the&nbsp;<code>throw e</code>&nbsp;syntax in a&nbsp;<code>catch</code>&nbsp;block to instantiate a new exception that you pass on to the caller. In this case, the stack trace of the original exception, which is available from the&nbsp;StackTrace&nbsp;property, is not preserved.</p>\r\n</div>\r\n<h2>\r\n\tThe&nbsp;<code>throw</code>&nbsp;expression</h2>\r\n<p>\r\n\tStarting with C# 7.0,&nbsp;<code>throw</code>&nbsp;can be used as an expression as well as a statement. This allows an exception to be thrown in contexts that were previously unsupported. These include:</p>\r\n<ul>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tthe conditional operator. The following example uses a&nbsp;<code>throw</code>&nbsp;expression to throw an&nbsp;ArgumentException&nbsp;if a method is passed an empty string array. Before C# 7.0, this logic would need to appear in an&nbsp;<code>if</code>/<code>else</code>&nbsp;statement.</p>\r\n\t\t<div>\r\n\t\t\t&nbsp;</div>\r\n\t\t<pre>\r\n\t\t<code><span><span>private</span> <span>static</span> <span>void</span> <span>DisplayFirstNumber</span>(<span><span>string</span>[] args</span>)\r\n</span>{\r\n   <span>string</span> arg = args.Length &gt;= <span>1</span> ? args[<span>0</span>] : \r\n                              <span>throw</span> <span>new</span> ArgumentException(<span>&quot;You must supply an argument&quot;</span>);\r\n   <span>if</span> (Int64.TryParse(arg, <span>out</span> <span>var</span> number))\r\n      Console.WriteLine(<span>$&quot;You entered <span>{number:F0}</span>&quot;</span>);\r\n   <span>else</span>\r\n      Console.WriteLine(<span>$&quot;<span>{arg}</span> is not a number.&quot;</span>);                            \r\n  \r\n}\r\n</code></pre>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tthe null-coalescing operator. In the following example, a&nbsp;<code>throw</code>&nbsp;expression is used with a null-coalescing operator to throw an exception if the string assigned to a&nbsp;<code>Name</code>&nbsp;property is&nbsp;<code>null</code>.</p>\r\n\t\t<div>\r\n\t\t\t&nbsp;</div>\r\n\t\t<pre>\r\n\t\t<code><span>public</span> <span>string</span> Name\r\n{\r\n    <span>get</span> =&gt; name;\r\n    <span>set</span> =&gt; name = <span>value</span> ?? \r\n        <span>throw</span> <span>new</span> ArgumentNullException(<span>&quot;Name cannot be null&quot;</span>, <span>nameof</span>(<span>value</span>));\r\n}   \r\n</code></pre>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tan expression-bodied&nbsp;lambda&nbsp;or method. The following example illustrates an expression-bodied method that throws an&nbsp;InvalidCastException&nbsp;because a conversion to a&nbsp;DateTime&nbsp;value is not supported.</p>\r\n\t\t<div>\r\n\t\t\t&nbsp;</div>\r\n\t\t<pre>\r\n\t\t<code><span>DateTime <span>ToDateTime</span>(<span>IFormatProvider provider</span>) </span>=&gt; \r\n         <span>throw</span> <span>new</span> InvalidCastException(<span>&quot;Conversion to a DateTime is not supported.&quot;</span>);</code></pre>\r\n\t</li>\r\n</ul>"
          },
          {
            "try-catch": "<p>\r\n\tThe try-catch statement consists of a&nbsp;<code>try</code>&nbsp;block followed by one or more&nbsp;<code>catch</code>&nbsp;clauses, which specify handlers for different exceptions.</p>\r\n<h2>\r\n\tRemarks</h2>\r\n<p>\r\n\tWhen an exception is thrown, the common language runtime (CLR) looks for the&nbsp;<code>catch</code>&nbsp;statement that handles this exception. If the currently executing method does not contain such a&nbsp;<code>catch</code>&nbsp;block, the CLR looks at the method that called the current method, and so on up the call stack. If no&nbsp;<code>catch</code>&nbsp;block is found, then the CLR displays an unhandled exception message to the user and stops execution of the program.</p>\r\n<p>\r\n\tThe&nbsp;<code>try</code>&nbsp;block contains the guarded code that may cause the exception. The block is executed until an exception is thrown or it is completed successfully. For example, the following attempt to cast a&nbsp;<code>null</code>&nbsp;object raises the&nbsp;NullReferenceException&nbsp;exception:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>object</span> o2 = <span>null</span>;\r\n<span>try</span>\r\n{\r\n    <span>int</span> i2 = (<span>int</span>)o2;   <span>// Error</span>\r\n}\r\n</code></pre>\r\n<p>\r\n\tAlthough the&nbsp;<code>catch</code>&nbsp;clause can be used without arguments to catch any type of exception, this usage is not recommended. In general, you should only catch those exceptions that you know how to recover from. Therefore, you should always specify an object argument derived from&nbsp;System.Exception&nbsp;For example:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>catch</span> (InvalidCastException e)\r\n{\r\n}\r\n</code></pre>\r\n<p>\r\n\tIt is possible to use more than one specific&nbsp;<code>catch</code>&nbsp;clause in the same try-catch statement. In this case, the order of the&nbsp;<code>catch</code>&nbsp;clauses is important because the&nbsp;<code>catch</code>&nbsp;clauses are examined in order. Catch the more specific exceptions before the less specific ones. The compiler produces an error if you order your catch blocks so that a later block can never be reached.</p>\r\n<p>\r\n\tUsing&nbsp;<code>catch</code>&nbsp;arguments is one way to filter for the exceptions you want to handle. You can also use an exception filter that further examines the exception to decide whether to handle it. If the exception filter returns false, then the search for a handler continues.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>catch</span> (ArgumentException e) when (e.ParamName == <span>&quot;&hellip;&quot;</span>)\r\n{\r\n}\r\n</code></pre>\r\n<p>\r\n\tException filters are preferable to catching and rethrowing (explained below) because filters leave the stack unharmed. If a later handler dumps the stack, you can see where the exception originally came from, rather than just the last place it was rethrown. A common use of exception filter expressions is logging. You can create a filter that always returns false that also outputs to a log, you can log exceptions as they go by without having to handle them and rethrow.</p>\r\n<p>\r\n\tA&nbsp;throw&nbsp;statement can be used in a&nbsp;<code>catch</code>&nbsp;block to re-throw the exception that is caught by the&nbsp;<code>catch</code>&nbsp;statement. The following example extracts source information from an&nbsp;IOExceptionexception, and then throws the exception to the parent method.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>catch</span> (FileNotFoundException e)\r\n{\r\n    <span>// FileNotFoundExceptions are handled here.</span>\r\n}\r\n<span>catch</span> (IOException e)\r\n{\r\n&nbsp;&nbsp;&nbsp; <span>// Extract some information from this exception, and then </span>\r\n&nbsp;&nbsp;&nbsp;&nbsp;<span>// throw it to the parent method.</span>\r\n&nbsp;&nbsp;&nbsp; <span>if</span> (e.Source != <span>null</span>)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(<span>&quot;IOException source: {0}&quot;</span>, e.Source);\r\n&nbsp;&nbsp;&nbsp; <span>throw</span>;\r\n}\r\n</code></pre>\r\n<p>\r\n\tYou can catch one exception and throw a different exception. When you do this, specify the exception that you caught as the inner exception, as shown in the following example.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>catch</span> (InvalidCastException e) \r\n{\r\n    <span>// Perform some action here, and then throw a new exception.</span>\r\n    <span>throw</span> <span>new</span> YourCustomException(<span>&quot;Put your error message here.&quot;</span>, e);\r\n}\r\n</code></pre>\r\n<p>\r\n\tYou can also re-throw an exception when a specified condition is true, as shown in the following example.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>catch</span> (InvalidCastException e)\r\n{\r\n    <span>if</span> (e.Data == <span>null</span>)\r\n    {\r\n        <span>throw</span>;\r\n    }\r\n    <span>else</span>\r\n    {\r\n        <span>// Take some action.</span>\r\n    }\r\n}\r\n</code></pre>\r\n<div>\r\n\t<blockquote>\r\n\t\t<p>\r\n\t\t\t&nbsp;Note</p>\r\n\t\t<p>\r\n\t\t\tIt is also possible to use an exception filter to get a similar result in an often cleaner fashion (as well as not modifying the stack, as explained earlier in this document). The following example has a similar behavior for callers as the previous example. The function throws the&nbsp;<code>InvalidCastException</code>&nbsp;back to the caller when&nbsp;<code>e.Data</code>&nbsp;is&nbsp;<code>null</code>.</p>\r\n\t</blockquote>\r\n\t<pre>\r\n\t<code><span>catch</span> (InvalidCastException e) when (e.Data != <span>null</span>) \r\n{\r\n    <span>// Take some action.</span>\r\n}\r\n</code></pre>\r\n</div>\r\n<p>\r\n\tFrom inside a&nbsp;<code>try</code>&nbsp;block, initialize only variables that are declared therein. Otherwise, an exception can occur before the execution of the block is completed. For example, in the following code example, the variable&nbsp;<code>n</code>&nbsp;is initialized inside the&nbsp;<code>try</code>&nbsp;block. An attempt to use this variable outside the&nbsp;<code>try</code>&nbsp;block in the&nbsp;<code>Write(n)</code>&nbsp;statement will generate a compiler error.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>static</span> <span>void</span> <span>Main</span>() \r\n</span>{\r\n    <span>int</span> n;\r\n    <span>try</span> \r\n    {\r\n        <span>// Do not initialize this variable here.</span>\r\n        n = <span>123</span>;\r\n    }\r\n    <span>catch</span>\r\n    {\r\n    }\r\n    <span>// Error: Use of unassigned local variable &#39;n&#39;.</span>\r\n    Console.Write(n);\r\n}\r\n</code></pre>\r\n<p>\r\n\tFor more information about catch, see&nbsp;try-catch-finally.</p>\r\n<h2>\r\n\tExceptions in Async Methods</h2>\r\n<p>\r\n\tAn async method is marked by an&nbsp;async&nbsp;modifier and usually contains one or more await expressions or statements. An await expression applies the&nbsp;await&nbsp;operator to a&nbsp;Task&nbsp;or&nbsp;Task&lt;TResult&gt;.</p>\r\n<p>\r\n\tWhen control reaches an&nbsp;<code>await</code>&nbsp;in the async method, progress in the method is suspended until the awaited task completes. When the task is complete, execution can resume in the method. For more information, see&nbsp;Asynchronous Programming with async and await&nbsp;and&nbsp;Control Flow in Async Programs.</p>\r\n<p>\r\n\tThe completed task to which&nbsp;<code>await</code>&nbsp;is applied might be in a faulted state because of an unhandled exception in the method that returns the task. Awaiting the task throws an exception. A task can also end up in a canceled state if the asynchronous process that returns it is canceled. Awaiting a canceled task throws an&nbsp;<code>OperationCanceledException</code>. For more information about how to cancel an asynchronous process, see&nbsp;Fine-Tuning Your Async Application.</p>\r\n<p>\r\n\tTo catch the exception, await the task in a&nbsp;<code>try</code>&nbsp;block, and catch the exception in the associated&nbsp;<code>catch</code>&nbsp;block. For an example, see the &quot;Example&quot; section.</p>\r\n<p>\r\n\tA task can be in a faulted state because multiple exceptions occurred in the awaited async method. For example, the task might be the result of a call to&nbsp;Task.WhenAll. When you await such a task, only one of the exceptions is caught, and you can&#39;t predict which exception will be caught. For an example, see the &quot;Example&quot; section.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tIn the following example, the&nbsp;<code>try</code>&nbsp;block contains a call to the&nbsp;<code>ProcessString</code>&nbsp;method that may cause an exception. The&nbsp;<code>catch</code>&nbsp;clause contains the exception handler that just displays a message on the screen. When the&nbsp;<code>throw</code>&nbsp;statement is called from inside&nbsp;<code>MyMethod</code>, the system looks for the&nbsp;<code>catch</code>&nbsp;statement and displays the message&nbsp;<code>Exception caught</code>.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>TryFinallyTest</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>ProcessString</span>(<span><span>string</span> s</span>)\r\n    </span>{\r\n        <span>if</span> (s == <span>null</span>)\r\n        {\r\n            <span>throw</span> <span>new</span> ArgumentNullException();\r\n        }\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>string</span> s = <span>null</span>; <span>// For demonstration purposes.</span>\r\n\r\n        <span>try</span>\r\n        {               \r\n            ProcessString(s);\r\n        }\r\n        <span>catch</span> (Exception e)\r\n        {\r\n            Console.WriteLine(<span>&quot;{0} Exception caught.&quot;</span>, e);\r\n        }\r\n    }\r\n}\r\n<span>/*\r\nOutput:\r\nSystem.ArgumentNullException: Value cannot be null.\r\n   at TryFinallyTest.Main() Exception caught.\r\n * */</span>\r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tIn the following example, two catch blocks are used, and the most specific exception, which comes first, is caught.</p>\r\n<p>\r\n\tTo catch the least specific exception, you can replace the throw statement in&nbsp;<code>ProcessString</code>&nbsp;with the following statement:&nbsp;<code>throw new Exception()</code>.</p>\r\n<p>\r\n\tIf you place the least-specific catch block first in the example, the following error message appears:&nbsp;<code>A previous catch clause already catches all exceptions of this or a super type (&#39;System.Exception&#39;)</code>.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>ThrowTest3</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>ProcessString</span>(<span><span>string</span> s</span>)\r\n    </span>{\r\n        <span>if</span> (s == <span>null</span>)\r\n        {\r\n            <span>throw</span> <span>new</span> ArgumentNullException();\r\n        }\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>try</span>\r\n        {\r\n            <span>string</span> s = <span>null</span>;\r\n            ProcessString(s);\r\n        }\r\n        <span>// Most specific:</span>\r\n        <span>catch</span> (ArgumentNullException e)\r\n        {\r\n            Console.WriteLine(<span>&quot;{0} First exception caught.&quot;</span>, e);\r\n        }\r\n        <span>// Least specific:</span>\r\n        <span>catch</span> (Exception e)\r\n        {\r\n            Console.WriteLine(<span>&quot;{0} Second exception caught.&quot;</span>, e);\r\n        }\r\n    }\r\n}\r\n<span>/*\r\n Output:\r\n System.ArgumentNullException: Value cannot be null.\r\n at Test.ThrowTest3.ProcessString(String s) ... First exception caught.\r\n*/</span>\r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example illustrates exception handling for async methods. To catch an exception that an async task throws, place the&nbsp;<code>await</code>&nbsp;expression in a&nbsp;<code>try</code>&nbsp;block, and catch the exception in a&nbsp;<code>catch</code>&nbsp;block.</p>\r\n<p>\r\n\tUncomment the&nbsp;<code>throw new Exception</code>&nbsp;line in the example to demonstrate exception handling. The task&#39;s&nbsp;<code>IsFaulted</code>&nbsp;property is set to&nbsp;<code>True</code>, the task&#39;s&nbsp;<code>Exception.InnerException</code>&nbsp;property is set to the exception, and the exception is caught in the&nbsp;<code>catch</code>&nbsp;block.</p>\r\n<p>\r\n\tUncomment the&nbsp;<code>throw new OperationCancelledException</code>&nbsp;line to demonstrate what happens when you cancel an asynchronous process. The task&#39;s&nbsp;<code>IsCanceled</code>&nbsp;property is set to&nbsp;<code>true</code>, and the exception is caught in the&nbsp;<code>catch</code>&nbsp;block. Under some conditions that don&#39;t apply to this example, the task&#39;s&nbsp;<code>IsFaulted</code>&nbsp;property is set to&nbsp;<code>true</code>&nbsp;and&nbsp;<code>IsCanceled</code>&nbsp;is set to&nbsp;<code>false</code>.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>public</span> <span>async</span> Task <span>DoSomethingAsync</span>()\r\n</span>{\r\n    Task&lt;<span>string</span>&gt; theTask = DelayAsync();\r\n\r\n    <span>try</span>\r\n    {\r\n        <span>string</span> result = <span>await</span> theTask;\r\n        Debug.WriteLine(<span>&quot;Result: &quot;</span> + result);\r\n    }\r\n    <span>catch</span> (Exception ex)\r\n    {\r\n        Debug.WriteLine(<span>&quot;Exception Message: &quot;</span> + ex.Message);\r\n    }\r\n    Debug.WriteLine(<span>&quot;Task IsCanceled: &quot;</span> + theTask.IsCanceled);\r\n    Debug.WriteLine(<span>&quot;Task IsFaulted:  &quot;</span> + theTask.IsFaulted);\r\n    <span>if</span> (theTask.Exception != <span>null</span>)\r\n    {\r\n        Debug.WriteLine(<span>&quot;Task Exception Message: &quot;</span>\r\n            + theTask.Exception.Message);\r\n        Debug.WriteLine(<span>&quot;Task Inner Exception Message: &quot;</span>\r\n            + theTask.Exception.InnerException.Message);\r\n    }\r\n}\r\n\r\n<span><span>private</span> <span>async</span> Task&lt;<span>string</span>&gt; <span>DelayAsync</span>()\r\n</span>{\r\n    <span>await</span> Task.Delay(<span>100</span>);\r\n\r\n    <span>// Uncomment each of the following lines to</span>\r\n    <span>// demonstrate exception handling.</span>\r\n\r\n    <span>//throw new OperationCanceledException(&quot;canceled&quot;);</span>\r\n    <span>//throw new Exception(&quot;Something happened.&quot;);</span>\r\n    <span>return</span> <span>&quot;Done&quot;</span>;\r\n}\r\n\r\n<span>// Output when no exception is thrown in the awaited method:</span>\r\n<span>//   Result: Done</span>\r\n<span>//   Task IsCanceled: False</span>\r\n<span>//   Task IsFaulted:  False</span>\r\n\r\n<span>// Output when an Exception is thrown in the awaited method:</span>\r\n<span>//   Exception Message: Something happened.</span>\r\n<span>//   Task IsCanceled: False</span>\r\n<span>//   Task IsFaulted:  True</span>\r\n<span>//   Task Exception Message: One or more errors occurred.</span>\r\n<span>//   Task Inner Exception Message: Something happened.</span>\r\n\r\n<span>// Output when a OperationCanceledException or TaskCanceledException</span>\r\n<span>// is thrown in the awaited method:</span>\r\n<span>//   Exception Message: canceled</span>\r\n<span>//   Task IsCanceled: True</span>\r\n<span>//   Task IsFaulted:  False</span>\r\n</code></pre>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example illustrates exception handling where multiple tasks can result in multiple exceptions. The&nbsp;<code>try</code>&nbsp;block awaits the task that&#39;s returned by a call to&nbsp;Task.WhenAll. The task is complete when the three tasks to which WhenAll is applied are complete.</p>\r\n<p>\r\n\tEach of the three tasks causes an exception. The&nbsp;<code>catch</code>&nbsp;block iterates through the exceptions, which are found in the&nbsp;<code>Exception.InnerExceptions</code>&nbsp;property of the task that was returned by&nbsp;Task.WhenAll.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>public</span> <span>async</span> Task <span>DoMultipleAsync</span>()\r\n</span>{\r\n    Task theTask1 = ExcAsync(info: <span>&quot;First Task&quot;</span>);\r\n    Task theTask2 = ExcAsync(info: <span>&quot;Second Task&quot;</span>);\r\n    Task theTask3 = ExcAsync(info: <span>&quot;Third Task&quot;</span>);\r\n\r\n    Task allTasks = Task.WhenAll(theTask1, theTask2, theTask3);\r\n\r\n    <span>try</span>\r\n    {\r\n        <span>await</span> allTasks;\r\n    }\r\n    <span>catch</span> (Exception ex)\r\n    {\r\n        Debug.WriteLine(<span>&quot;Exception: &quot;</span> + ex.Message);\r\n        Debug.WriteLine(<span>&quot;Task IsFaulted: &quot;</span> + allTasks.IsFaulted);\r\n        <span>foreach</span> (<span>var</span> inEx <span>in</span> allTasks.Exception.InnerExceptions)\r\n        {\r\n            Debug.WriteLine(<span>&quot;Task Inner Exception: &quot;</span> + inEx.Message);\r\n        }\r\n    }\r\n}\r\n\r\n<span><span>private</span> <span>async</span> Task <span>ExcAsync</span>(<span><span>string</span> info</span>)\r\n</span>{\r\n    <span>await</span> Task.Delay(<span>100</span>);\r\n    \r\n    <span>throw</span> <span>new</span> Exception(<span>&quot;Error-&quot;</span> + info);\r\n}\r\n\r\n<span>// Output:</span>\r\n<span>//   Exception: Error-First Task</span>\r\n<span>//   Task IsFaulted: True</span>\r\n<span>//   Task Inner Exception: Error-First Task</span>\r\n<span>//   Task Inner Exception: Error-Second Task</span>\r\n<span>//   Task Inner Exception: Error-Third Task</span></code></pre>"
          },
          {
            "try-finally": "<p>\r\n\tBy using a&nbsp;<code>finally</code>&nbsp;block, you can clean up any resources that are allocated in a&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch\" target=\"_blank\">try</a>&nbsp;block, and you can run code even if an exception occurs in the&nbsp;<code>try</code>&nbsp;block. Typically, the statements of a&nbsp;<code>finally</code>block run when control leaves a&nbsp;<code>try</code>&nbsp;statement. The transfer of control can occur as a result of normal execution, of execution of a&nbsp;<code>break</code>,&nbsp;<code>continue</code>,&nbsp;<code>goto</code>, or&nbsp;<code>return</code>&nbsp;statement, or of propagation of an exception out of the&nbsp;<code>try</code>&nbsp;statement.</p>\r\n<p>\r\n\tWithin a handled exception, the associated&nbsp;<code>finally</code>&nbsp;block is guaranteed to be run. However, if the exception is unhandled, execution of the&nbsp;<code>finally</code>&nbsp;block is dependent on how the exception unwind operation is triggered. That, in turn, is dependent on how your computer is set up.</p>\r\n<p>\r\n\tUsually, when an unhandled exception ends an application, whether or not the&nbsp;<code>finally</code>&nbsp;block is run is not important. However, if you have statements in a&nbsp;<code>finally</code>&nbsp;block that must be run even in that situation, one solution is to add a&nbsp;<code>catch</code>&nbsp;block to the&nbsp;<code>try</code>-<code>finally</code>&nbsp;statement. Alternatively, you can catch the exception that might be thrown in the&nbsp;<code>try</code>&nbsp;block of a&nbsp;<code>try</code>-<code>finally</code>&nbsp;statement higher up the call stack. That is, you can catch the exception in the method that calls the method that contains the&nbsp;<code>try</code>-<code>finally</code>&nbsp;statement, or in the method that calls that method, or in any method in the call stack. If the exception is not caught, execution of the&nbsp;<code>finally</code>&nbsp;block depends on whether the operating system chooses to trigger an exception unwind operation.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tIn the following example, an invalid conversion statement causes a&nbsp;<code>System.InvalidCastException</code>exception. The exception is unhandled.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>class</span> <span>ThrowTestA</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>int</span> i = <span>123</span>;\r\n        <span>string</span> s = <span>&quot;Some string&quot;</span>;\r\n        <span>object</span> obj = s;\r\n\r\n        <span>try</span>\r\n        {\r\n            <span>// Invalid conversion; obj contains a string, not a numeric type.</span>\r\n            i = (<span>int</span>)obj;\r\n\r\n            <span>// The following statement is not run.</span>\r\n            Console.WriteLine(<span>&quot;WriteLine at the end of the try block.&quot;</span>);\r\n        }\r\n        <span>finally</span>\r\n        {\r\n            <span>// To run the program in Visual Studio, type CTRL+F5. Then </span>\r\n            <span>// click Cancel in the error dialog.</span>\r\n            Console.WriteLine(<span>&quot;\\nExecution of the finally block after an unhandled\\n&quot;</span> +\r\n                <span>&quot;error depends on how the exception unwind operation is triggered.&quot;</span>);\r\n            Console.WriteLine(<span>&quot;i = {0}&quot;</span>, i);\r\n        }\r\n    }\r\n    <span>// Output:</span>\r\n    <span>// Unhandled Exception: System.InvalidCastException: Specified cast is not valid.</span>\r\n    <span>//</span>\r\n    <span>// Execution of the finally block after an unhandled</span>\r\n    <span>// error depends on how the exception unwind operation is triggered.</span>\r\n    <span>// i = 123</span>\r\n}\r\n</code></pre>\r\n<p>\r\n\tIn the following example, an exception from the&nbsp;<code>TryCast</code>&nbsp;method is caught in a method farther up the call stack.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>class</span> <span>ThrowTestB</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>try</span>\r\n        {\r\n            <span>// TryCast produces an unhandled exception.</span>\r\n            TryCast();\r\n        }\r\n        <span>catch</span> (Exception ex)\r\n        {\r\n            <span>// Catch the exception that is unhandled in TryCast.</span>\r\n            Console.WriteLine\r\n                (<span>&quot;Catching the {0} exception triggers the finally block.&quot;</span>,\r\n                ex.GetType());\r\n\r\n            <span>// Restore the original unhandled exception. You might not</span>\r\n            <span>// know what exception to expect, or how to handle it, so pass </span>\r\n            <span>// it on.</span>\r\n            <span>throw</span>;\r\n        }\r\n    }\r\n\r\n    <span><span>public</span> <span>static</span> <span>void</span> <span>TryCast</span>()\r\n    </span>{\r\n        <span>int</span> i = <span>123</span>;\r\n        <span>string</span> s = <span>&quot;Some string&quot;</span>;\r\n        <span>object</span> obj = s;\r\n\r\n        <span>try</span>\r\n        {\r\n            <span>// Invalid conversion; obj contains a string, not a numeric type.</span>\r\n            i = (<span>int</span>)obj;\r\n\r\n            <span>// The following statement is not run.</span>\r\n            Console.WriteLine(<span>&quot;WriteLine at the end of the try block.&quot;</span>);\r\n        }\r\n        <span>finally</span>\r\n        {\r\n            <span>// Report that the finally block is run, and show that the value of</span>\r\n            <span>// i has not been changed.</span>\r\n            Console.WriteLine(<span>&quot;\\nIn the finally block in TryCast, i = {0}.\\n&quot;</span>, i);\r\n        }\r\n    }\r\n    <span>// Output:</span>\r\n    <span>// In the finally block in TryCast, i = 123.</span>\r\n\r\n    <span>// Catching the System.InvalidCastException exception triggers the finally block.</span>\r\n\r\n    <span>// Unhandled Exception: System.InvalidCastException: Specified cast is not valid.</span>\r\n}</code></pre>"
          },
          {
            "try-catch-finally": "<p>\r\n\tA common usage of&nbsp;<code>catch</code>&nbsp;and&nbsp;<code>finally</code>&nbsp;together is to obtain and use resources in a&nbsp;<code>try</code>&nbsp;block, deal with exceptional circumstances in a&nbsp;<code>catch</code>&nbsp;block, and release the resources in the&nbsp;<code>finally</code>block.</p>\r\n<p>\r\n\tFor more information and examples on re-throwing exceptions, see&nbsp;try-catch&nbsp;and&nbsp;Throwing Exceptions. For more information about the&nbsp;<code>finally</code>&nbsp;block, see&nbsp;try-finally.</p>\r\n<h2>\r\n\tExample</h2>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>class</span> <span>EHClass</span>\r\n{\r\n    <span><span>void</span> <span>ReadFile</span>(<span><span>int</span> index</span>)\r\n    </span>{\r\n        <span>// To run this code, substitute a valid path from your local machine</span>\r\n        <span>string</span> path = <span>@&quot;c:\\users\\public\\test.txt&quot;</span>;\r\n        System.IO.StreamReader file = <span>new</span> System.IO.StreamReader(path);\r\n        <span>char</span>[] buffer = <span>new</span> <span>char</span>[<span>10</span>];\r\n        <span>try</span>\r\n        {\r\n            file.ReadBlock(buffer, index, buffer.Length);\r\n        }\r\n        <span>catch</span> (System.IO.IOException e)\r\n        {\r\n            Console.WriteLine(<span>&quot;Error reading from {0}. Message = {1}&quot;</span>, path, e.Message);\r\n        }\r\n        \r\n        <span>finally</span>\r\n        {\r\n            <span>if</span> (file != <span>null</span>)\r\n            {\r\n                file.Close();\r\n            }\r\n        }\r\n        <span>// Do something with buffer...</span>\r\n    }\r\n\r\n}</code></pre>"
          },
          {
            "checked": "<p>\r\n\tThe&nbsp;<code>checked</code>&nbsp;keyword is used to explicitly enable overflow checking for integral-type arithmetic operations and conversions.</p>\r\n<p>\r\n\tBy default, an expression that contains only constant values causes a compiler error if the expression produces a value that is outside the range of the destination type. If the expression contains one or more non-constant values, the compiler does not detect the overflow. Evaluating the expression assigned to&nbsp;<code>i2</code>&nbsp;in the following example does not cause a compiler error.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// The following example causes compiler error CS0220 because 2147483647</span>\r\n<span>// is the maximum value for integers. </span>\r\n<span>//int i1 = 2147483647 + 10;</span>\r\n\r\n<span>// The following example, which includes variable ten, does not cause</span>\r\n<span>// a compiler error.</span>\r\n<span>int</span> ten = <span>10</span>;\r\n<span>int</span> i2 = <span>2147483647</span> + ten;\r\n\r\n<span>// By default, the overflow in the previous statement also does</span>\r\n<span>// not cause a run-time exception. The following line displays </span>\r\n<span>// -2,147,483,639 as the sum of 2,147,483,647 and 10.</span>\r\nConsole.WriteLine(i2);\r\n</code></pre>\r\n<p>\r\n\tBy default, these non-constant expressions are not checked for overflow at run time either, and they do not raise overflow exceptions. The previous example displays -2,147,483,639 as the sum of two positive integers.</p>\r\n<p>\r\n\tOverflow checking can be enabled by compiler options, environment configuration, or use of the&nbsp;<code>checked</code>&nbsp;keyword. The following examples demonstrate how to use a&nbsp;<code>checked</code>&nbsp;expression or a&nbsp;<code>checked</code>&nbsp;block to detect the overflow that is produced by the previous sum at run time. Both examples raise an overflow exception.</p>\r\n<div>\r\n\t// If the previous sum is attempted in a checked environment, an&nbsp;</div>\r\n<pre>\r\n<code><span>// OverflowException error is raised.</span>\r\n\r\n<span>// Checked expression.</span>\r\nConsole.WriteLine(<span>checked</span>(<span>2147483647</span> + ten));\r\n\r\n<span>// Checked block.</span>\r\n<span>checked</span>\r\n{\r\n    <span>int</span> i3 = <span>2147483647</span> + ten;\r\n    Console.WriteLine(i3);\r\n}\r\n</code></pre>\r\n<p>\r\n\tThe&nbsp;unchecked&nbsp;keyword can be used to prevent overflow checking.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThis sample shows how to use&nbsp;<code>checked</code>&nbsp;to enable overflow checking at run time.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>OverFlowTest</span>\r\n{\r\n    <span>// Set maxIntValue to the maximum value for integers.</span>\r\n    <span>static</span> <span>int</span> maxIntValue = <span>2147483647</span>;\r\n\r\n    <span>// Using a checked expression.</span>\r\n    <span><span>static</span> <span>int</span> <span>CheckedMethod</span>()\r\n    </span>{\r\n        <span>int</span> z = <span>0</span>;\r\n        <span>try</span>\r\n        {\r\n            <span>// The following line raises an exception because it is checked.</span>\r\n            z = <span>checked</span>(maxIntValue + <span>10</span>);\r\n        }\r\n        <span>catch</span> (System.OverflowException e)\r\n        {\r\n            <span>// The following line displays information about the error.</span>\r\n            Console.WriteLine(<span>&quot;CHECKED and CAUGHT:  &quot;</span> + e.ToString());\r\n        }\r\n        <span>// The value of z is still 0.</span>\r\n        <span>return</span> z;\r\n    }\r\n\r\n    <span>// Using an unchecked expression.</span>\r\n    <span><span>static</span> <span>int</span> <span>UncheckedMethod</span>()\r\n    </span>{\r\n        <span>int</span> z = <span>0</span>;\r\n        <span>try</span>\r\n        {\r\n            <span>// The following calculation is unchecked and will not </span>\r\n            <span>// raise an exception.</span>\r\n            z = maxIntValue + <span>10</span>;\r\n        }\r\n        <span>catch</span> (System.OverflowException e)\r\n        {\r\n            <span>// The following line will not be executed.</span>\r\n            Console.WriteLine(<span>&quot;UNCHECKED and CAUGHT:  &quot;</span> + e.ToString());\r\n        }\r\n        <span>// Because of the undetected overflow, the sum of 2147483647 + 10 is </span>\r\n        <span>// returned as -2147483639.</span>\r\n        <span>return</span> z;\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        Console.WriteLine(<span>&quot;\\nCHECKED output value is: {0}&quot;</span>,\r\n                          CheckedMethod());\r\n        Console.WriteLine(<span>&quot;UNCHECKED output value is: {0}&quot;</span>,\r\n                          UncheckedMethod());\r\n    }\r\n    <span>/*\r\n   Output:\r\n   CHECKED and CAUGHT:  System.OverflowException: Arithmetic operation resulted\r\n   in an overflow.\r\n      at ConsoleApplication1.OverFlowTest.CheckedMethod() \r\n\r\n   CHECKED output value is: 0\r\n   UNCHECKED output value is: -2147483639\r\n */</span>\r\n}</code></pre>"
          },
          {
            "unchecked": "<p>\r\n\tThe&nbsp;<code>unchecked</code>&nbsp;keyword is used to suppress overflow-checking for integral-type arithmetic operations and conversions.</p>\r\n<p>\r\n\tIn an unchecked context, if an expression produces a value that is outside the range of the destination type, the overflow is not flagged. For example, because the calculation in the following example is performed in an&nbsp;<code>unchecked</code>&nbsp;block or expression, the fact that the result is too large for an integer is ignored, and&nbsp;<code>int1</code>&nbsp;is assigned the value -2,147,483,639.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>unchecked</span>\r\n{\r\n    int1 = <span>2147483647</span> + <span>10</span>;\r\n}\r\nint1 = <span>unchecked</span>(ConstantMax + <span>10</span>);\r\n</code></pre>\r\n<p>\r\n\tIf the&nbsp;<code>unchecked</code>&nbsp;environment is removed, a compilation error occurs. The overflow can be detected at compile time because all the terms of the expression are constants.</p>\r\n<p>\r\n\tExpressions that contain non-constant terms are unchecked by default at compile time and run time. See&nbsp;checked&nbsp;for information about enabling a checked environment.</p>\r\n<p>\r\n\tBecause checking for overflow takes time, the use of unchecked code in situations where there is no danger of overflow might improve performance. However, if overflow is a possibility, a checked environment should be used.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThis sample shows how to use the&nbsp;<code>unchecked</code>&nbsp;keyword.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>UncheckedDemo</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)\r\n    </span>{\r\n        <span>// int.MaxValue is 2,147,483,647.</span>\r\n        <span>const</span> <span>int</span> ConstantMax = <span>int</span>.MaxValue;\r\n        <span>int</span> int1;\r\n        <span>int</span> int2;\r\n        <span>int</span> variableMax = <span>2147483647</span>;\r\n\r\n        <span>// The following statements are checked by default at compile time. They do not</span>\r\n        <span>// compile.</span>\r\n        <span>//int1 = 2147483647 + 10;</span>\r\n        <span>//int1 = ConstantMax + 10;</span>\r\n\r\n        <span>// To enable the assignments to int1 to compile and run, place them inside </span>\r\n        <span>// an unchecked block or expression. The following statements compile and</span>\r\n        <span>// run.</span>\r\n        <span>unchecked</span>\r\n        {\r\n            int1 = <span>2147483647</span> + <span>10</span>;\r\n        }\r\n        int1 = <span>unchecked</span>(ConstantMax + <span>10</span>);\r\n\r\n        <span>// The sum of 2,147,483,647 and 10 is displayed as -2,147,483,639.</span>\r\n        Console.WriteLine(int1);\r\n\r\n\r\n        <span>// The following statement is unchecked by default at compile time and run </span>\r\n        <span>// time because the expression contains the variable variableMax. It causes  </span>\r\n        <span>// overflow but the overflow is not detected. The statement compiles and runs.</span>\r\n        int2 = variableMax + <span>10</span>;\r\n\r\n        <span>// Again, the sum of 2,147,483,647 and 10 is displayed as -2,147,483,639.</span>\r\n        Console.WriteLine(int2);\r\n\r\n        <span>// To catch the overflow in the assignment to int2 at run time, put the</span>\r\n        <span>// declaration in a checked block or expression. The following</span>\r\n        <span>// statements compile but raise an overflow exception at run time.</span>\r\n        <span>checked</span>\r\n        {\r\n            <span>//int2 = variableMax + 10;</span>\r\n        }\r\n        <span>//int2 = checked(variableMax + 10);</span>\r\n\r\n        <span>// Unchecked sections frequently are used to break out of a checked </span>\r\n        <span>// environment in order to improve performance in a portion of code </span>\r\n        <span>// that is not expected to raise overflow exceptions.</span>\r\n        <span>checked</span>\r\n        { \r\n            <span>// Code that might cause overflow should be executed in a checked</span>\r\n            <span>// environment.</span>\r\n            <span>unchecked</span>\r\n            { \r\n                <span>// This section is appropriate for code that you are confident </span>\r\n                <span>// will not result in overflow, and for which performance is </span>\r\n                <span>// a priority.</span>\r\n            }\r\n            <span>// Additional checked code here. </span>\r\n        }\r\n    }\r\n}</code></pre>"
          },
          {
            "fixed Statement": "<p>\r\n\tThe&nbsp;<code>fixed</code>&nbsp;statement prevents the garbage collector from relocating a movable variable. The&nbsp;<code>fixed</code>&nbsp;statement is only permitted in an&nbsp;unsafe&nbsp;context.&nbsp;<code>fixed</code>&nbsp;can also be used to create&nbsp;fixed size buffers.</p>\r\n<p>\r\n\tThe&nbsp;<code>fixed</code>&nbsp;statement sets a pointer to a managed variable and &quot;pins&quot; that variable during the execution of the statement. Pointers to movable managed variables are useful only in a&nbsp;<code>fixed</code>context. Without a&nbsp;<code>fixed</code>&nbsp;context, garbage collection could relocate the variables unpredictably. The C# compiler only lets you assign a pointer to a managed variable in a&nbsp;<code>fixed</code>&nbsp;statement.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>Point</span> \r\n{ \r\n    <span>public</span> <span>int</span> x;\r\n    <span>public</span> <span>int</span> y; \r\n}\r\n\r\n<span><span>unsafe</span> <span>private</span> <span>static</span> <span>void</span> <span>ModifyFixedStorage</span>()\r\n</span>{\r\n    <span>// Variable pt is a managed variable, subject to garbage collection.</span>\r\n    Point pt = <span>new</span> Point();\r\n\r\n    <span>// Using fixed allows the address of pt members to be taken,</span>\r\n    <span>// and &quot;pins&quot; pt so that it is not relocated.</span>\r\n\r\n    <span>fixed</span> (<span>int</span>* p = &amp;pt.x)\r\n    {\r\n        *p = <span>1</span>;\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tYou can initialize a pointer by using an array, a string, a fixed-size buffer, or the address of a variable. The following example illustrates the use of variable addresses, arrays, and strings. For more information about fixed-size buffers, see&nbsp;Fixed Size Buffers.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>Point point = <span>new</span> Point();\r\n<span>double</span>[] arr = { <span>0</span>, <span>1.5</span>, <span>2.3</span>, <span>3.4</span>, <span>4.0</span>, <span>5.9</span> };\r\n<span>string</span> str = <span>&quot;Hello World&quot;</span>;\r\n\r\n<span>// The following two assignments are equivalent. Each assigns the address</span>\r\n<span>// of the first element in array arr to pointer p.</span>\r\n\r\n<span>// You can initialize a pointer by using an array.</span>\r\n<span>fixed</span> (<span>double</span>* p = arr) { <span>/*...*/</span> }\r\n\r\n<span>// You can initialize a pointer by using the address of a variable. </span>\r\n<span>fixed</span> (<span>double</span>* p = &amp;arr[<span>0</span>]) { <span>/*...*/</span> }\r\n\r\n<span>// The following assignment initializes p by using a string.</span>\r\n<span>fixed</span> (<span>char</span>* p = str) { <span>/*...*/</span> }\r\n\r\n<span>// The following assignment is not valid, because str[0] is a char, </span>\r\n<span>// which is a value, not a variable.</span>\r\n<span>//fixed (char* p = &amp;str[0]) { /*...*/ } </span>\r\n</code></pre>\r\n<p>\r\n\tStarting with C# 7.3, the&nbsp;<code>fixed</code>&nbsp;statement operates on additional types beyond arrays, strings, fixed-size buffers, or unmanaged variables. Any type that implements a method named&nbsp;<code>GetPinnableReference</code>&nbsp;can be pinned. The&nbsp;<code>GetPinnableReference</code>&nbsp;must return a&nbsp;<code>ref</code>&nbsp;variable to an unmanaged type. See the topic on&nbsp;pointer types&nbsp;for more information. The .NET types&nbsp;System.Span&lt;T&gt;&nbsp;and&nbsp;System.ReadOnlySpan&lt;T&gt;&nbsp;introduced in .NET Core 2.0 make use of this pattern and can be pinned. This is shown in the following example:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>unsafe</span> <span>private</span> <span>static</span> <span>void</span> <span>FixedSpanExample</span>()\r\n</span>{\r\n    <span>int</span>[] PascalsTriangle = {\r\n                  <span>1</span>,\r\n                <span>1</span>,  <span>1</span>,\r\n              <span>1</span>,  <span>2</span>,  <span>1</span>,\r\n            <span>1</span>,  <span>3</span>,  <span>3</span>,  <span>1</span>,\r\n          <span>1</span>,  <span>4</span>,  <span>6</span>,  <span>4</span>,  <span>1</span>,\r\n        <span>1</span>,  <span>5</span>,  <span>10</span>, <span>10</span>, <span>5</span>,  <span>1</span>\r\n    };\r\n\r\n    Span&lt;<span>int</span>&gt; RowFive = <span>new</span> Span&lt;<span>int</span>&gt;(PascalsTriangle, <span>10</span>, <span>5</span>);\r\n\r\n    <span>fixed</span> (<span>int</span>* ptrToRow = RowFive)\r\n    {\r\n        <span>// Sum the numbers 1,4,6,4,1</span>\r\n        <span>var</span> sum = <span>0</span>;\r\n        <span>for</span> (<span>int</span> i = <span>0</span>; i &lt; RowFive.Length; i++)\r\n        {\r\n            sum += *(ptrToRow + i);\r\n        }\r\n        Console.WriteLine(sum);\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tIf you are creating types that should participate in this pattern, see&nbsp;Span&lt;T&gt;.GetPinnableReference()for an example of implementing the pattern.</p>\r\n<p>\r\n\tMultiple pointers can be initialized in one statement if they are all the same type:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>fixed</span> (<span>byte</span>* ps = srcarray, pd = dstarray) {...}\r\n</code></pre>\r\n<p>\r\n\tTo initialize pointers of different types, simply nest&nbsp;<code>fixed</code>&nbsp;statements, as shown in the following example.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>fixed</span> (<span>int</span>* p1 = &amp;point.x)\r\n{\r\n    <span>fixed</span> (<span>double</span>* p2 = &amp;arr[<span>5</span>])\r\n    {\r\n        <span>// Do something with p1 and p2.</span>\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tAfter the code in the statement is executed, any pinned variables are unpinned and subject to garbage collection. Therefore, do not point to those variables outside the&nbsp;<code>fixed</code>&nbsp;statement. The variables declared in the&nbsp;<code>fixed</code>&nbsp;statement are scoped to that statement, making this easier:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>fixed</span> (<span>byte</span>* ps = srcarray, pd = dstarray)\r\n{\r\n   ...\r\n}\r\n<span>// ps and pd are no longer in scope here.</span>\r\n</code></pre>\r\n<p>\r\n\tPointers initialized in&nbsp;<code>fixed</code>&nbsp;statements are readonly variables. If you want to modify the pointer value, you must declare a second pointer variable, and modify that. The variable declared in the&nbsp;<code>fixed</code>&nbsp;statement cannot be modified:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>fixed</span> (<span>byte</span>* ps = srcarray, pd = dstarray)\r\n{\r\n    <span>byte</span>* pSourceCopy = ps;\r\n    pSourceCopy++; <span>// point to the next element.</span>\r\n    ps++; <span>// invalid: cannot modify ps, as it is declared in the fixed statement.</span>\r\n}\r\n</code></pre>\r\n<p>\r\n\tIn unsafe mode, you can allocate memory on the stack, where it is not subject to garbage collection and therefore does not need to be pinned. For more information, see&nbsp;stackalloc.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>// Unsafe method: takes a pointer to an int.</span>\r\n<span><span>unsafe</span> <span>static</span> <span>void</span> <span>SquarePtrParam</span>(<span><span>int</span>* p</span>)\r\n</span>{\r\n    *p *= *p;\r\n}\r\n\r\n<span><span>unsafe</span> <span>static</span> <span>void</span> <span>SquarePointValue</span>()\r\n</span>{\r\n    Point pt = <span>new</span> Point\r\n    {\r\n        x = <span>5</span>,\r\n        y = <span>6</span>\r\n    };\r\n    <span>// Pin pt in place:</span>\r\n    <span>fixed</span> (<span>int</span>* p = &amp;pt.x)\r\n    {\r\n        SquarePtrParam(p);\r\n    }\r\n    <span>// pt now unpinned.</span>\r\n    Console.WriteLine(<span>&quot;{0} {1}&quot;</span>, pt.x, pt.y);\r\n    <span>/*\r\n    Output:\r\n    25 6\r\n     */</span>\r\n}</code></pre>"
          },
          {
            "lock statement": "<p>\r\n\tThe&nbsp;<code>lock</code>&nbsp;statement acquires the mutual-exclusion lock for a given object, executes a statement block, and then releases the lock. While a lock is held, the thread that holds the lock can again acquire and release the lock. Any other thread is blocked from acquiring the lock and waits until the lock is released.</p>\r\n<p>\r\n\tThe&nbsp;<code>lock</code>&nbsp;statement is of the form</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>lock</span> (x)\r\n{\r\n    <span>// Your code...</span>\r\n}\r\n</code></pre>\r\n<p>\r\n\twhere&nbsp;<code>x</code>&nbsp;is an expression of a&nbsp;reference type. It&#39;s precisely equivalent to</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>object</span> __lockObj = x;\r\n<span>bool</span> __lockWasTaken = <span>false</span>;\r\n<span>try</span>\r\n{\r\n    System.Threading.Monitor.Enter(__lockObj, <span>ref</span> __lockWasTaken);\r\n    <span>// Your code...</span>\r\n}\r\n<span>finally</span>\r\n{\r\n    <span>if</span> (__lockWasTaken) System.Threading.Monitor.Exit(__lockObj);\r\n}\r\n</code></pre>\r\n<p>\r\n\tSince the code uses a&nbsp;try...finally&nbsp;block, the lock is released even if an exception is thrown within the body of a&nbsp;<code>lock</code>&nbsp;statement.</p>\r\n<p>\r\n\tYou can&#39;t use the&nbsp;await&nbsp;keyword in the body of a&nbsp;<code>lock</code>&nbsp;statement.</p>\r\n<h2>\r\n\tRemarks</h2>\r\n<p>\r\n\tWhen you synchronize thread access to a shared resource, lock on a dedicated object instance (for example,&nbsp;<code>private readonly object balanceLock = new object();</code>) or another instance that is unlikely to be used as a lock object by unrelated parts of the code. Avoid using the same lock object instance for different shared resources, as it might result in deadlock or lock contention. In particular, avoid using the following as lock objects:</p>\r\n<ul>\r\n\t<li>\r\n\t\t<code>this</code>, as it might be used by the callers as a lock.</li>\r\n\t<li>\r\n\t\tType&nbsp;instances, as those might be obtained by the&nbsp;typeof&nbsp;operator or reflection.</li>\r\n\t<li>\r\n\t\tstring instances, including string literals, as those might be&nbsp;interned.</li>\r\n</ul>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example defines an&nbsp;<code>Account</code>&nbsp;class that synchronizes access to its private&nbsp;<code>balance</code>field by locking on a dedicated&nbsp;<code>balanceLock</code>&nbsp;instance. Using the same instance for locking ensures that the&nbsp;<code>balance</code>&nbsp;field cannot be updated simultaneously by two threads attempting to call the&nbsp;<code>Debit</code>&nbsp;or&nbsp;<code>Credit</code>&nbsp;methods simultaneously.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>using</span> System;\r\n<span>using</span> System.Threading.Tasks;\r\n\r\n<span>public</span> <span>class</span> <span>Account</span>\r\n{\r\n    <span>private</span> <span>readonly</span> <span>object</span> balanceLock = <span>new</span> <span>object</span>();\r\n    <span>private</span> <span>decimal</span> balance;\r\n\r\n    <span><span>public</span> <span>Account</span>(<span><span>decimal</span> initialBalance</span>)\r\n    </span>{\r\n        balance = initialBalance;\r\n    }\r\n\r\n    <span><span>public</span> <span>decimal</span> <span>Debit</span>(<span><span>decimal</span> amount</span>)\r\n    </span>{\r\n        <span>lock</span> (balanceLock)\r\n        {\r\n            <span>if</span> (balance &gt;= amount)\r\n            {\r\n                Console.WriteLine(<span>$&quot;Balance before debit :<span>{balance, <span>5</span>}</span>&quot;</span>);\r\n                Console.WriteLine(<span>$&quot;Amount to remove     :<span>{amount, <span>5</span>}</span>&quot;</span>);\r\n                balance = balance - amount;\r\n                Console.WriteLine(<span>$&quot;Balance after debit  :<span>{balance, <span>5</span>}</span>&quot;</span>);\r\n                <span>return</span> amount;\r\n            }\r\n            <span>else</span>\r\n            {\r\n                <span>return</span> <span>0</span>;\r\n            }\r\n        }\r\n    }\r\n\r\n    <span><span>public</span> <span>void</span> <span>Credit</span>(<span><span>decimal</span> amount</span>)\r\n    </span>{\r\n        <span>lock</span> (balanceLock)\r\n        {\r\n            Console.WriteLine(<span>$&quot;Balance before credit:<span>{balance, <span>5</span>}</span>&quot;</span>);\r\n            Console.WriteLine(<span>$&quot;Amount to add        :<span>{amount, <span>5</span>}</span>&quot;</span>);\r\n            balance = balance + amount;\r\n            Console.WriteLine(<span>$&quot;Balance after credit :<span>{balance, <span>5</span>}</span>&quot;</span>);\r\n        }\r\n    }\r\n}\r\n\r\n<span>class</span> <span>AccountTest</span>\r\n{\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>var</span> account = <span>new</span> Account(<span>1000</span>);\r\n        <span>var</span> tasks = <span>new</span> Task[<span>100</span>];\r\n        <span>for</span> (<span>int</span> i = <span>0</span>; i &lt; tasks.Length; i++)\r\n        {\r\n            tasks[i] = Task.Run(() =&gt; RandomlyUpdate(account));\r\n        }\r\n        Task.WaitAll(tasks);\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>RandomlyUpdate</span>(<span>Account account</span>)\r\n    </span>{\r\n        <span>var</span> rnd = <span>new</span> Random();\r\n        <span>for</span> (<span>int</span> i = <span>0</span>; i &lt; <span>10</span>; i++)\r\n        {\r\n            <span>var</span> amount = rnd.Next(<span>1</span>, <span>100</span>);\r\n            <span>bool</span> doCredit = rnd.NextDouble() &lt; <span>0.5</span>;\r\n            <span>if</span> (doCredit)\r\n            {\r\n                account.Credit(amount);\r\n            }\r\n            <span>else</span>\r\n            {\r\n                account.Debit(amount);\r\n            }\r\n        }\r\n    }\r\n}</code></pre>"
          },
          {
            "params": "<p>\r\n\tBy using the&nbsp;<code>params</code>&nbsp;keyword, you can specify a&nbsp;method parameter&nbsp;that takes a variable number of arguments.</p>\r\n<p>\r\n\tYou can send a comma-separated list of arguments of the type specified in the parameter declaration or an array of arguments of the specified type. You also can send no arguments. If you send no arguments, the length of the&nbsp;<code>params</code>&nbsp;list is zero.</p>\r\n<p>\r\n\tNo additional parameters are permitted after the&nbsp;<code>params</code>&nbsp;keyword in a method declaration, and only one&nbsp;<code>params</code>&nbsp;keyword is permitted in a method declaration.</p>\r\n<p>\r\n\tThe declared type of the&nbsp;<code>params</code>&nbsp;parameter must be a single-dimensional array, as the following example shows. Otherwise, a compiler error&nbsp;CS0225&nbsp;occurs.</p>\r\n<h2>\r\n\tExample</h2>\r\n<p>\r\n\tThe following example demonstrates various ways in which arguments can be sent to a&nbsp;<code>params</code>parameter.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>public</span> <span>class</span> <span>MyClass</span>\r\n{\r\n    <span><span>public</span> <span>static</span> <span>void</span> <span>UseParams</span>(<span><span>params</span> <span>int</span>[] list</span>)\r\n    </span>{\r\n        <span>for</span> (<span>int</span> i = <span>0</span>; i &lt; list.Length; i++)\r\n        {\r\n            Console.Write(list[i] + <span>&quot; &quot;</span>);\r\n        }\r\n        Console.WriteLine();\r\n    }\r\n\r\n    <span><span>public</span> <span>static</span> <span>void</span> <span>UseParams2</span>(<span><span>params</span> <span>object</span>[] list</span>)\r\n    </span>{\r\n        <span>for</span> (<span>int</span> i = <span>0</span>; i &lt; list.Length; i++)\r\n        {\r\n            Console.Write(list[i] + <span>&quot; &quot;</span>);\r\n        }\r\n        Console.WriteLine();\r\n    }\r\n\r\n    <span><span>static</span> <span>void</span> <span>Main</span>()\r\n    </span>{\r\n        <span>// You can send a comma-separated list of arguments of the </span>\r\n        <span>// specified type.</span>\r\n        UseParams(<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>);\r\n        UseParams2(<span>1</span>, <span>&#39;a&#39;</span>, <span>&quot;test&quot;</span>);\r\n\r\n        <span>// A params parameter accepts zero or more arguments.</span>\r\n        <span>// The following calling statement displays only a blank line.</span>\r\n        UseParams2();\r\n\r\n        <span>// An array argument can be passed, as long as the array</span>\r\n        <span>// type matches the parameter type of the method being called.</span>\r\n        <span>int</span>[] myIntArray = { <span>5</span>, <span>6</span>, <span>7</span>, <span>8</span>, <span>9</span> };\r\n        UseParams(myIntArray);\r\n\r\n        <span>object</span>[] myObjArray = { <span>2</span>, <span>&#39;b&#39;</span>, <span>&quot;test&quot;</span>, <span>&quot;again&quot;</span> };\r\n        UseParams2(myObjArray);\r\n\r\n        <span>// The following call causes a compiler error because the object</span>\r\n        <span>// array cannot be converted into an integer array.</span>\r\n        <span>//UseParams(myObjArray);</span>\r\n\r\n        <span>// The following call does not cause an error, but the entire </span>\r\n        <span>// integer array becomes the first element of the params array.</span>\r\n        UseParams2(myIntArray);\r\n    }\r\n}\r\n<span>/*\r\nOutput:\r\n    1 2 3 4\r\n    1 a test\r\n           \r\n    5 6 7 8 9\r\n    2 b test again\r\n    System.Int32[]\r\n*/</span></code></pre>"
          },
          {
            "in (Parameter Modifier)": "<p>\r\n\tThe&nbsp;<code>in</code>&nbsp;keyword causes arguments to be passed by reference. It is like the&nbsp;ref&nbsp;or&nbsp;out&nbsp;keywords, except that&nbsp;<code>in</code>&nbsp;arguments cannot be modified by the called method. Whereas&nbsp;<code>ref</code>&nbsp;arguments may be modified,&nbsp;<code>out</code>&nbsp;arguments must be modified by the called method, and those modifications are observable in the calling context.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>int</span> readonlyArgument = <span>44</span>;\r\nInArgExample(readonlyArgument);\r\nConsole.WriteLine(readonlyArgument);     <span>// value is still 44</span>\r\n\r\n<span><span>void</span> <span>InArgExample</span>(<span><span>in</span> <span>int</span> number</span>)\r\n</span>{\r\n    <span>// Uncomment the following line to see error CS8331</span>\r\n    <span>//number = 19;</span>\r\n}\r\n</code></pre>\r\n<p>\r\n\tThe preceding example demonstrates that the&nbsp;<code>in</code>&nbsp;modifier is usually unnecessary at the call site. It is only required in the method declaration.</p>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tThe&nbsp;<code>in</code>&nbsp;keyword can also be used with a generic type parameter to specify that the type parameter is contravariant, as part of a&nbsp;<code>foreach</code>&nbsp;statement, or as part of a&nbsp;<code>join</code>&nbsp;clause in a LINQ query. For more information on the use of the&nbsp;<code>in</code>&nbsp;keyword in these contexts, see&nbsp;in, which provides links to all those uses.</p>\r\n</div>\r\n<p>\r\n\tVariables passed as&nbsp;<code>in</code>&nbsp;arguments must be initialized before being passed in a method call. However, the called method may not assign a value or modify the argument.</p>\r\n<p>\r\n\tAlthough the&nbsp;<code>in</code>,&nbsp;<code>ref</code>, and&nbsp;<code>out</code>&nbsp;keywords cause different run-time behavior, they are not considered part of the method signature at compile time. Therefore, methods cannot be overloaded if the only difference is that one method takes a&nbsp;<code>ref</code>&nbsp;or&nbsp;<code>in</code>&nbsp;argument and the other takes an&nbsp;<code>out</code>&nbsp;argument. The following code, for example, will not compile:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>CS0663_Example</span>\r\n{\r\n    <span>// Compiler error CS0663: &quot;Cannot define overloaded </span>\r\n    <span>// methods that differ only on in, ref and out&quot;.</span>\r\n    <span><span>public</span> <span>void</span> <span>SampleMethod</span>(<span><span>in</span> <span>int</span> i</span>) </span>{ }\r\n    <span><span>public</span> <span>void</span> <span>SampleMethod</span>(<span><span>ref</span> <span>int</span> i</span>) </span>{ }\r\n}\r\n</code></pre>\r\n<p>\r\n\tOverloading based on the presence of&nbsp;<code>in</code>&nbsp;is allowed:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>InOverloads</span>\r\n{\r\n    <span><span>public</span> <span>void</span> <span>SampleMethod</span>(<span><span>in</span> <span>int</span> i</span>) </span>{ }\r\n    <span><span>public</span> <span>void</span> <span>SampleMethod</span>(<span><span>int</span> i</span>) </span>{ }\r\n}\r\n</code></pre>\r\n<h2>\r\n\tOverload resolution rules</h2>\r\n<p>\r\n\tYou can understand the overload resolution rules for methods with by value vs.&nbsp;<code>in</code>&nbsp;arguments by understanding the motivation for&nbsp;<code>in</code>&nbsp;arguments. Defining methods using&nbsp;<code>in</code>&nbsp;parameters is a potential performance optimization. Some&nbsp;<code>struct</code>&nbsp;type arguments may be large in size, and when methods are called in tight loops or critical code paths, the cost of copying those structures is critical. Methods declare&nbsp;<code>in</code>&nbsp;parameters to specify that arguments may be passed by reference safely because the called method does not modify the state of that argument. Passing those arguments by reference avoids the (potentially) expensive copy.</p>\r\n<p>\r\n\tSpecifying&nbsp;<code>in</code>&nbsp;for arguments at the call site is typically optional. There is no semantic difference between passing arguments by value and passing them by reference using the&nbsp;<code>in</code>&nbsp;modifier. The&nbsp;<code>in</code>&nbsp;modifier at the call site is optional because you don&#39;t need to indicate that the argument&#39;s value might be changed. You explicitly add the&nbsp;<code>in</code>&nbsp;modifier at the call site to ensure the argument is passed by reference, not by value. Explicitly using&nbsp;<code>in</code>&nbsp;has the following two effects:</p>\r\n<p>\r\n\tFirst, specifying&nbsp;<code>in</code>&nbsp;at the call site forces the compiler to select a method defined with a matching&nbsp;<code>in</code>&nbsp;parameter. Otherwise, when two methods differ only in the presence of&nbsp;<code>in</code>, the by value overload is a better match.</p>\r\n<p>\r\n\tSecond, specifying&nbsp;<code>in</code>&nbsp;declares your intent to pass an argument by reference. The argument used with&nbsp;<code>in</code>&nbsp;must represent a location that can be directly referred to. The same general rules for&nbsp;<code>out</code>and&nbsp;<code>ref</code>&nbsp;arguments apply: You cannot use constants, ordinary properties, or other expressions that produce values. Otherwise, omitting&nbsp;<code>in</code>&nbsp;at the call site informs the compiler that you will allow it to create a temporary variable to pass by read-only reference to the method. The compiler creates a temporary variable to overcome several restrictions with&nbsp;<code>in</code>&nbsp;arguments:</p>\r\n<ul>\r\n\t<li>\r\n\t\tA temporary variable allows compile-time constants as&nbsp;<code>in</code>&nbsp;parameters.</li>\r\n\t<li>\r\n\t\tA temporary variable allows properties, or other expressions for&nbsp;<code>in</code>&nbsp;parameters.</li>\r\n\t<li>\r\n\t\tA temporary variable allows arguments where there is an implicit conversion from the argument type to the parameter type.</li>\r\n</ul>\r\n<p>\r\n\tIn all the preceding instances, the compiler creates a temporary variable that stores the value of the constant, property, or other expression.</p>\r\n<p>\r\n\tThe following code illustrates these rules:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>static</span> <span>void</span> <span>Method</span>(<span><span>in</span> <span>int</span> argument</span>)\r\n</span>{\r\n    <span>// implementation removed</span>\r\n}\r\n\r\nMethod(<span>5</span>); <span>// OK, temporary variable created.</span>\r\nMethod(<span>5</span>L); <span>// CS1503: no implicit conversion from long to int</span>\r\n<span>short</span> s = <span>0</span>;\r\nMethod(s); <span>// OK, temporary int created with the value 0</span>\r\nMethod(<span>in</span> s); <span>// CS1503: cannot convert from in short to in int</span>\r\n<span>int</span> i = <span>42</span>;\r\nMethod(i); <span>// passed by readonly reference</span>\r\nMethod(<span>in</span> i); <span>// passed by readonly reference, explicitly using `in`</span>\r\n</code></pre>\r\n<p>\r\n\tNow, suppose another method using by value arguments was available. The results change as shown in the following code:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>static</span> <span>void</span> <span>Method</span>(<span><span>int</span> argument</span>)\r\n</span>{\r\n    <span>// implementation removed</span>\r\n}\r\n\r\n<span><span>static</span> <span>void</span> <span>Method</span>(<span><span>in</span> <span>int</span> argument</span>)\r\n</span>{\r\n    <span>// implementation removed</span>\r\n}\r\n\r\nMethod(<span>5</span>); <span>// Calls overload passed by value</span>\r\nMethod(<span>5</span>L); <span>// CS1503: no implicit conversion from long to int</span>\r\n<span>short</span> s = <span>0</span>;\r\nMethod(s); <span>// Calls overload passed by value.</span>\r\nMethod(<span>in</span> s); <span>// CS1503: cannot convert from in short to in int</span>\r\n<span>int</span> i = <span>42</span>;\r\nMethod(i); <span>// Calls overload passed by value</span>\r\nMethod(<span>in</span> i); <span>// passed by readonly reference, explicitly using `in`</span>\r\n</code></pre>\r\n<p>\r\n\tThe only method call where the argument is passed by reference is the final one.</p>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tThe preceding code uses&nbsp;<code>int</code>&nbsp;as the argument type for simplicity. Because&nbsp;<code>int</code>&nbsp;is no larger than a reference in most modern machines, there is no benefit to passing a single&nbsp;<code>int</code>&nbsp;as a readonly reference.</p>\r\n</div>\r\n<h2>\r\n\tLimitations on&nbsp;<code>in</code>&nbsp;parameters</h2>\r\n<p>\r\n\tYou can&#39;t use the&nbsp;<code>in</code>,&nbsp;<code>ref</code>, and&nbsp;<code>out</code>&nbsp;keywords for the following kinds of methods:</p>\r\n<ul>\r\n\t<li>\r\n\t\tAsync methods, which you define by using the&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/async\" target=\"_blank\">async</a>&nbsp;modifier.</li>\r\n\t<li>\r\n\t\tIterator methods, which include a&nbsp;<a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/yield\" target=\"_blank\">yield return</a>&nbsp;or&nbsp;<code>yield break</code>&nbsp;statement.</li>\r\n</ul>"
          },
          {
            "ref": "<p>\r\n\tThe&nbsp;<code>ref</code>&nbsp;keyword indicates a value that is passed by reference. It is used in four different contexts:</p>\r\n<ul>\r\n\t<li>\r\n\t\tIn a method signature and in a method call, to pass an argument to a method by reference. For more information, see&nbsp;Passing an argument by reference.</li>\r\n\t<li>\r\n\t\tIn a method signature, to return a value to the caller by reference. For more information, see&nbsp;Reference return values.</li>\r\n\t<li>\r\n\t\tIn a member body, to indicate that a reference return value is stored locally as a reference that the caller intends to modify or, in general, a local variable accesses another value by reference. For more information, see&nbsp;Ref locals.</li>\r\n\t<li>\r\n\t\tIn a&nbsp;<code>struct</code>&nbsp;declaration to declare a&nbsp;<code>ref struct</code>&nbsp;or a&nbsp;<code>ref readonly struct</code>. For more information, see&nbsp;ref struct types.</li>\r\n</ul>\r\n<h2>\r\n\tPassing an argument by reference</h2>\r\n<p>\r\n\tWhen used in a method&#39;s parameter list, the&nbsp;<code>ref</code>&nbsp;keyword indicates that an argument is passed by reference, not by value. The effect of passing by reference is that any change to the argument in the called method is reflected in the calling method. For example, if the caller passes a local variable expression or an array element access expression, and the called method replaces the object to which the ref parameter refers, then the caller&rsquo;s local variable or the array element now refers to the new object when the method returns.</p>\r\n<div>\r\n\t<p>\r\n\t\t&nbsp;Note</p>\r\n\t<p>\r\n\t\tDo not confuse the concept of passing by reference with the concept of reference types. The two concepts are not the same. A method parameter can be modified by&nbsp;<code>ref</code>&nbsp;regardless of whether it is a value type or a reference type. There is no boxing of a value type when it is passed by reference.</p>\r\n</div>\r\n<p>\r\n\tTo use a&nbsp;<code>ref</code>&nbsp;parameter, both the method definition and the calling method must explicitly use the&nbsp;<code>ref</code>&nbsp;keyword, as shown in the following example.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>void</span> <span>Method</span>(<span><span>ref</span> <span>int</span> refArgument</span>)\r\n</span>{\r\n    refArgument = refArgument + <span>44</span>;\r\n}\r\n\r\n<span>int</span> number = <span>1</span>;\r\nMethod(<span>ref</span> number);\r\nConsole.WriteLine(number);\r\n<span>// Output: 45</span>\r\n</code></pre>\r\n<p>\r\n\tAn argument that is passed to a&nbsp;<code>ref</code>&nbsp;or&nbsp;<code>in</code>&nbsp;parameter must be initialized before it is passed. This differs from&nbsp;out&nbsp;parameters, whose arguments do not have to be explicitly initialized before they are passed.</p>\r\n<p>\r\n\tMembers of a class can&#39;t have signatures that differ only by&nbsp;<code>ref</code>,&nbsp;<code>in</code>, or&nbsp;<code>out</code>. A compiler error occurs if the only difference between two members of a type is that one of them has a&nbsp;<code>ref</code>parameter and the other has an&nbsp;<code>out</code>, or&nbsp;<code>in</code>&nbsp;parameter. The following code, for example, doesn&#39;t compile.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>CS0663_Example</span>\r\n{\r\n    <span>// Compiler error CS0663: &quot;Cannot define overloaded </span>\r\n    <span>// methods that differ only on ref and out&quot;.</span>\r\n    <span><span>public</span> <span>void</span> <span>SampleMethod</span>(<span><span>out</span> <span>int</span> i</span>) </span>{ }\r\n    <span><span>public</span> <span>void</span> <span>SampleMethod</span>(<span><span>ref</span> <span>int</span> i</span>) </span>{ }\r\n}\r\n</code></pre>\r\n<p>\r\n\tHowever, methods can be overloaded when one method has a&nbsp;<code>ref</code>,&nbsp;<code>in</code>, or&nbsp;<code>out</code>&nbsp;parameter and the other has a value parameter, as shown in the following example.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>RefOverloadExample</span>\r\n{\r\n    <span><span>public</span> <span>void</span> <span>SampleMethod</span>(<span><span>int</span> i</span>) </span>{ }\r\n    <span><span>public</span> <span>void</span> <span>SampleMethod</span>(<span><span>ref</span> <span>int</span> i</span>) </span>{ }\r\n}\r\n</code></pre>\r\n<p>\r\n\tIn other situations that require signature matching, such as hiding or overriding,&nbsp;<code>in</code>,&nbsp;<code>ref</code>, and&nbsp;<code>out</code>&nbsp;are part of the signature and don&#39;t match each other.</p>\r\n<p>\r\n\tProperties are not variables. They are methods, and cannot be passed to&nbsp;<code>ref</code>&nbsp;parameters.</p>\r\n<p>\r\n\tYou can&#39;t use the&nbsp;<code>ref</code>,&nbsp;<code>in</code>, and&nbsp;<code>out</code>&nbsp;keywords for the following kinds of methods:</p>\r\n<ul>\r\n\t<li>\r\n\t\tAsync methods, which you define by using the&nbsp;async&nbsp;modifier.</li>\r\n\t<li>\r\n\t\tIterator methods, which include a&nbsp;yield return&nbsp;or&nbsp;<code>yield break</code>&nbsp;statement.</li>\r\n</ul>\r\n<h2>\r\n\tPassing an argument by reference: An example</h2>\r\n<p>\r\n\tThe previous examples pass value types by reference. You can also use the&nbsp;<code>ref</code>&nbsp;keyword to pass reference types by reference. Passing a reference type by reference enables the called method to replace the object to which the reference parameter refers in the caller. The storage location of the object is passed to the method as the value of the reference parameter. If you change the value in the storage location of the parameter (to point to a new object), you also change the storage location to which the caller refers. The following example passes an instance of a reference type as a&nbsp;<code>ref</code>&nbsp;parameter.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>Product</span>\r\n{\r\n    <span><span>public</span> <span>Product</span>(<span><span>string</span> name, <span>int</span> newID</span>)\r\n    </span>{\r\n        ItemName = name;\r\n        ItemID = newID;\r\n    }\r\n\r\n    <span>public</span> <span>string</span> ItemName { <span>get</span>; <span>set</span>; }\r\n    <span>public</span> <span>int</span> ItemID { <span>get</span>; <span>set</span>; }\r\n}\r\n\r\n<span><span>private</span> <span>static</span> <span>void</span> <span>ModifyProductsByReference</span>()\r\n</span>{\r\n    <span>// Declare an instance of Product and display its initial values.</span>\r\n    Product item = <span>new</span> Product(<span>&quot;Fasteners&quot;</span>, <span>54321</span>);\r\n    System.Console.WriteLine(<span>&quot;Original values in Main.  Name: {0}, ID: {1}\\n&quot;</span>,\r\n        item.ItemName, item.ItemID);\r\n\r\n    <span>// Pass the product instance to ChangeByReference.</span>\r\n    ChangeByReference(<span>ref</span> item);\r\n    System.Console.WriteLine(<span>&quot;Back in Main.  Name: {0}, ID: {1}\\n&quot;</span>,\r\n        item.ItemName, item.ItemID);\r\n}\r\n\r\n<span><span>private</span> <span>static</span> <span>void</span> <span>ChangeByReference</span>(<span><span>ref</span> Product itemRef</span>)\r\n</span>{\r\n    <span>// Change the address that is stored in the itemRef parameter.   </span>\r\n    itemRef = <span>new</span> Product(<span>&quot;Stapler&quot;</span>, <span>99999</span>);\r\n\r\n    <span>// You can change the value of one of the properties of</span>\r\n    <span>// itemRef. The change happens to item in Main as well.</span>\r\n    itemRef.ItemID = <span>12345</span>;\r\n}\r\n</code></pre>\r\n<p>\r\n\tFor more information about how to pass reference types by value and by reference, see&nbsp;Passing Reference-Type Parameters.</p>\r\n<h2>\r\n\tReference return values</h2>\r\n<p>\r\n\tReference return values (or ref returns) are values that a method returns by reference to the caller. That is, the caller can modify the value returned by a method, and that change is reflected in the state of the object that contains the method.</p>\r\n<p>\r\n\tA reference return value is defined by using the&nbsp;<code>ref</code>&nbsp;keyword:</p>\r\n<ul>\r\n\t<li>\r\n\t\tIn the method signature. For example, the following method signature indicates that the&nbsp;<code>GetCurrentPrice</code>&nbsp;method returns a&nbsp;Decimal&nbsp;value by reference.</li>\r\n</ul>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>public</span> <span>ref</span> <span>decimal</span> <span>GetCurrentPrice</span>()\r\n</span></code></pre>\r\n<ul>\r\n\t<li>\r\n\t\tBetween the&nbsp;<code>return</code>&nbsp;token and the variable returned in a&nbsp;<code>return</code>&nbsp;statement in the method. For example:</li>\r\n</ul>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>return</span> <span>ref</span> DecimalArray[<span>0</span>];\r\n</code></pre>\r\n<p>\r\n\tIn order for the caller to modify the object&#39;s state, the reference return value must be stored to a variable that is explicitly defined as a&nbsp;ref local.</p>\r\n<p>\r\n\tThe called method may also declare the return value as&nbsp;<code>ref readonly</code>&nbsp;to return the value by reference, and enforce that the calling code cannot modify the returned value. The calling method can avoid copying the returned valued by storing the value in a local&nbsp;ref readonly&nbsp;variable.</p>\r\n<p>\r\n\tFor an example, see&nbsp;A ref returns and ref locals example.</p>\r\n<h2>\r\n\tRef locals</h2>\r\n<p>\r\n\tA ref local variable is used to refer to values returned using&nbsp;<code>return ref</code>. A ref local variable cannot be initialized to a non-ref return value. In other words, the right hand side of the initialization must be a reference. Any modifications to the value of the ref local are reflected in the state of the object whose method returned the value by reference.</p>\r\n<p>\r\n\tYou define a ref local by using the&nbsp;<code>ref</code>&nbsp;keyword before the variable declaration, as well as immediately before the call to the method that returns the value by reference.</p>\r\n<p>\r\n\tFor example, the following statement defines a ref local value that is returned by a method named&nbsp;<code>GetEstimatedValue</code>:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>ref</span> <span>decimal</span> estValue = <span>ref</span> Building.GetEstimatedValue();\r\n</code></pre>\r\n<p>\r\n\tYou can access a value by reference in the same way. In some cases, accessing a value by reference increases performance by avoiding a potentially expensive copy operation. For example, the following statement shows how one can define a ref local value that is used to reference a value.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>ref</span> VeryLargeStruct reflocal = <span>ref</span> veryLargeStruct;\r\n</code></pre>\r\n<p>\r\n\tNote that in both examples the&nbsp;<code>ref</code>&nbsp;keyword must be used in both places, or the compiler generates error CS8172, &quot;Cannot initialize a by-reference variable with a value.&quot;</p>\r\n<p>\r\n\tBeginning with C# 7.3, the iteration variable of the&nbsp;<code>foreach</code>&nbsp;statement can be ref local or ref readonly local variable. For more information, see the&nbsp;foreach statement&nbsp;article.</p>\r\n<h2>\r\n\tRef readonly locals</h2>\r\n<p>\r\n\tA ref readonly local is used to refer to values returned by the method or property that has&nbsp;<code>ref readonly</code>&nbsp;in its signature and uses&nbsp;<code>return ref</code>. A&nbsp;<code>ref readonly</code>&nbsp;variable combines the properties of a&nbsp;<code>ref</code>&nbsp;local variable with a&nbsp;<code>readonly</code>&nbsp;variable: it is an alias to the storage it&#39;s assigned to, and it cannot be modified.</p>\r\n<h2>\r\n\tA ref returns and ref locals example</h2>\r\n<p>\r\n\tThe following example defines a&nbsp;<code>Book</code>&nbsp;class that has two&nbsp;String&nbsp;fields,&nbsp;<code>Title</code>&nbsp;and&nbsp;<code>Author</code>. It also defines a&nbsp;<code>BookCollection</code>&nbsp;class that includes a private array of&nbsp;<code>Book</code>&nbsp;objects. Individual book objects are returned by reference by calling its&nbsp;<code>GetBookByTitle</code>&nbsp;method.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code>\r\n<span>public</span> <span>class</span> <span>Book</span>\r\n{\r\n    <span>public</span> <span>string</span> Author;\r\n    <span>public</span> <span>string</span> Title;\r\n}\r\n\r\n<span>public</span> <span>class</span> <span>BookCollection</span>\r\n{\r\n    <span>private</span> Book[] books = { <span>new</span> Book { Title = <span>&quot;Call of the Wild, The&quot;</span>, Author = <span>&quot;Jack London&quot;</span> },\r\n                        <span>new</span> Book { Title = <span>&quot;Tale of Two Cities, A&quot;</span>, Author = <span>&quot;Charles Dickens&quot;</span> }\r\n                       };\r\n    <span>private</span> Book nobook = <span>null</span>;\r\n\r\n    <span><span>public</span> <span>ref</span> Book <span>GetBookByTitle</span>(<span><span>string</span> title</span>)\r\n    </span>{\r\n        <span>for</span> (<span>int</span> ctr = <span>0</span>; ctr &lt; books.Length; ctr++)\r\n        {\r\n            <span>if</span> (title == books[ctr].Title)\r\n                <span>return</span> <span>ref</span> books[ctr];\r\n        }\r\n        <span>return</span> <span>ref</span> nobook;\r\n    }\r\n\r\n    <span><span>public</span> <span>void</span> <span>ListBooks</span>()\r\n    </span>{\r\n        <span>foreach</span> (<span>var</span> book <span>in</span> books)\r\n        {\r\n            Console.WriteLine(<span>$&quot;<span>{book.Title}</span>, by <span>{book.Author}</span>&quot;</span>);\r\n        }\r\n        Console.WriteLine();\r\n    }\r\n}\r\n</code></pre>\r\n<p>\r\n\tWhen the caller stores the value returned by the&nbsp;<code>GetBookByTitle</code>&nbsp;method as a ref local, changes that the caller makes to the return value are reflected in the&nbsp;<code>BookCollection</code>&nbsp;object, as the following example shows.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>var</span> bc = <span>new</span> BookCollection();\r\nbc.ListBooks();\r\n\r\n<span>ref</span> <span>var</span> book = <span>ref</span> bc.GetBookByTitle(<span>&quot;Call of the Wild, The&quot;</span>);\r\n<span>if</span> (book != <span>null</span>)\r\n    book = <span>new</span> Book { Title = <span>&quot;Republic, The&quot;</span>, Author = <span>&quot;Plato&quot;</span> };\r\nbc.ListBooks();\r\n<span>// The example displays the following output:</span>\r\n<span>//       Call of the Wild, The, by Jack London</span>\r\n<span>//       Tale of Two Cities, A, by Charles Dickens</span>\r\n<span>//       </span>\r\n<span>//       Republic, The, by Plato</span>\r\n<span>//       Tale of Two Cities, A, by Charles Dickens</span>\r\n</code></pre>\r\n<h2>\r\n\tRef struct types</h2>\r\n<p>\r\n\tAdding the&nbsp;<code>ref</code>&nbsp;modifier to a&nbsp;<code>struct</code>&nbsp;declaration defines that instances of that type must be stack allocated. In other words, instances of these types can never be created on the heap as a member of another class. The primary motivation for this feature was&nbsp;Span&lt;T&gt;&nbsp;and related structures.</p>\r\n<p>\r\n\tThe goal of keeping a&nbsp;<code>ref struct</code>&nbsp;type as a stack-allocated variable introduces several rules that the compiler enforces for all&nbsp;<code>ref struct</code>&nbsp;types.</p>\r\n<ul>\r\n\t<li>\r\n\t\tYou can&#39;t box a&nbsp;<code>ref struct</code>. You cannot assign a&nbsp;<code>ref struct</code>&nbsp;type to a variable of type&nbsp;<code>object</code>,&nbsp;<code>dynamic</code>, or any interface type.</li>\r\n\t<li>\r\n\t\t<code>ref struct</code>&nbsp;types cannot implement interfaces.</li>\r\n\t<li>\r\n\t\tYou can&#39;t declare a&nbsp;<code>ref struct</code>&nbsp;as a member of a class or a normal struct.</li>\r\n\t<li>\r\n\t\tYou cannot declare local variables that are&nbsp;<code>ref struct</code>&nbsp;types in async methods. You can declare them in synchronous methods that return&nbsp;Task,&nbsp;Task&lt;TResult&gt;&nbsp;or&nbsp;<code>Task</code>-like types.</li>\r\n\t<li>\r\n\t\tYou cannot declare&nbsp;<code>ref struct</code>&nbsp;local variables in iterators.</li>\r\n\t<li>\r\n\t\tYou cannot capture&nbsp;<code>ref struct</code>&nbsp;variables in lambda expressions or local functions.</li>\r\n</ul>\r\n<p>\r\n\tThese restrictions ensure you don&#39;t accidentally use a&nbsp;<code>ref struct</code>&nbsp;in a manner that could promote it to the managed heap.</p>\r\n<p>\r\n\tYou can combine modifiers to declare a struct as&nbsp;<code>readonly ref</code>. A&nbsp;<code>readonly ref struct</code>&nbsp;combines the benefits and restrictions of&nbsp;<code>ref struct</code>&nbsp;and&nbsp;<code>readonly struct</code>&nbsp;declarations.</p>"
          },
          {
            "out (Parameter Modifier)": "<p>\r\n\tThe&nbsp;<code>out</code>&nbsp;keyword causes arguments to be passed by reference. It is like the&nbsp;ref&nbsp;keyword, except that&nbsp;<code>ref</code>&nbsp;requires that the variable be initialized before it is passed. It is also like the&nbsp;in&nbsp;keyword, except that&nbsp;<code>in</code>&nbsp;does not allow the called method to modify the argument value. To use an&nbsp;<code>out</code>parameter, both the method definition and the calling method must explicitly use the&nbsp;<code>out</code>keyword. For example:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>int</span> initializeInMethod;\r\nOutArgExample(<span>out</span> initializeInMethod);\r\nConsole.WriteLine(initializeInMethod);     <span>// value is now 44</span>\r\n\r\n<span><span>void</span> <span>OutArgExample</span>(<span><span>out</span> <span>int</span> number</span>)\r\n</span>{\r\n    number = <span>44</span>;\r\n}\r\n</code></pre>\r\n<div>\r\n\t<blockquote>\r\n\t\t<p>\r\n\t\t\t&nbsp;Note</p>\r\n\t\t<p>\r\n\t\t\tThe&nbsp;<code>out</code>&nbsp;keyword can also be used with a generic type parameter to specify that the type parameter is covariant. For more information on the use of the&nbsp;<code>out</code>&nbsp;keyword in this context, see&nbsp;out (Generic Modifier).</p>\r\n\t</blockquote>\r\n</div>\r\n<p>\r\n\tVariables passed as&nbsp;<code>out</code>&nbsp;arguments do not have to be initialized before being passed in a method call. However, the called method is required to assign a value before the method returns.</p>\r\n<p>\r\n\tAlthough the&nbsp;<code>in</code>,&nbsp;<code>ref</code>, and&nbsp;<code>out</code>&nbsp;keywords cause different run-time behavior, they are not considered part of the method signature at compile time. Therefore, methods cannot be overloaded if the only difference is that one method takes a&nbsp;<code>ref</code>&nbsp;or&nbsp;<code>in</code>&nbsp;argument and the other takes an&nbsp;<code>out</code>&nbsp;argument. The following code, for example, will not compile:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>CS0663_Example</span>\r\n{\r\n    <span>// Compiler error CS0663: &quot;Cannot define overloaded </span>\r\n    <span>// methods that differ only on ref and out&quot;.</span>\r\n    <span><span>public</span> <span>void</span> <span>SampleMethod</span>(<span><span>out</span> <span>int</span> i</span>) </span>{ }\r\n    <span><span>public</span> <span>void</span> <span>SampleMethod</span>(<span><span>ref</span> <span>int</span> i</span>) </span>{ }\r\n}\r\n</code></pre>\r\n<p>\r\n\tOverloading is legal, however, if one method takes a&nbsp;<code>ref</code>,&nbsp;<code>in</code>, or&nbsp;<code>out</code>&nbsp;argument and the other has none of those modifiers, like this:</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>class</span> <span>OutOverloadExample</span>\r\n{\r\n    <span><span>public</span> <span>void</span> <span>SampleMethod</span>(<span><span>int</span> i</span>) </span>{ }\r\n    <span><span>public</span> <span>void</span> <span>SampleMethod</span>(<span><span>out</span> <span>int</span> i</span>) </span>=&gt; i = <span>5</span>;\r\n}\r\n</code></pre>\r\n<p>\r\n\tThe compiler chooses the best overload by matching the parameter modifiers at the call site to the parameter modifiers used in the method call.</p>\r\n<p>\r\n\tProperties are not variables and therefore cannot be passed as&nbsp;<code>out</code>&nbsp;parameters.</p>\r\n<p>\r\n\tYou can&#39;t use the&nbsp;<code>in</code>,&nbsp;<code>ref</code>, and&nbsp;<code>out</code>&nbsp;keywords for the following kinds of methods:</p>\r\n<ul>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tAsync methods, which you define by using the&nbsp;async&nbsp;modifier.</p>\r\n\t</li>\r\n\t<li>\r\n\t\t<p>\r\n\t\t\tIterator methods, which include a&nbsp;yield return&nbsp;or&nbsp;<code>yield break</code>&nbsp;statement.</p>\r\n\t</li>\r\n</ul>\r\n<h2>\r\n\tDeclaring&nbsp;<code>out</code>&nbsp;arguments</h2>\r\n<p>\r\n\tDeclaring a method with&nbsp;<code>out</code>&nbsp;arguments is useful when you want a method to return multiple values. The following example uses&nbsp;<code>out</code>&nbsp;to return three variables with a single method call. Note that the third argument is assigned to null. This enables methods to return values optionally.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span><span>void</span> <span>Method</span>(<span><span>out</span> <span>int</span> answer, <span>out</span> <span>string</span> message, <span>out</span> <span>string</span> stillNull</span>)\r\n</span>{\r\n    answer = <span>44</span>;\r\n    message = <span>&quot;I&#39;ve been returned&quot;</span>;\r\n    stillNull = <span>null</span>;\r\n}\r\n\r\n<span>int</span> argNumber;\r\n<span>string</span> argMessage, argDefault;\r\nMethod(<span>out</span> argNumber, <span>out</span> argMessage, <span>out</span> argDefault);\r\nConsole.WriteLine(argNumber);\r\nConsole.WriteLine(argMessage);\r\nConsole.WriteLine(argDefault == <span>null</span>);\r\n</code></pre>\r\n<p>\r\n\tThe&nbsp;Try pattern&nbsp;involves returning a&nbsp;<code>bool</code>&nbsp;to indicate whether an operation succeeded or failed, and returning the value produced by the operation in an&nbsp;<code>out</code>&nbsp;argument. A number of parsing methods, such as the&nbsp;DateTime.TryParse&nbsp;method, use this pattern.</p>\r\n<h2>\r\n\tCalling a method with an&nbsp;<code>out</code>&nbsp;argument</h2>\r\n<p>\r\n\tIn C# 6 and earlier, you must declare a variable in a separate statement before you pass it as an&nbsp;<code>out</code>&nbsp;argument. The following example declares a variable named&nbsp;<code>number</code>&nbsp;before it is passed to the&nbsp;Int32.TryParse&nbsp;method, which attempts to convert a string to a number.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> numberAsString = <span>&quot;1640&quot;</span>;\r\n\r\n<span>int</span> number;\r\n<span>if</span> (Int32.TryParse(numberAsString, <span>out</span> number))\r\n    Console.WriteLine(<span>$&quot;Converted &#39;<span>{numberAsString}</span>&#39; to <span>{number}</span>&quot;</span>);\r\n<span>else</span>\r\n    Console.WriteLine(<span>$&quot;Unable to convert &#39;<span>{numberAsString}</span>&#39;&quot;</span>);\r\n<span>// The example displays the following output:</span>\r\n<span>//       Converted &#39;1640&#39; to 1640</span>\r\n</code></pre>\r\n<p>\r\n\tStarting with C# 7.0, you can declare the&nbsp;<code>out</code>&nbsp;variable in the argument list of the method call, rather than in a separate variable declaration. This produces more compact, readable code, and also prevents you from inadvertently assigning a value to the variable before the method call. The following example is like the previous example, except that it defines the&nbsp;<code>number</code>&nbsp;variable in the call to the&nbsp;Int32.TryParse&nbsp;method.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> numberAsString = <span>&quot;1640&quot;</span>;\r\n\r\n<span>if</span> (Int32.TryParse(numberAsString, <span>out</span> <span>int</span> number))\r\n    Console.WriteLine(<span>$&quot;Converted &#39;<span>{numberAsString}</span>&#39; to <span>{number}</span>&quot;</span>);\r\n<span>else</span>\r\n    Console.WriteLine(<span>$&quot;Unable to convert &#39;<span>{numberAsString}</span>&#39;&quot;</span>);\r\n<span>// The example displays the following output:</span>\r\n<span>//       Converted &#39;1640&#39; to 1640</span>\r\n</code></pre>\r\n<p>\r\n\tIn the previous example, the&nbsp;<code>number</code>&nbsp;variable is strongly typed as an&nbsp;<code>int</code>. You can also declare an implicitly typed local variable, as the following example does.</p>\r\n<div>\r\n\t&nbsp;</div>\r\n<pre>\r\n<code><span>string</span> numberAsString = <span>&quot;1640&quot;</span>;\r\n\r\n<span>if</span> (Int32.TryParse(numberAsString, <span>out</span> <span>var</span> number))\r\n    Console.WriteLine(<span>$&quot;Converted &#39;<span>{numberAsString}</span>&#39; to <span>{number}</span>&quot;</span>);\r\n<span>else</span>\r\n    Console.WriteLine(<span>$&quot;Unable to convert &#39;<span>{numberAsString}</span>&#39;&quot;</span>);\r\n<span>// The example displays the following output:</span>\r\n<span>//       Converted &#39;1640&#39; to 1640</span></code></pre>"
          }
        ]
      ]
    }
  }
]